diff --git a/node_modules/cockatiel/dist/BulkheadPolicy.d.ts b/node_modules/cockatiel/dist/BulkheadPolicy.d.ts
index c7f64e5..0151b18 100644
--- a/node_modules/cockatiel/dist/BulkheadPolicy.d.ts
+++ b/node_modules/cockatiel/dist/BulkheadPolicy.d.ts
@@ -36,6 +36,6 @@ export declare class BulkheadPolicy implements IPolicy {
      * @param fn Function to execute
      * @throws a {@link BulkheadRejectedException} if the bulkhead limits are exceeeded
      */
-    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
+    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: import("./common/LocalAbortController").LocalAbortSignal): Promise<T>;
     private dequeue;
 }
diff --git a/node_modules/cockatiel/dist/BulkheadPolicy.js.map b/node_modules/cockatiel/dist/BulkheadPolicy.js.map
index 195e65d..65464d5 100644
--- a/node_modules/cockatiel/dist/BulkheadPolicy.js.map
+++ b/node_modules/cockatiel/dist/BulkheadPolicy.js.map
@@ -1 +1 @@
-{"version":3,"file":"BulkheadPolicy.js","sourceRoot":"","sources":["../src/BulkheadPolicy.ts"],"names":[],"mappings":";;;AAAA,0CAAoD;AACpD,0CAAuC;AACvC,0CAA8C;AAC9C,gDAAmD;AACnD,0EAAuE;AACvE,4CAAqD;AAUrD,MAAa,cAAc;IAuBzB;;OAEG;IACH,IAAW,cAAc;QACvB,OAAO,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;IACrC,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,YACmB,QAAgB,EAChB,aAAqB;QADrB,aAAQ,GAAR,QAAQ,CAAQ;QAChB,kBAAa,GAAb,aAAa,CAAQ;QAvChC,WAAM,GAAG,CAAC,CAAC;QACF,UAAK,GAA+B,EAAE,CAAC;QACvC,oBAAe,GAAG,IAAI,oBAAY,EAAQ,CAAC;QAC3C,aAAQ,GAAG,IAAI,yBAAc,EAAE,CAAC;QAEjD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,aAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC;IAsBzD,CAAC;IAEJ;;;;OAIG;IACI,KAAK,CAAC,OAAO,CAClB,EAA0D,EAC1D,MAAM,GAAG,0BAAkB;QAE3B,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,2BAAkB,EAAE,CAAC;QACjC,CAAC;QAED,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAChC,IAAI,CAAC,MAAM,EAAE,CAAC;YACd,IAAI,CAAC;gBACH,OAAO,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;YAC9B,CAAC;oBAAS,CAAC;gBACT,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,IAAI,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACH,CAAC;QAED,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YAC3C,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAA,aAAK,GAAK,CAAC;YAChD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;YACjD,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QAC5B,MAAM,IAAI,6CAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;IACrE,CAAC;IAEO,OAAO;QACb,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAChC,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,OAAO;QACT,CAAC;QAED,OAAO,CAAC,OAAO,EAAE;aACd,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aAC9C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;aAClB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACxB,CAAC;CACF;AAzFD,wCAyFC","sourcesContent":["import { neverAbortedSignal } from './common/abort';\nimport { defer } from './common/defer';\nimport { EventEmitter } from './common/Event';\nimport { ExecuteWrapper } from './common/Executor';\nimport { BulkheadRejectedError } from './errors/BulkheadRejectedError';\nimport { TaskCancelledError } from './errors/Errors';\nimport { IDefaultPolicyContext, IPolicy } from './Policy';\n\ninterface IQueueItem<T> {\n  signal: AbortSignal;\n  fn(context: IDefaultPolicyContext): Promise<T> | T;\n  resolve(value: T): void;\n  reject(error: Error): void;\n}\n\nexport class BulkheadPolicy implements IPolicy {\n  public declare readonly _altReturn: never;\n\n  private active = 0;\n  private readonly queue: Array<IQueueItem<unknown>> = [];\n  private readonly onRejectEmitter = new EventEmitter<void>();\n  private readonly executor = new ExecuteWrapper();\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * Emitter that fires when an item is rejected from the bulkhead.\n   */\n  public readonly onReject = this.onRejectEmitter.addListener;\n\n  /**\n   * Returns the number of available execution slots at this point in time.\n   */\n  public get executionSlots() {\n    return this.capacity - this.active;\n  }\n\n  /**\n   * Returns the number of queue slots at this point in time.\n   */\n  public get queueSlots() {\n    return this.queueCapacity - this.queue.length;\n  }\n\n  /**\n   * Bulkhead limits concurrent requests made.\n   */\n  constructor(\n    private readonly capacity: number,\n    private readonly queueCapacity: number,\n  ) {}\n\n  /**\n   * Executes the given function.\n   * @param fn Function to execute\n   * @throws a {@link BulkheadRejectedException} if the bulkhead limits are exceeeded\n   */\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T> {\n    if (signal.aborted) {\n      throw new TaskCancelledError();\n    }\n\n    if (this.active < this.capacity) {\n      this.active++;\n      try {\n        return await fn({ signal });\n      } finally {\n        this.active--;\n        this.dequeue();\n      }\n    }\n\n    if (this.queue.length < this.queueCapacity) {\n      const { resolve, reject, promise } = defer<T>();\n      this.queue.push({ signal, fn, resolve, reject });\n      return promise;\n    }\n\n    this.onRejectEmitter.emit();\n    throw new BulkheadRejectedError(this.capacity, this.queueCapacity);\n  }\n\n  private dequeue() {\n    const item = this.queue.shift();\n    if (!item) {\n      return;\n    }\n\n    Promise.resolve()\n      .then(() => this.execute(item.fn, item.signal))\n      .then(item.resolve)\n      .catch(item.reject);\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"BulkheadPolicy.js","sourceRoot":"","sources":["../src/BulkheadPolicy.ts"],"names":[],"mappings":";;;AAAA,0CAAoD;AACpD,0CAAuC;AACvC,0CAA8C;AAC9C,gDAAmD;AACnD,0EAAuE;AACvE,4CAAqD;AAWrD,MAAa,cAAc;IAuBzB;;OAEG;IACH,IAAW,cAAc;QACvB,OAAO,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;IACrC,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,YACmB,QAAgB,EAChB,aAAqB;QADrB,aAAQ,GAAR,QAAQ,CAAQ;QAChB,kBAAa,GAAb,aAAa,CAAQ;QAvChC,WAAM,GAAG,CAAC,CAAC;QACF,UAAK,GAA+B,EAAE,CAAC;QACvC,oBAAe,GAAG,IAAI,oBAAY,EAAQ,CAAC;QAC3C,aAAQ,GAAG,IAAI,yBAAc,EAAE,CAAC;QAEjD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,aAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC;IAsBzD,CAAC;IAEJ;;;;OAIG;IACI,KAAK,CAAC,OAAO,CAClB,EAA0D,EAC1D,MAAM,GAAG,0BAAkB;QAE3B,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,2BAAkB,EAAE,CAAC;QACjC,CAAC;QAED,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAChC,IAAI,CAAC,MAAM,EAAE,CAAC;YACd,IAAI,CAAC;gBACH,OAAO,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;YAC9B,CAAC;oBAAS,CAAC;gBACT,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,IAAI,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACH,CAAC;QAED,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YAC3C,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAA,aAAK,GAAK,CAAC;YAChD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;YACjD,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QAC5B,MAAM,IAAI,6CAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;IACrE,CAAC;IAEO,OAAO;QACb,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAChC,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,OAAO;QACT,CAAC;QAED,OAAO,CAAC,OAAO,EAAE;aACd,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aAC9C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;aAClB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACxB,CAAC;CACF;AAzFD,wCAyFC","sourcesContent":["import { neverAbortedSignal } from './common/abort';\nimport { defer } from './common/defer';\nimport { EventEmitter } from './common/Event';\nimport { ExecuteWrapper } from './common/Executor';\nimport { BulkheadRejectedError } from './errors/BulkheadRejectedError';\nimport { TaskCancelledError } from './errors/Errors';\nimport { IDefaultPolicyContext, IPolicy } from './Policy';\nimport { AbortSignal } from './common/LocalAbortController';\n\ninterface IQueueItem<T> {\n  signal: AbortSignal;\n  fn(context: IDefaultPolicyContext): Promise<T> | T;\n  resolve(value: T): void;\n  reject(error: Error): void;\n}\n\nexport class BulkheadPolicy implements IPolicy {\n  public declare readonly _altReturn: never;\n\n  private active = 0;\n  private readonly queue: Array<IQueueItem<unknown>> = [];\n  private readonly onRejectEmitter = new EventEmitter<void>();\n  private readonly executor = new ExecuteWrapper();\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * Emitter that fires when an item is rejected from the bulkhead.\n   */\n  public readonly onReject = this.onRejectEmitter.addListener;\n\n  /**\n   * Returns the number of available execution slots at this point in time.\n   */\n  public get executionSlots() {\n    return this.capacity - this.active;\n  }\n\n  /**\n   * Returns the number of queue slots at this point in time.\n   */\n  public get queueSlots() {\n    return this.queueCapacity - this.queue.length;\n  }\n\n  /**\n   * Bulkhead limits concurrent requests made.\n   */\n  constructor(\n    private readonly capacity: number,\n    private readonly queueCapacity: number,\n  ) {}\n\n  /**\n   * Executes the given function.\n   * @param fn Function to execute\n   * @throws a {@link BulkheadRejectedException} if the bulkhead limits are exceeeded\n   */\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T> {\n    if (signal.aborted) {\n      throw new TaskCancelledError();\n    }\n\n    if (this.active < this.capacity) {\n      this.active++;\n      try {\n        return await fn({ signal });\n      } finally {\n        this.active--;\n        this.dequeue();\n      }\n    }\n\n    if (this.queue.length < this.queueCapacity) {\n      const { resolve, reject, promise } = defer<T>();\n      this.queue.push({ signal, fn, resolve, reject });\n      return promise;\n    }\n\n    this.onRejectEmitter.emit();\n    throw new BulkheadRejectedError(this.capacity, this.queueCapacity);\n  }\n\n  private dequeue() {\n    const item = this.queue.shift();\n    if (!item) {\n      return;\n    }\n\n    Promise.resolve()\n      .then(() => this.execute(item.fn, item.signal))\n      .then(item.resolve)\n      .catch(item.reject);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/Executor.bench.d.ts b/node_modules/cockatiel/dist/BulkheadPolicy.test.d.ts
similarity index 100%
rename from node_modules/cockatiel/dist/esm/common/Executor.bench.d.ts
rename to node_modules/cockatiel/dist/BulkheadPolicy.test.d.ts
diff --git a/node_modules/cockatiel/dist/BulkheadPolicy.test.js b/node_modules/cockatiel/dist/BulkheadPolicy.test.js
new file mode 100644
index 0000000..8d9d89e
--- /dev/null
+++ b/node_modules/cockatiel/dist/BulkheadPolicy.test.js
@@ -0,0 +1,130 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const util_1 = require("util");
+const abort_1 = require("./common/abort");
+const defer_1 = require("./common/defer");
+const LocalAbortController_1 = require("./common/LocalAbortController");
+const BulkheadRejectedError_1 = require("./errors/BulkheadRejectedError");
+const Errors_1 = require("./errors/Errors");
+const Policy_1 = require("./Policy");
+const delay = (0, util_1.promisify)(setTimeout);
+describe('Bulkhead', () => {
+    let order = [];
+    let fnIndex = 0;
+    beforeEach(() => {
+        order = [];
+        fnIndex = 0;
+    });
+    const makeFn = () => {
+        const index = fnIndex++;
+        return async () => {
+            order.push(`${index}: enter`);
+            await delay(index * 2);
+            order.push(`${index}: exit`);
+            return index;
+        };
+    };
+    const makeFns = (count) => {
+        const out = [];
+        for (let i = 0; i < count; i++) {
+            out.push(makeFn());
+        }
+        return out;
+    };
+    it('rejects calls after limit is hit', async () => {
+        const b = (0, Policy_1.bulkhead)(2);
+        const funcs = makeFns(3);
+        const output = funcs.map(fn => b.execute(fn));
+        await Promise.all([
+            (0, chai_1.expect)(output[0]).to.eventually.equal(0),
+            (0, chai_1.expect)(output[1]).to.eventually.equal(1),
+            (0, chai_1.expect)(output[2]).to.be.rejectedWith(BulkheadRejectedError_1.BulkheadRejectedError),
+        ]);
+        (0, chai_1.expect)(order).to.deep.equal(['0: enter', '1: enter', '0: exit', '1: exit']);
+    });
+    it('queues requests, and rejects after queue limit', async () => {
+        const b = (0, Policy_1.bulkhead)(2, 2);
+        const funcs = makeFns(5);
+        const output = funcs.map(fn => b.execute(fn));
+        await Promise.all([
+            (0, chai_1.expect)(output[0]).to.eventually.equal(0),
+            (0, chai_1.expect)(output[1]).to.eventually.equal(1),
+            (0, chai_1.expect)(output[2]).to.eventually.equal(2),
+            (0, chai_1.expect)(output[3]).to.eventually.equal(3),
+            (0, chai_1.expect)(output[4]).to.be.rejectedWith(BulkheadRejectedError_1.BulkheadRejectedError),
+        ]);
+        (0, chai_1.expect)(order).to.deep.equal([
+            '0: enter',
+            '1: enter',
+            '0: exit',
+            '2: enter',
+            '1: exit',
+            '3: enter',
+            '2: exit',
+            '3: exit',
+        ]);
+    });
+    it('maintains proper state', async () => {
+        const b = (0, Policy_1.bulkhead)(2, 2);
+        const defer1 = (0, defer_1.defer)();
+        const defer2 = (0, defer_1.defer)();
+        const defer3 = (0, defer_1.defer)();
+        const defer4 = (0, defer_1.defer)();
+        (0, chai_1.expect)(b.queueSlots).to.equal(2);
+        (0, chai_1.expect)(b.executionSlots).to.equal(2);
+        const out1 = b.execute(() => defer1.promise);
+        (0, chai_1.expect)(b.queueSlots).to.equal(2);
+        (0, chai_1.expect)(b.executionSlots).to.equal(1);
+        const out2 = b.execute(() => defer2.promise);
+        (0, chai_1.expect)(b.queueSlots).to.equal(2);
+        (0, chai_1.expect)(b.executionSlots).to.equal(0);
+        const out3 = b.execute(() => defer3.promise);
+        (0, chai_1.expect)(b.queueSlots).to.equal(1);
+        (0, chai_1.expect)(b.executionSlots).to.equal(0);
+        const out4 = b.execute(() => defer4.promise);
+        (0, chai_1.expect)(b.queueSlots).to.equal(0);
+        (0, chai_1.expect)(b.executionSlots).to.equal(0);
+        defer1.resolve(undefined);
+        await out1;
+        (0, chai_1.expect)(b.executionSlots).to.equal(0);
+        (0, chai_1.expect)(b.queueSlots).to.equal(1);
+        defer2.resolve(undefined);
+        await out2;
+        (0, chai_1.expect)(b.executionSlots).to.equal(0);
+        (0, chai_1.expect)(b.queueSlots).to.equal(2);
+        defer3.resolve(undefined);
+        await out3;
+        (0, chai_1.expect)(b.executionSlots).to.equal(1);
+        (0, chai_1.expect)(b.queueSlots).to.equal(2);
+        defer4.resolve(undefined);
+        await out4;
+        (0, chai_1.expect)(b.executionSlots).to.equal(2);
+        (0, chai_1.expect)(b.queueSlots).to.equal(2);
+    });
+    it('links parent cancellation token', async () => {
+        const b = (0, Policy_1.bulkhead)(1, Infinity);
+        const todo = [];
+        for (let i = 0; i < 3; i++) {
+            const parent = (0, LocalAbortController_1.createAbortController)();
+            todo.push(b.execute(async ({ signal }) => {
+                await delay(1);
+                (0, chai_1.expect)(signal.aborted).to.be.false;
+                parent.abort();
+                (0, chai_1.expect)(signal.aborted).to.be.true;
+            }, parent.signal));
+        }
+        // initially cancelled
+        todo.push((0, chai_1.expect)(b.execute(() => {
+            throw new Error('expected not to call');
+        }, abort_1.abortedSignal)).to.be.rejectedWith(Errors_1.TaskCancelledError));
+        // cancelled by the time it gets executed
+        const cancelledCts = (0, LocalAbortController_1.createAbortController)();
+        setTimeout(() => cancelledCts.abort(), 2);
+        todo.push((0, chai_1.expect)(b.execute(() => {
+            throw new Error('expected not to call');
+        }, cancelledCts.signal)).to.be.rejectedWith(Errors_1.TaskCancelledError));
+        await Promise.all(todo);
+    });
+});
+//# sourceMappingURL=BulkheadPolicy.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/BulkheadPolicy.test.js.map b/node_modules/cockatiel/dist/BulkheadPolicy.test.js.map
new file mode 100644
index 0000000..adbc55f
--- /dev/null
+++ b/node_modules/cockatiel/dist/BulkheadPolicy.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"BulkheadPolicy.test.js","sourceRoot":"","sources":["../src/BulkheadPolicy.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from 'chai';\nimport { promisify } from 'util';\nimport { abortedSignal } from './common/abort';\nimport { defer } from './common/defer';\nimport { createAbortController } from './common/LocalAbortController';\nimport { BulkheadRejectedError } from './errors/BulkheadRejectedError';\nimport { TaskCancelledError } from './errors/Errors';\nimport { bulkhead } from './Policy';\n\nconst delay = promisify(setTimeout);\n\ndescribe('Bulkhead', () => {\n  let order: string[] = [];\n  let fnIndex = 0;\n  beforeEach(() => {\n    order = [];\n    fnIndex = 0;\n  });\n\n  const makeFn = () => {\n    const index = fnIndex++;\n    return async () => {\n      order.push(`${index}: enter`);\n      await delay(index * 2);\n      order.push(`${index}: exit`);\n      return index;\n    };\n  };\n\n  const makeFns = (count: number) => {\n    const out: Array<() => void> = [];\n    for (let i = 0; i < count; i++) {\n      out.push(makeFn());\n    }\n    return out;\n  };\n\n  it('rejects calls after limit is hit', async () => {\n    const b = bulkhead(2);\n    const funcs = makeFns(3);\n    const output = funcs.map(fn => b.execute(fn));\n\n    await Promise.all([\n      expect(output[0]).to.eventually.equal(0),\n      expect(output[1]).to.eventually.equal(1),\n      expect(output[2]).to.be.rejectedWith(BulkheadRejectedError),\n    ]);\n\n    expect(order).to.deep.equal(['0: enter', '1: enter', '0: exit', '1: exit']);\n  });\n\n  it('queues requests, and rejects after queue limit', async () => {\n    const b = bulkhead(2, 2);\n    const funcs = makeFns(5);\n    const output = funcs.map(fn => b.execute(fn));\n\n    await Promise.all([\n      expect(output[0]).to.eventually.equal(0),\n      expect(output[1]).to.eventually.equal(1),\n      expect(output[2]).to.eventually.equal(2),\n      expect(output[3]).to.eventually.equal(3),\n      expect(output[4]).to.be.rejectedWith(BulkheadRejectedError),\n    ]);\n\n    expect(order).to.deep.equal([\n      '0: enter',\n      '1: enter',\n      '0: exit',\n      '2: enter',\n      '1: exit',\n      '3: enter',\n      '2: exit',\n      '3: exit',\n    ]);\n  });\n\n  it('maintains proper state', async () => {\n    const b = bulkhead(2, 2);\n    const defer1 = defer();\n    const defer2 = defer();\n    const defer3 = defer();\n    const defer4 = defer();\n\n    expect(b.queueSlots).to.equal(2);\n    expect(b.executionSlots).to.equal(2);\n\n    const out1 = b.execute(() => defer1.promise);\n    expect(b.queueSlots).to.equal(2);\n    expect(b.executionSlots).to.equal(1);\n\n    const out2 = b.execute(() => defer2.promise);\n    expect(b.queueSlots).to.equal(2);\n    expect(b.executionSlots).to.equal(0);\n\n    const out3 = b.execute(() => defer3.promise);\n    expect(b.queueSlots).to.equal(1);\n    expect(b.executionSlots).to.equal(0);\n\n    const out4 = b.execute(() => defer4.promise);\n    expect(b.queueSlots).to.equal(0);\n    expect(b.executionSlots).to.equal(0);\n\n    defer1.resolve(undefined);\n    await out1;\n    expect(b.executionSlots).to.equal(0);\n    expect(b.queueSlots).to.equal(1);\n\n    defer2.resolve(undefined);\n    await out2;\n    expect(b.executionSlots).to.equal(0);\n    expect(b.queueSlots).to.equal(2);\n\n    defer3.resolve(undefined);\n    await out3;\n    expect(b.executionSlots).to.equal(1);\n    expect(b.queueSlots).to.equal(2);\n\n    defer4.resolve(undefined);\n    await out4;\n    expect(b.executionSlots).to.equal(2);\n    expect(b.queueSlots).to.equal(2);\n  });\n\n  it('links parent cancellation token', async () => {\n    const b = bulkhead(1, Infinity);\n    const todo: Array<PromiseLike<void>> = [];\n    for (let i = 0; i < 3; i++) {\n      const parent = createAbortController();\n      todo.push(\n        b.execute(async ({ signal }) => {\n          await delay(1);\n          expect(signal.aborted).to.be.false;\n          parent.abort();\n          expect(signal.aborted).to.be.true;\n        }, parent.signal),\n      );\n    }\n\n    // initially cancelled\n    todo.push(\n      expect(\n        b.execute(() => {\n          throw new Error('expected not to call');\n        }, abortedSignal),\n      ).to.be.rejectedWith(TaskCancelledError),\n    );\n\n    // cancelled by the time it gets executed\n    const cancelledCts = createAbortController();\n    setTimeout(() => cancelledCts.abort(), 2);\n    todo.push(\n      expect(\n        b.execute(() => {\n          throw new Error('expected not to call');\n        }, cancelledCts.signal),\n      ).to.be.rejectedWith(TaskCancelledError),\n    );\n\n    await Promise.all(todo);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/CircuitBreakerPolicy.d.ts b/node_modules/cockatiel/dist/CircuitBreakerPolicy.d.ts
index b519a94..349c70e 100644
--- a/node_modules/cockatiel/dist/CircuitBreakerPolicy.d.ts
+++ b/node_modules/cockatiel/dist/CircuitBreakerPolicy.d.ts
@@ -113,7 +113,7 @@ export declare class CircuitBreakerPolicy implements IPolicy {
      * open via {@link CircuitBreakerPolicy.isolate}
      * @returns a Promise that resolves or rejects with the function results.
      */
-    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
+    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: import("./common/LocalAbortController").LocalAbortSignal): Promise<T>;
     /**
      * Captures circuit breaker state that can later be used to recreate the
      * breaker by passing `state` to the `circuitBreaker` function. This is
diff --git a/node_modules/cockatiel/dist/CircuitBreakerPolicy.js.map b/node_modules/cockatiel/dist/CircuitBreakerPolicy.js.map
index 4959fa4..7929c6a 100644
--- a/node_modules/cockatiel/dist/CircuitBreakerPolicy.js.map
+++ b/node_modules/cockatiel/dist/CircuitBreakerPolicy.js.map
@@ -1 +1 @@
-{"version":3,"file":"CircuitBreakerPolicy.js","sourceRoot":"","sources":["../src/CircuitBreakerPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConstantBackoff, IBackoff, IBackoffFactory } from './backoff/Backoff';\nimport { IBreaker } from './breaker/Breaker';\nimport { neverAbortedSignal } from './common/abort';\nimport { EventEmitter } from './common/Event';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { BrokenCircuitError, HydratingCircuitError, TaskCancelledError } from './errors/Errors';\nimport { IsolatedCircuitError } from './errors/IsolatedCircuitError';\nimport { FailureReason, IDefaultPolicyContext, IPolicy } from './Policy';\n\nexport enum CircuitState {\n  /**\n   * Normal operation. Execution of actions allowed.\n   */\n  Closed,\n\n  /**\n   * The automated controller has opened the circuit. Execution of actions blocked.\n   */\n  Open,\n\n  /**\n   * Recovering from open state, after the automated break duration has\n   * expired. Execution of actions permitted. Success of subsequent action/s\n   * controls onward transition to Open or Closed state.\n   */\n  HalfOpen,\n\n  /**\n   * Circuit held manually in an open state. Execution of actions blocked.\n   */\n  Isolated,\n}\n\n/**\n * Context passed into halfOpenAfter backoff delegate.\n */\nexport interface IHalfOpenAfterBackoffContext extends IDefaultPolicyContext {\n  /**\n   * The consecutive number of times the circuit has entered the\n   * {@link CircuitState.Open} state.\n   */\n  attempt: number;\n  /**\n   * The result of the last method call that caused the circuit to enter the\n   * {@link CircuitState.Open} state. Either a thrown error, or a value that we\n   * determined should open the circuit.\n   */\n  result: FailureReason<unknown>;\n}\n\nexport interface ICircuitBreakerOptions {\n  breaker: IBreaker;\n\n  /**\n   * When to (potentially) enter the {@link CircuitState.HalfOpen} state from\n   * the {@link CircuitState.Open} state. Either a duration in milliseconds or a\n   * backoff factory.\n   */\n  halfOpenAfter: number | IBackoffFactory<IHalfOpenAfterBackoffContext>;\n\n  /**\n   * Initial state from a previous call to {@link CircuitBreakerPolicy.toJSON}.\n   */\n  initialState?: unknown;\n}\n\ntype InnerState =\n  | { value: CircuitState.Closed }\n  | { value: CircuitState.Isolated; counters: number }\n  | {\n      value: CircuitState.Open;\n      openedAt: number;\n      attemptNo: number;\n      backoff: IBackoff<IHalfOpenAfterBackoffContext>;\n    }\n  | {\n      value: CircuitState.HalfOpen;\n      test: Promise<any>;\n      attemptNo: number;\n      backoff: IBackoff<IHalfOpenAfterBackoffContext>;\n    };\n\ninterface ISerializedState {\n  ownState: Partial<InnerState>;\n  breakerState: unknown;\n}\n\nexport class CircuitBreakerPolicy implements IPolicy {\n  declare readonly _altReturn: never;\n\n  private readonly breakEmitter = new EventEmitter<FailureReason<unknown> | { isolated: true }>();\n  private readonly resetEmitter = new EventEmitter<void>();\n  private readonly halfOpenEmitter = new EventEmitter<void>();\n  private readonly stateChangeEmitter = new EventEmitter<CircuitState>();\n  private readonly halfOpenAfterBackoffFactory: IBackoffFactory<IHalfOpenAfterBackoffContext>;\n  private innerLastFailure?: FailureReason<unknown>;\n  private innerState: InnerState = { value: CircuitState.Closed };\n\n  /**\n   * Event emitted when the circuit breaker opens.\n   */\n  public readonly onBreak = this.breakEmitter.addListener;\n\n  /**\n   * Event emitted when the circuit breaker resets.\n   */\n  public readonly onReset = this.resetEmitter.addListener;\n\n  /**\n   * Event emitted when the circuit breaker is half open (running a test call).\n   * Either `onBreak` on `onReset` will subsequently fire.\n   */\n  public readonly onHalfOpen = this.halfOpenEmitter.addListener;\n\n  /**\n   * Fired whenever the circuit breaker state changes.\n   */\n  public readonly onStateChange = this.stateChangeEmitter.addListener;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * Gets the current circuit breaker state.\n   */\n  public get state(): CircuitState {\n    return this.innerState.value;\n  }\n\n  /**\n   * Gets the last reason the circuit breaker failed.\n   */\n  public get lastFailure() {\n    return this.innerLastFailure;\n  }\n\n  constructor(\n    private readonly options: ICircuitBreakerOptions,\n    private readonly executor: ExecuteWrapper,\n  ) {\n    this.halfOpenAfterBackoffFactory =\n      typeof options.halfOpenAfter === 'number'\n        ? new ConstantBackoff(options.halfOpenAfter)\n        : options.halfOpenAfter;\n\n    if (options.initialState) {\n      const initialState = options.initialState as ISerializedState;\n      this.innerState = initialState.ownState as InnerState;\n      this.options.breaker.state = initialState.breakerState;\n\n      if (\n        this.innerState.value === CircuitState.Open ||\n        this.innerState.value === CircuitState.HalfOpen\n      ) {\n        this.innerLastFailure = { error: new HydratingCircuitError() };\n        let backoff = this.halfOpenAfterBackoffFactory.next({\n          attempt: 1,\n          result: this.innerLastFailure,\n          signal: neverAbortedSignal,\n        });\n        for (let i = 2; i <= this.innerState.attemptNo; i++) {\n          backoff = backoff.next({\n            attempt: i,\n            result: this.innerLastFailure,\n            signal: neverAbortedSignal,\n          });\n        }\n        this.innerState.backoff = backoff;\n      }\n    }\n  }\n\n  /**\n   * Manually holds open the circuit breaker.\n   * @returns A handle that keeps the breaker open until `.dispose()` is called.\n   */\n  public isolate() {\n    if (this.innerState.value !== CircuitState.Isolated) {\n      this.innerState = { value: CircuitState.Isolated, counters: 0 };\n      this.breakEmitter.emit({ isolated: true });\n      this.stateChangeEmitter.emit(CircuitState.Isolated);\n    }\n\n    this.innerState.counters++;\n\n    let disposed = false;\n    return {\n      dispose: () => {\n        if (disposed) {\n          return;\n        }\n\n        disposed = true;\n        if (this.innerState.value === CircuitState.Isolated && !--this.innerState.counters) {\n          this.innerState = { value: CircuitState.Closed };\n          this.resetEmitter.emit();\n          this.stateChangeEmitter.emit(CircuitState.Closed);\n        }\n      },\n    };\n  }\n\n  /**\n   * Executes the given function.\n   * @param fn Function to run\n   * @throws a {@link BrokenCircuitError} if the circuit is open\n   * @throws a {@link IsolatedCircuitError} if the circuit is held\n   * open via {@link CircuitBreakerPolicy.isolate}\n   * @returns a Promise that resolves or rejects with the function results.\n   */\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T> {\n    const state = this.innerState;\n    switch (state.value) {\n      case CircuitState.Closed:\n        const result = await this.executor.invoke(fn, { signal });\n        if ('success' in result) {\n          this.options.breaker.success(state.value);\n        } else {\n          this.innerLastFailure = result;\n          if (this.options.breaker.failure(state.value)) {\n            this.open(result, signal);\n          }\n        }\n\n        return returnOrThrow(result);\n\n      case CircuitState.HalfOpen:\n        await state.test.catch(() => undefined);\n        if (this.state === CircuitState.Closed && signal.aborted) {\n          throw new TaskCancelledError();\n        }\n\n        return this.execute(fn);\n\n      case CircuitState.Open:\n        if (Date.now() - state.openedAt < state.backoff.duration) {\n          throw new BrokenCircuitError();\n        }\n        const test = this.halfOpen(fn, signal);\n        this.innerState = {\n          value: CircuitState.HalfOpen,\n          test,\n          backoff: state.backoff,\n          attemptNo: state.attemptNo + 1,\n        };\n        this.stateChangeEmitter.emit(CircuitState.HalfOpen);\n        return test;\n\n      case CircuitState.Isolated:\n        throw new IsolatedCircuitError();\n\n      default:\n        throw new Error(`Unexpected circuit state ${state}`);\n    }\n  }\n\n  /**\n   * Captures circuit breaker state that can later be used to recreate the\n   * breaker by passing `state` to the `circuitBreaker` function. This is\n   * useful in cases like serverless functions where you may want to keep\n   * the breaker state across multiple executions.\n   */\n  public toJSON(): unknown {\n    const state = this.innerState;\n    let ownState: Partial<InnerState>;\n    if (state.value === CircuitState.HalfOpen) {\n      ownState = {\n        value: CircuitState.Open,\n        openedAt: 0,\n        attemptNo: state.attemptNo,\n      };\n    } else if (state.value === CircuitState.Open) {\n      ownState = {\n        value: CircuitState.Open,\n        openedAt: state.openedAt,\n        attemptNo: state.attemptNo,\n      };\n    } else {\n      ownState = state;\n    }\n\n    return { ownState, breakerState: this.options.breaker.state } satisfies ISerializedState;\n  }\n\n  private async halfOpen<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal: AbortSignal,\n  ): Promise<T> {\n    this.halfOpenEmitter.emit();\n\n    try {\n      const result = await this.executor.invoke(fn, { signal });\n      if ('success' in result) {\n        this.options.breaker.success(CircuitState.HalfOpen);\n        this.close();\n      } else {\n        this.innerLastFailure = result;\n        this.options.breaker.failure(CircuitState.HalfOpen);\n        this.open(result, signal);\n      }\n\n      return returnOrThrow(result);\n    } catch (err) {\n      // It's an error, but not one the circuit is meant to retry, so\n      // for our purposes it's a success. Task failed successfully!\n      this.close();\n      throw err;\n    }\n  }\n\n  private open(reason: FailureReason<unknown>, signal: AbortSignal) {\n    if (this.state === CircuitState.Isolated || this.state === CircuitState.Open) {\n      return;\n    }\n\n    const attemptNo =\n      this.innerState.value === CircuitState.HalfOpen ? this.innerState.attemptNo : 1;\n    const context = { attempt: attemptNo, result: reason, signal };\n    const backoff =\n      this.innerState.value === CircuitState.HalfOpen\n        ? this.innerState.backoff.next(context)\n        : this.halfOpenAfterBackoffFactory.next(context);\n\n    this.innerState = { value: CircuitState.Open, openedAt: Date.now(), backoff, attemptNo };\n    this.breakEmitter.emit(reason);\n    this.stateChangeEmitter.emit(CircuitState.Open);\n  }\n\n  private close() {\n    if (this.state === CircuitState.HalfOpen) {\n      this.innerState = { value: CircuitState.Closed };\n      this.resetEmitter.emit();\n      this.stateChangeEmitter.emit(CircuitState.Closed);\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"CircuitBreakerPolicy.js","sourceRoot":"","sources":["../src/CircuitBreakerPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConstantBackoff, IBackoff, IBackoffFactory } from './backoff/Backoff';\nimport { IBreaker } from './breaker/Breaker';\nimport { neverAbortedSignal } from './common/abort';\nimport { EventEmitter } from './common/Event';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { BrokenCircuitError, HydratingCircuitError, TaskCancelledError } from './errors/Errors';\nimport { IsolatedCircuitError } from './errors/IsolatedCircuitError';\nimport { FailureReason, IDefaultPolicyContext, IPolicy } from './Policy';\nimport { AbortSignal } from './common/LocalAbortController';\n\nexport enum CircuitState {\n  /**\n   * Normal operation. Execution of actions allowed.\n   */\n  Closed,\n\n  /**\n   * The automated controller has opened the circuit. Execution of actions blocked.\n   */\n  Open,\n\n  /**\n   * Recovering from open state, after the automated break duration has\n   * expired. Execution of actions permitted. Success of subsequent action/s\n   * controls onward transition to Open or Closed state.\n   */\n  HalfOpen,\n\n  /**\n   * Circuit held manually in an open state. Execution of actions blocked.\n   */\n  Isolated,\n}\n\n/**\n * Context passed into halfOpenAfter backoff delegate.\n */\nexport interface IHalfOpenAfterBackoffContext extends IDefaultPolicyContext {\n  /**\n   * The consecutive number of times the circuit has entered the\n   * {@link CircuitState.Open} state.\n   */\n  attempt: number;\n  /**\n   * The result of the last method call that caused the circuit to enter the\n   * {@link CircuitState.Open} state. Either a thrown error, or a value that we\n   * determined should open the circuit.\n   */\n  result: FailureReason<unknown>;\n}\n\nexport interface ICircuitBreakerOptions {\n  breaker: IBreaker;\n\n  /**\n   * When to (potentially) enter the {@link CircuitState.HalfOpen} state from\n   * the {@link CircuitState.Open} state. Either a duration in milliseconds or a\n   * backoff factory.\n   */\n  halfOpenAfter: number | IBackoffFactory<IHalfOpenAfterBackoffContext>;\n\n  /**\n   * Initial state from a previous call to {@link CircuitBreakerPolicy.toJSON}.\n   */\n  initialState?: unknown;\n}\n\ntype InnerState =\n  | { value: CircuitState.Closed }\n  | { value: CircuitState.Isolated; counters: number }\n  | {\n      value: CircuitState.Open;\n      openedAt: number;\n      attemptNo: number;\n      backoff: IBackoff<IHalfOpenAfterBackoffContext>;\n    }\n  | {\n      value: CircuitState.HalfOpen;\n      test: Promise<any>;\n      attemptNo: number;\n      backoff: IBackoff<IHalfOpenAfterBackoffContext>;\n    };\n\ninterface ISerializedState {\n  ownState: Partial<InnerState>;\n  breakerState: unknown;\n}\n\nexport class CircuitBreakerPolicy implements IPolicy {\n  declare readonly _altReturn: never;\n\n  private readonly breakEmitter = new EventEmitter<FailureReason<unknown> | { isolated: true }>();\n  private readonly resetEmitter = new EventEmitter<void>();\n  private readonly halfOpenEmitter = new EventEmitter<void>();\n  private readonly stateChangeEmitter = new EventEmitter<CircuitState>();\n  private readonly halfOpenAfterBackoffFactory: IBackoffFactory<IHalfOpenAfterBackoffContext>;\n  private innerLastFailure?: FailureReason<unknown>;\n  private innerState: InnerState = { value: CircuitState.Closed };\n\n  /**\n   * Event emitted when the circuit breaker opens.\n   */\n  public readonly onBreak = this.breakEmitter.addListener;\n\n  /**\n   * Event emitted when the circuit breaker resets.\n   */\n  public readonly onReset = this.resetEmitter.addListener;\n\n  /**\n   * Event emitted when the circuit breaker is half open (running a test call).\n   * Either `onBreak` on `onReset` will subsequently fire.\n   */\n  public readonly onHalfOpen = this.halfOpenEmitter.addListener;\n\n  /**\n   * Fired whenever the circuit breaker state changes.\n   */\n  public readonly onStateChange = this.stateChangeEmitter.addListener;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * Gets the current circuit breaker state.\n   */\n  public get state(): CircuitState {\n    return this.innerState.value;\n  }\n\n  /**\n   * Gets the last reason the circuit breaker failed.\n   */\n  public get lastFailure() {\n    return this.innerLastFailure;\n  }\n\n  constructor(\n    private readonly options: ICircuitBreakerOptions,\n    private readonly executor: ExecuteWrapper,\n  ) {\n    this.halfOpenAfterBackoffFactory =\n      typeof options.halfOpenAfter === 'number'\n        ? new ConstantBackoff(options.halfOpenAfter)\n        : options.halfOpenAfter;\n\n    if (options.initialState) {\n      const initialState = options.initialState as ISerializedState;\n      this.innerState = initialState.ownState as InnerState;\n      this.options.breaker.state = initialState.breakerState;\n\n      if (\n        this.innerState.value === CircuitState.Open ||\n        this.innerState.value === CircuitState.HalfOpen\n      ) {\n        this.innerLastFailure = { error: new HydratingCircuitError() };\n        let backoff = this.halfOpenAfterBackoffFactory.next({\n          attempt: 1,\n          result: this.innerLastFailure,\n          signal: neverAbortedSignal,\n        });\n        for (let i = 2; i <= this.innerState.attemptNo; i++) {\n          backoff = backoff.next({\n            attempt: i,\n            result: this.innerLastFailure,\n            signal: neverAbortedSignal,\n          });\n        }\n        this.innerState.backoff = backoff;\n      }\n    }\n  }\n\n  /**\n   * Manually holds open the circuit breaker.\n   * @returns A handle that keeps the breaker open until `.dispose()` is called.\n   */\n  public isolate() {\n    if (this.innerState.value !== CircuitState.Isolated) {\n      this.innerState = { value: CircuitState.Isolated, counters: 0 };\n      this.breakEmitter.emit({ isolated: true });\n      this.stateChangeEmitter.emit(CircuitState.Isolated);\n    }\n\n    this.innerState.counters++;\n\n    let disposed = false;\n    return {\n      dispose: () => {\n        if (disposed) {\n          return;\n        }\n\n        disposed = true;\n        if (this.innerState.value === CircuitState.Isolated && !--this.innerState.counters) {\n          this.innerState = { value: CircuitState.Closed };\n          this.resetEmitter.emit();\n          this.stateChangeEmitter.emit(CircuitState.Closed);\n        }\n      },\n    };\n  }\n\n  /**\n   * Executes the given function.\n   * @param fn Function to run\n   * @throws a {@link BrokenCircuitError} if the circuit is open\n   * @throws a {@link IsolatedCircuitError} if the circuit is held\n   * open via {@link CircuitBreakerPolicy.isolate}\n   * @returns a Promise that resolves or rejects with the function results.\n   */\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T> {\n    const state = this.innerState;\n    switch (state.value) {\n      case CircuitState.Closed:\n        const result = await this.executor.invoke(fn, { signal });\n        if ('success' in result) {\n          this.options.breaker.success(state.value);\n        } else {\n          this.innerLastFailure = result;\n          if (this.options.breaker.failure(state.value)) {\n            this.open(result, signal);\n          }\n        }\n\n        return returnOrThrow(result);\n\n      case CircuitState.HalfOpen:\n        await state.test.catch(() => undefined);\n        if (this.state === CircuitState.Closed && signal.aborted) {\n          throw new TaskCancelledError();\n        }\n\n        return this.execute(fn);\n\n      case CircuitState.Open:\n        if (Date.now() - state.openedAt < state.backoff.duration) {\n          throw new BrokenCircuitError();\n        }\n        const test = this.halfOpen(fn, signal);\n        this.innerState = {\n          value: CircuitState.HalfOpen,\n          test,\n          backoff: state.backoff,\n          attemptNo: state.attemptNo + 1,\n        };\n        this.stateChangeEmitter.emit(CircuitState.HalfOpen);\n        return test;\n\n      case CircuitState.Isolated:\n        throw new IsolatedCircuitError();\n\n      default:\n        throw new Error(`Unexpected circuit state ${state}`);\n    }\n  }\n\n  /**\n   * Captures circuit breaker state that can later be used to recreate the\n   * breaker by passing `state` to the `circuitBreaker` function. This is\n   * useful in cases like serverless functions where you may want to keep\n   * the breaker state across multiple executions.\n   */\n  public toJSON(): unknown {\n    const state = this.innerState;\n    let ownState: Partial<InnerState>;\n    if (state.value === CircuitState.HalfOpen) {\n      ownState = {\n        value: CircuitState.Open,\n        openedAt: 0,\n        attemptNo: state.attemptNo,\n      };\n    } else if (state.value === CircuitState.Open) {\n      ownState = {\n        value: CircuitState.Open,\n        openedAt: state.openedAt,\n        attemptNo: state.attemptNo,\n      };\n    } else {\n      ownState = state;\n    }\n\n    return { ownState, breakerState: this.options.breaker.state } satisfies ISerializedState;\n  }\n\n  private async halfOpen<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal: AbortSignal,\n  ): Promise<T> {\n    this.halfOpenEmitter.emit();\n\n    try {\n      const result = await this.executor.invoke(fn, { signal });\n      if ('success' in result) {\n        this.options.breaker.success(CircuitState.HalfOpen);\n        this.close();\n      } else {\n        this.innerLastFailure = result;\n        this.options.breaker.failure(CircuitState.HalfOpen);\n        this.open(result, signal);\n      }\n\n      return returnOrThrow(result);\n    } catch (err) {\n      // It's an error, but not one the circuit is meant to retry, so\n      // for our purposes it's a success. Task failed successfully!\n      this.close();\n      throw err;\n    }\n  }\n\n  private open(reason: FailureReason<unknown>, signal: AbortSignal) {\n    if (this.state === CircuitState.Isolated || this.state === CircuitState.Open) {\n      return;\n    }\n\n    const attemptNo =\n      this.innerState.value === CircuitState.HalfOpen ? this.innerState.attemptNo : 1;\n    const context = { attempt: attemptNo, result: reason, signal };\n    const backoff =\n      this.innerState.value === CircuitState.HalfOpen\n        ? this.innerState.backoff.next(context)\n        : this.halfOpenAfterBackoffFactory.next(context);\n\n    this.innerState = { value: CircuitState.Open, openedAt: Date.now(), backoff, attemptNo };\n    this.breakEmitter.emit(reason);\n    this.stateChangeEmitter.emit(CircuitState.Open);\n  }\n\n  private close() {\n    if (this.state === CircuitState.HalfOpen) {\n      this.innerState = { value: CircuitState.Closed };\n      this.resetEmitter.emit();\n      this.stateChangeEmitter.emit(CircuitState.Closed);\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.d.ts b/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.js b/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.js
new file mode 100644
index 0000000..f62aee7
--- /dev/null
+++ b/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.js
@@ -0,0 +1,307 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const sinon_1 = require("sinon");
+const util_1 = require("util");
+const IterableBackoff_1 = require("./backoff/IterableBackoff");
+const Breaker_1 = require("./breaker/Breaker");
+const LocalAbortController_1 = require("./common/LocalAbortController");
+const CircuitBreakerPolicy_1 = require("./CircuitBreakerPolicy");
+const abort_1 = require("./common/abort");
+const Errors_1 = require("./errors/Errors");
+const IsolatedCircuitError_1 = require("./errors/IsolatedCircuitError");
+const Policy_1 = require("./Policy");
+class MyException extends Error {
+}
+const delay = (0, util_1.promisify)(setTimeout);
+describe('CircuitBreakerPolicy', () => {
+    let p;
+    let clock;
+    let onBreak;
+    let onReset;
+    let onHalfOpen;
+    beforeEach(() => {
+        p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+            halfOpenAfter: 1000,
+            breaker: new Breaker_1.ConsecutiveBreaker(2),
+        });
+        clock = (0, sinon_1.useFakeTimers)();
+        onBreak = (0, sinon_1.stub)();
+        onReset = (0, sinon_1.stub)();
+        onHalfOpen = (0, sinon_1.stub)();
+        p.onBreak(onBreak);
+        p.onReset(onReset);
+        p.onHalfOpen(onHalfOpen);
+    });
+    afterEach(() => {
+        clock.restore();
+    });
+    const openBreaker = async () => {
+        const s = (0, sinon_1.stub)().throws(new MyException());
+        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
+        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
+    };
+    it('allows calls when open', async () => {
+        (0, chai_1.expect)(await p.execute(() => 42)).to.equal(42);
+    });
+    it('opens after failing calls', async () => {
+        const s = (0, sinon_1.stub)().throws(new MyException());
+        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+        (0, chai_1.expect)(onBreak).not.called;
+        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
+        (0, chai_1.expect)(onBreak).called;
+        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(Errors_1.BrokenCircuitError);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
+        (0, chai_1.expect)(p.lastFailure.error).to.be.an.instanceOf(MyException);
+        (0, chai_1.expect)(onBreak).calledOnce;
+        (0, chai_1.expect)(s).calledTwice;
+    });
+    it('closes if the half open test succeeds', async () => {
+        await openBreaker();
+        clock.tick(1000);
+        const result = p.execute((0, sinon_1.stub)().resolves(42));
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.HalfOpen);
+        (0, chai_1.expect)(onHalfOpen).calledOnce;
+        (0, chai_1.expect)(await result).to.equal(42);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+        (0, chai_1.expect)(onReset).calledOnce;
+    });
+    it('uses the given backof factory to decide whether to enter the half open state', async () => {
+        p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+            halfOpenAfter: new IterableBackoff_1.IterableBackoff([1000, 2000]),
+            breaker: new Breaker_1.ConsecutiveBreaker(2),
+        });
+        p.onReset(onReset);
+        p.onHalfOpen(onHalfOpen);
+        await openBreaker();
+        clock.tick(1000);
+        const failedAttempt = p.execute((0, sinon_1.stub)().throws(new MyException()));
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.HalfOpen);
+        (0, chai_1.expect)(onHalfOpen).calledOnce;
+        await (0, chai_1.expect)(failedAttempt).to.be.rejectedWith(MyException);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
+        clock.tick(1000);
+        await (0, chai_1.expect)(p.execute((0, sinon_1.stub)().throws(new MyException()))).to.be.rejectedWith(Errors_1.BrokenCircuitError);
+        clock.tick(1000);
+        const result = p.execute((0, sinon_1.stub)().resolves(42));
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.HalfOpen);
+        (0, chai_1.expect)(onHalfOpen).calledTwice;
+        (0, chai_1.expect)(await result).to.equal(42);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+        (0, chai_1.expect)(onReset).calledOnce;
+    });
+    it('resets the backoff when closing the circuit', async () => {
+        let args = [];
+        p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+            halfOpenAfter: new (class MyBreaker {
+                constructor(duration) {
+                    this.duration = duration;
+                }
+                next(context) {
+                    args.push({ duration: this.duration + 1, attempt: context.attempt });
+                    (0, chai_1.expect)('error' in context.result).to.be.true;
+                    return new MyBreaker(this.duration + 1);
+                }
+            })(0),
+            breaker: new Breaker_1.ConsecutiveBreaker(2),
+        });
+        p.onReset(onReset);
+        p.onHalfOpen(onHalfOpen);
+        await openBreaker();
+        (0, chai_1.expect)(args).to.deep.equal([{ duration: 1, attempt: 1 }]);
+        clock.tick(args.pop().duration);
+        await (0, chai_1.expect)(p.execute((0, sinon_1.stub)().throws(new MyException()))).to.be.rejectedWith(MyException);
+        (0, chai_1.expect)(args).to.deep.equal([{ duration: 2, attempt: 2 }]);
+        clock.tick(args.pop().duration);
+        await p.execute((0, sinon_1.stub)().resolves(42));
+        (0, chai_1.expect)(args).to.be.empty;
+        await openBreaker();
+        (0, chai_1.expect)(args).to.deep.equal([{ duration: 1, attempt: 1 }]);
+        clock.tick(args.pop().duration);
+        await p.execute((0, sinon_1.stub)().resolves(42));
+        (0, chai_1.expect)(args).to.be.empty;
+    });
+    it('dedupes half-open tests', async () => {
+        await openBreaker();
+        clock.tick(1000);
+        // Two functinos, a and b. We execute with "a" first, and then make sure
+        // it returns before "b" gets called.
+        let aReturned = false;
+        const a = async () => {
+            await delay(10);
+            aReturned = true;
+            return 1;
+        };
+        const b = async () => {
+            (0, chai_1.expect)(aReturned).to.be.true;
+            return 2;
+        };
+        const todo = [
+            (0, chai_1.expect)(p.execute(a)).to.eventually.equal(1),
+            (0, chai_1.expect)(p.execute(b)).to.eventually.equal(2),
+        ];
+        clock.tick(10);
+        await Promise.all(todo);
+    });
+    it('stops deduped half-open tests if the circuit reopens', async () => {
+        await openBreaker();
+        clock.tick(1000);
+        // Two functinos, a and b. We execute with "a" first, and then make sure
+        // it returns before "b" gets called.
+        const a = async () => {
+            await delay(10);
+            throw new MyException();
+        };
+        const b = async () => {
+            throw new Error('expected to not be called');
+        };
+        const todo = [
+            (0, chai_1.expect)(p.execute(a)).to.be.rejectedWith(MyException),
+            (0, chai_1.expect)(p.execute(b)).to.be.rejectedWith(Errors_1.BrokenCircuitError),
+        ];
+        clock.tick(10);
+        await Promise.all(todo);
+    });
+    it('re-opens if the half open fails', async () => {
+        await openBreaker();
+        clock.tick(1000);
+        const s = (0, sinon_1.stub)().throws(new MyException());
+        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
+    });
+    it('handles isolation correctly', async () => {
+        const handle1 = p.isolate();
+        (0, chai_1.expect)(onBreak).calledOnceWith({ isolated: true });
+        const handle2 = p.isolate();
+        (0, chai_1.expect)(onBreak).calledOnce;
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Isolated);
+        await (0, chai_1.expect)(p.execute(() => 42)).to.be.rejectedWith(IsolatedCircuitError_1.IsolatedCircuitError);
+        handle1.dispose();
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Isolated);
+        (0, chai_1.expect)(onReset).not.called;
+        handle2.dispose();
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+        (0, chai_1.expect)(onReset).calledOnce;
+        (0, chai_1.expect)(await p.execute(() => 42)).to.equal(42);
+    });
+    it('links parent cancellation token', async () => {
+        const parent = (0, LocalAbortController_1.createAbortController)();
+        await (0, Policy_1.circuitBreaker)(Policy_1.handleAll, {
+            halfOpenAfter: 1000,
+            breaker: new Breaker_1.ConsecutiveBreaker(3),
+        }).execute(({ signal }) => {
+            (0, chai_1.expect)(signal.aborted).to.be.false;
+            parent.abort();
+            (0, chai_1.expect)(signal.aborted).to.be.true;
+        }, parent.signal);
+    });
+    it('aborts function execution if half open test succeeds', async () => {
+        await openBreaker();
+        clock.tick(1000);
+        // half open test:
+        p.execute((0, sinon_1.stub)().resolves(42));
+        // queued timeout:
+        await (0, chai_1.expect)(p.execute((0, sinon_1.stub)(), abort_1.abortedSignal)).to.be.rejectedWith(Errors_1.TaskCancelledError);
+        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+        (0, chai_1.expect)(onReset).calledOnce;
+    });
+    describe('state restoration', () => {
+        let args = [];
+        class MyBreaker {
+            constructor(duration) {
+                this.duration = duration;
+            }
+            next(context) {
+                args.push({ duration: this.duration + 1, attempt: context.attempt });
+                (0, chai_1.expect)('error' in context.result).to.be.true;
+                return new MyBreaker(this.duration + 1);
+            }
+        }
+        beforeEach(() => {
+            args = [];
+        });
+        it('restores closed state', async () => {
+            p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+            });
+            const p2 = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+                initialState: p.toJSON(),
+            });
+            (0, chai_1.expect)(p2.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+            await p2.execute((0, sinon_1.stub)().resolves(42));
+        });
+        it('restores breaker state', async () => {
+            p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+            });
+            const s = (0, sinon_1.stub)().throws(new MyException());
+            await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
+            const p2 = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+                initialState: p.toJSON(),
+            });
+            (0, chai_1.expect)(p2.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+            await (0, chai_1.expect)(p2.execute(s)).to.be.rejectedWith(MyException);
+            (0, chai_1.expect)(p2.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
+        });
+        it('restores open state', async () => {
+            p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+            });
+            await openBreaker();
+            clock.tick(args.pop().duration);
+            await (0, chai_1.expect)(p.execute((0, sinon_1.stub)().throws(new MyException()))).to.be.rejectedWith(MyException);
+            args.length = 0;
+            const p2 = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+                initialState: p.toJSON(),
+            });
+            (0, chai_1.expect)(p2.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
+            (0, chai_1.expect)(args).to.deep.equal([
+                { duration: 1, attempt: 1 },
+                { duration: 2, attempt: 2 },
+            ]);
+            await (0, chai_1.expect)(p.execute((0, sinon_1.stub)().resolves(42))).to.be.rejectedWith(Errors_1.BrokenCircuitError);
+            clock.tick(args.pop().duration);
+            await p2.execute((0, sinon_1.stub)().resolves(42));
+            (0, chai_1.expect)(p2.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
+        });
+        it('restores half-open state with immediate retry', async () => {
+            // set time ahead because openedAt gets serialized to 0
+            clock.tick(1000);
+            p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+            });
+            await openBreaker();
+            clock.tick(args.pop().duration);
+            args.length = 0;
+            p.execute(async () => {
+                await delay(1);
+                throw new MyException();
+            }).catch(() => { });
+            (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.HalfOpen);
+            const p2 = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
+                halfOpenAfter: new MyBreaker(0),
+                breaker: new Breaker_1.ConsecutiveBreaker(2),
+                initialState: p.toJSON(),
+            });
+            (0, chai_1.expect)(p2.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
+            (0, chai_1.expect)(args).to.deep.equal([
+                { duration: 1, attempt: 1 },
+                { duration: 2, attempt: 2 },
+            ]);
+            await p2.execute((0, sinon_1.stub)().resolves(42));
+        });
+    });
+});
+//# sourceMappingURL=CircuitBreakerPolicy.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.js.map b/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.js.map
new file mode 100644
index 0000000..555970e
--- /dev/null
+++ b/node_modules/cockatiel/dist/CircuitBreakerPolicy.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"CircuitBreakerPolicy.test.js","sourceRoot":"","sources":["../src/CircuitBreakerPolicy.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from 'chai';\nimport { SinonFakeTimers, SinonStub, stub, useFakeTimers } from 'sinon';\nimport { promisify } from 'util';\nimport { IBackoffFactory } from './backoff/Backoff';\nimport { IterableBackoff } from './backoff/IterableBackoff';\nimport { ConsecutiveBreaker } from './breaker/Breaker';\nimport { createAbortController } from './common/LocalAbortController';\nimport {\n  CircuitBreakerPolicy,\n  CircuitState,\n  IHalfOpenAfterBackoffContext,\n} from './CircuitBreakerPolicy';\nimport { abortedSignal } from './common/abort';\nimport { BrokenCircuitError, TaskCancelledError } from './errors/Errors';\nimport { IsolatedCircuitError } from './errors/IsolatedCircuitError';\nimport { circuitBreaker, handleAll, handleType } from './Policy';\n\nclass MyException extends Error {}\n\nconst delay = promisify(setTimeout);\n\ndescribe('CircuitBreakerPolicy', () => {\n  let p: CircuitBreakerPolicy;\n  let clock: SinonFakeTimers;\n  let onBreak: SinonStub;\n  let onReset: SinonStub;\n  let onHalfOpen: SinonStub;\n\n  beforeEach(() => {\n    p = circuitBreaker(handleType(MyException), {\n      halfOpenAfter: 1000,\n      breaker: new ConsecutiveBreaker(2),\n    });\n    clock = useFakeTimers();\n    onBreak = stub();\n    onReset = stub();\n    onHalfOpen = stub();\n    p.onBreak(onBreak);\n    p.onReset(onReset);\n    p.onHalfOpen(onHalfOpen);\n  });\n\n  afterEach(() => {\n    clock.restore();\n  });\n\n  const openBreaker = async () => {\n    const s = stub().throws(new MyException());\n    await expect(p.execute(s)).to.be.rejectedWith(MyException);\n    await expect(p.execute(s)).to.be.rejectedWith(MyException);\n  };\n\n  it('allows calls when open', async () => {\n    expect(await p.execute(() => 42)).to.equal(42);\n  });\n\n  it('opens after failing calls', async () => {\n    const s = stub().throws(new MyException());\n\n    await expect(p.execute(s)).to.be.rejectedWith(MyException);\n    expect(p.state).to.equal(CircuitState.Closed);\n    expect(onBreak).not.called;\n\n    await expect(p.execute(s)).to.be.rejectedWith(MyException);\n    expect(p.state).to.equal(CircuitState.Open);\n    expect(onBreak).called;\n\n    await expect(p.execute(s)).to.be.rejectedWith(BrokenCircuitError);\n    expect(p.state).to.equal(CircuitState.Open);\n\n    expect((p.lastFailure as any).error).to.be.an.instanceOf(MyException);\n    expect(onBreak).calledOnce;\n    expect(s).calledTwice;\n  });\n\n  it('closes if the half open test succeeds', async () => {\n    await openBreaker();\n\n    clock.tick(1000);\n\n    const result = p.execute(stub().resolves(42));\n    expect(p.state).to.equal(CircuitState.HalfOpen);\n    expect(onHalfOpen).calledOnce;\n    expect(await result).to.equal(42);\n    expect(p.state).to.equal(CircuitState.Closed);\n    expect(onReset).calledOnce;\n  });\n\n  it('uses the given backof factory to decide whether to enter the half open state', async () => {\n    p = circuitBreaker(handleType(MyException), {\n      halfOpenAfter: new IterableBackoff([1000, 2000]),\n      breaker: new ConsecutiveBreaker(2),\n    });\n    p.onReset(onReset);\n    p.onHalfOpen(onHalfOpen);\n\n    await openBreaker();\n\n    clock.tick(1000);\n\n    const failedAttempt = p.execute(stub().throws(new MyException()));\n    expect(p.state).to.equal(CircuitState.HalfOpen);\n    expect(onHalfOpen).calledOnce;\n    await expect(failedAttempt).to.be.rejectedWith(MyException);\n    expect(p.state).to.equal(CircuitState.Open);\n\n    clock.tick(1000);\n\n    await expect(p.execute(stub().throws(new MyException()))).to.be.rejectedWith(\n      BrokenCircuitError,\n    );\n\n    clock.tick(1000);\n\n    const result = p.execute(stub().resolves(42));\n    expect(p.state).to.equal(CircuitState.HalfOpen);\n    expect(onHalfOpen).calledTwice;\n    expect(await result).to.equal(42);\n    expect(p.state).to.equal(CircuitState.Closed);\n    expect(onReset).calledOnce;\n  });\n\n  it('resets the backoff when closing the circuit', async () => {\n    let args: { duration: number; attempt: number }[] = [];\n    p = circuitBreaker(handleType(MyException), {\n      halfOpenAfter: new (class MyBreaker implements IBackoffFactory<IHalfOpenAfterBackoffContext> {\n        constructor(public readonly duration: number) {}\n\n        next(context: IHalfOpenAfterBackoffContext) {\n          args.push({ duration: this.duration + 1, attempt: context.attempt });\n          expect('error' in context.result).to.be.true;\n          return new MyBreaker(this.duration + 1);\n        }\n      })(0),\n      breaker: new ConsecutiveBreaker(2),\n    });\n    p.onReset(onReset);\n    p.onHalfOpen(onHalfOpen);\n\n    await openBreaker();\n\n    expect(args).to.deep.equal([{ duration: 1, attempt: 1 }]);\n    clock.tick(args.pop()!.duration);\n\n    await expect(p.execute(stub().throws(new MyException()))).to.be.rejectedWith(MyException);\n    expect(args).to.deep.equal([{ duration: 2, attempt: 2 }]);\n    clock.tick(args.pop()!.duration);\n\n    await p.execute(stub().resolves(42));\n    expect(args).to.be.empty;\n\n    await openBreaker();\n\n    expect(args).to.deep.equal([{ duration: 1, attempt: 1 }]);\n    clock.tick(args.pop()!.duration);\n\n    await p.execute(stub().resolves(42));\n    expect(args).to.be.empty;\n  });\n\n  it('dedupes half-open tests', async () => {\n    await openBreaker();\n    clock.tick(1000);\n\n    // Two functinos, a and b. We execute with \"a\" first, and then make sure\n    // it returns before \"b\" gets called.\n    let aReturned = false;\n    const a = async () => {\n      await delay(10);\n      aReturned = true;\n      return 1;\n    };\n\n    const b = async () => {\n      expect(aReturned).to.be.true;\n      return 2;\n    };\n\n    const todo = [\n      expect(p.execute(a)).to.eventually.equal(1),\n      expect(p.execute(b)).to.eventually.equal(2),\n    ];\n\n    clock.tick(10);\n\n    await Promise.all(todo);\n  });\n\n  it('stops deduped half-open tests if the circuit reopens', async () => {\n    await openBreaker();\n    clock.tick(1000);\n\n    // Two functinos, a and b. We execute with \"a\" first, and then make sure\n    // it returns before \"b\" gets called.\n    const a = async () => {\n      await delay(10);\n      throw new MyException();\n    };\n\n    const b = async () => {\n      throw new Error('expected to not be called');\n    };\n\n    const todo = [\n      expect(p.execute(a)).to.be.rejectedWith(MyException),\n      expect(p.execute(b)).to.be.rejectedWith(BrokenCircuitError),\n    ];\n\n    clock.tick(10);\n\n    await Promise.all(todo);\n  });\n\n  it('re-opens if the half open fails', async () => {\n    await openBreaker();\n\n    clock.tick(1000);\n\n    const s = stub().throws(new MyException());\n    await expect(p.execute(s)).to.be.rejectedWith(MyException);\n    expect(p.state).to.equal(CircuitState.Open);\n  });\n\n  it('handles isolation correctly', async () => {\n    const handle1 = p.isolate();\n    expect(onBreak).calledOnceWith({ isolated: true });\n\n    const handle2 = p.isolate();\n    expect(onBreak).calledOnce;\n\n    expect(p.state).to.equal(CircuitState.Isolated);\n    await expect(p.execute(() => 42)).to.be.rejectedWith(IsolatedCircuitError);\n\n    handle1.dispose();\n    expect(p.state).to.equal(CircuitState.Isolated);\n    expect(onReset).not.called;\n\n    handle2.dispose();\n    expect(p.state).to.equal(CircuitState.Closed);\n    expect(onReset).calledOnce;\n\n    expect(await p.execute(() => 42)).to.equal(42);\n  });\n\n  it('links parent cancellation token', async () => {\n    const parent = createAbortController();\n    await circuitBreaker(handleAll, {\n      halfOpenAfter: 1000,\n      breaker: new ConsecutiveBreaker(3),\n    }).execute(({ signal }) => {\n      expect(signal.aborted).to.be.false;\n      parent.abort();\n      expect(signal.aborted).to.be.true;\n    }, parent.signal);\n  });\n\n  it('aborts function execution if half open test succeeds', async () => {\n    await openBreaker();\n\n    clock.tick(1000);\n\n    // half open test:\n    p.execute(stub().resolves(42));\n\n    // queued timeout:\n    await expect(p.execute(stub(), abortedSignal)).to.be.rejectedWith(TaskCancelledError);\n\n    expect(p.state).to.equal(CircuitState.Closed);\n    expect(onReset).calledOnce;\n  });\n\n  describe('state restoration', () => {\n    let args: { duration: number; attempt: number }[] = [];\n    class MyBreaker implements IBackoffFactory<IHalfOpenAfterBackoffContext> {\n      constructor(public readonly duration: number) {}\n\n      next(context: IHalfOpenAfterBackoffContext) {\n        args.push({ duration: this.duration + 1, attempt: context.attempt });\n        expect('error' in context.result).to.be.true;\n        return new MyBreaker(this.duration + 1);\n      }\n    }\n\n    beforeEach(() => {\n      args = [];\n    });\n\n    it('restores closed state', async () => {\n      p = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n      });\n\n      const p2 = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n        initialState: p.toJSON(),\n      });\n\n      expect(p2.state).to.equal(CircuitState.Closed);\n      await p2.execute(stub().resolves(42));\n    });\n\n    it('restores breaker state', async () => {\n      p = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n      });\n\n      const s = stub().throws(new MyException());\n      await expect(p.execute(s)).to.be.rejectedWith(MyException);\n\n      const p2 = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n        initialState: p.toJSON(),\n      });\n\n      expect(p2.state).to.equal(CircuitState.Closed);\n      await expect(p2.execute(s)).to.be.rejectedWith(MyException);\n      expect(p2.state).to.equal(CircuitState.Open);\n    });\n\n    it('restores open state', async () => {\n      p = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n      });\n\n      await openBreaker();\n      clock.tick(args.pop()!.duration);\n      await expect(p.execute(stub().throws(new MyException()))).to.be.rejectedWith(MyException);\n      args.length = 0;\n\n      const p2 = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n        initialState: p.toJSON(),\n      });\n\n      expect(p2.state).to.equal(CircuitState.Open);\n      expect(args).to.deep.equal([\n        { duration: 1, attempt: 1 },\n        { duration: 2, attempt: 2 },\n      ]);\n      await expect(p.execute(stub().resolves(42))).to.be.rejectedWith(BrokenCircuitError);\n\n      clock.tick(args.pop()!.duration);\n      await p2.execute(stub().resolves(42));\n      expect(p2.state).to.equal(CircuitState.Closed);\n    });\n\n    it('restores half-open state with immediate retry', async () => {\n      // set time ahead because openedAt gets serialized to 0\n      clock.tick(1000);\n\n      p = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n      });\n\n      await openBreaker();\n      clock.tick(args.pop()!.duration);\n      args.length = 0;\n\n      p.execute(async () => {\n        await delay(1);\n        throw new MyException();\n      }).catch(() => {});\n      expect(p.state).to.equal(CircuitState.HalfOpen);\n\n      const p2 = circuitBreaker(handleType(MyException), {\n        halfOpenAfter: new MyBreaker(0),\n        breaker: new ConsecutiveBreaker(2),\n        initialState: p.toJSON(),\n      });\n\n      expect(p2.state).to.equal(CircuitState.Open);\n      expect(args).to.deep.equal([\n        { duration: 1, attempt: 1 },\n        { duration: 2, attempt: 2 },\n      ]);\n\n      await p2.execute(stub().resolves(42));\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/FallbackPolicy.d.ts b/node_modules/cockatiel/dist/FallbackPolicy.d.ts
index c4e35c5..150b506 100644
--- a/node_modules/cockatiel/dist/FallbackPolicy.d.ts
+++ b/node_modules/cockatiel/dist/FallbackPolicy.d.ts
@@ -18,5 +18,5 @@ export declare class FallbackPolicy<AltReturn> implements IPolicy<IDefaultPolicy
      * @param fn Function to execute.
      * @returns The function result or fallback value.
      */
-    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T | AltReturn>;
+    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: import("./common/LocalAbortController").LocalAbortSignal): Promise<T | AltReturn>;
 }
diff --git a/node_modules/cockatiel/dist/FallbackPolicy.test.d.ts b/node_modules/cockatiel/dist/FallbackPolicy.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/FallbackPolicy.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/FallbackPolicy.test.js b/node_modules/cockatiel/dist/FallbackPolicy.test.js
new file mode 100644
index 0000000..0bdb327
--- /dev/null
+++ b/node_modules/cockatiel/dist/FallbackPolicy.test.js
@@ -0,0 +1,36 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const sinon_1 = require("sinon");
+const LocalAbortController_1 = require("./common/LocalAbortController");
+const Policy_1 = require("./Policy");
+describe('FallbackPolicy', () => {
+    it('does not fall back when not necessary', async () => {
+        const result = await (0, Policy_1.fallback)(Policy_1.handleAll, 'error').execute(() => 'ok');
+        (0, chai_1.expect)(result).to.equal('ok');
+    });
+    it('returns a fallback and emits an error if necessary', async () => {
+        const policy = (0, Policy_1.fallback)(Policy_1.handleAll, 'error');
+        const onFallback = (0, sinon_1.stub)();
+        policy.onFailure(onFallback);
+        const error = new Error('oh no!');
+        const result = await policy.execute(() => {
+            throw error;
+        });
+        (0, chai_1.expect)(result).to.equal('error');
+        (0, chai_1.expect)(onFallback).calledWith({
+            reason: { error },
+            handled: true,
+            duration: onFallback.args[0]?.[0].duration,
+        });
+    });
+    it('links parent cancellation token', async () => {
+        const parent = (0, LocalAbortController_1.createAbortController)();
+        await (0, Policy_1.fallback)(Policy_1.handleAll, 'error').execute(({ signal }) => {
+            (0, chai_1.expect)(signal.aborted).to.be.false;
+            parent.abort();
+            (0, chai_1.expect)(signal.aborted).to.be.true;
+        }, parent.signal);
+    });
+});
+//# sourceMappingURL=FallbackPolicy.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/FallbackPolicy.test.js.map b/node_modules/cockatiel/dist/FallbackPolicy.test.js.map
new file mode 100644
index 0000000..6a4715e
--- /dev/null
+++ b/node_modules/cockatiel/dist/FallbackPolicy.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"FallbackPolicy.test.js","sourceRoot":"","sources":["../src/FallbackPolicy.test.ts"],"names":[],"mappings":";;AAAA,+BAA8B;AAC9B,iCAA6B;AAC7B,wEAAsE;AACtE,qCAA+C;AAE/C,QAAQ,CAAC,gBAAgB,EAAE,GAAG,EAAE;IAC9B,EAAE,CAAC,uCAAuC,EAAE,KAAK,IAAI,EAAE;QACrD,MAAM,MAAM,GAAG,MAAM,IAAA,iBAAQ,EAAC,kBAAS,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;QACtE,IAAA,aAAM,EAAC,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,oDAAoD,EAAE,KAAK,IAAI,EAAE;QAClE,MAAM,MAAM,GAAG,IAAA,iBAAQ,EAAC,kBAAS,EAAE,OAAO,CAAC,CAAC;QAC5C,MAAM,UAAU,GAAG,IAAA,YAAI,GAAE,CAAC;QAC1B,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;QAE7B,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;QAClC,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;YACvC,MAAM,KAAK,CAAC;QACd,CAAC,CAAC,CAAC;QACH,IAAA,aAAM,EAAC,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACjC,IAAA,aAAM,EAAC,UAAU,CAAC,CAAC,UAAU,CAAC;YAC5B,MAAM,EAAE,EAAE,KAAK,EAAE;YACjB,OAAO,EAAE,IAAI;YACb,QAAQ,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ;SAC3C,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,iCAAiC,EAAE,KAAK,IAAI,EAAE;QAC/C,MAAM,MAAM,GAAG,IAAA,4CAAqB,GAAE,CAAC;QACvC,MAAM,IAAA,iBAAQ,EAAC,kBAAS,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE;YACxD,IAAA,aAAM,EAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;YACnC,MAAM,CAAC,KAAK,EAAE,CAAC;YACf,IAAA,aAAM,EAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;QACpC,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;IACpB,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expect } from 'chai';\nimport { stub } from 'sinon';\nimport { createAbortController } from './common/LocalAbortController';\nimport { fallback, handleAll } from './Policy';\n\ndescribe('FallbackPolicy', () => {\n  it('does not fall back when not necessary', async () => {\n    const result = await fallback(handleAll, 'error').execute(() => 'ok');\n    expect(result).to.equal('ok');\n  });\n\n  it('returns a fallback and emits an error if necessary', async () => {\n    const policy = fallback(handleAll, 'error');\n    const onFallback = stub();\n    policy.onFailure(onFallback);\n\n    const error = new Error('oh no!');\n    const result = await policy.execute(() => {\n      throw error;\n    });\n    expect(result).to.equal('error');\n    expect(onFallback).calledWith({\n      reason: { error },\n      handled: true,\n      duration: onFallback.args[0]?.[0].duration,\n    });\n  });\n\n  it('links parent cancellation token', async () => {\n    const parent = createAbortController();\n    await fallback(handleAll, 'error').execute(({ signal }) => {\n      expect(signal.aborted).to.be.false;\n      parent.abort();\n      expect(signal.aborted).to.be.true;\n    }, parent.signal);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/NoopPolicy.d.ts b/node_modules/cockatiel/dist/NoopPolicy.d.ts
index 0beec48..b2d992c 100644
--- a/node_modules/cockatiel/dist/NoopPolicy.d.ts
+++ b/node_modules/cockatiel/dist/NoopPolicy.d.ts
@@ -1,4 +1,5 @@
 import { IDefaultPolicyContext, IPolicy } from './Policy';
+import { AbortSignal } from './common/LocalAbortController';
 /**
  * A no-op policy, useful for unit tests and stubs.
  */
diff --git a/node_modules/cockatiel/dist/NoopPolicy.js.map b/node_modules/cockatiel/dist/NoopPolicy.js.map
index 7055d13..0b1ef4c 100644
--- a/node_modules/cockatiel/dist/NoopPolicy.js.map
+++ b/node_modules/cockatiel/dist/NoopPolicy.js.map
@@ -1 +1 @@
-{"version":3,"file":"NoopPolicy.js","sourceRoot":"","sources":["../src/NoopPolicy.ts"],"names":[],"mappings":";;;AAAA,0CAAoD;AACpD,gDAAkE;AAGlE;;GAEG;AACH,MAAa,UAAU;IAAvB;QAEmB,aAAQ,GAAG,IAAI,yBAAc,EAAE,CAAC;QACjC,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QACpC,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IAQtD,CAAC;IANQ,KAAK,CAAC,OAAO,CAClB,EAA0D,EAC1D,SAAsB,0BAAkB;QAExC,OAAO,IAAA,wBAAa,EAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;IACnE,CAAC;CACF;AAZD,gCAYC","sourcesContent":["import { neverAbortedSignal } from './common/abort';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { IDefaultPolicyContext, IPolicy } from './Policy';\n\n/**\n * A no-op policy, useful for unit tests and stubs.\n */\nexport class NoopPolicy implements IPolicy {\n  declare readonly _altReturn: never;\n  private readonly executor = new ExecuteWrapper();\n  public readonly onSuccess = this.executor.onSuccess;\n  public readonly onFailure = this.executor.onFailure;\n\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal: AbortSignal = neverAbortedSignal,\n  ): Promise<T> {\n    return returnOrThrow(await this.executor.invoke(fn, { signal }));\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NoopPolicy.js","sourceRoot":"","sources":["../src/NoopPolicy.ts"],"names":[],"mappings":";;;AAAA,0CAAoD;AACpD,gDAAkE;AAIlE;;GAEG;AACH,MAAa,UAAU;IAAvB;QAEmB,aAAQ,GAAG,IAAI,yBAAc,EAAE,CAAC;QACjC,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QACpC,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IAQtD,CAAC;IANQ,KAAK,CAAC,OAAO,CAClB,EAA0D,EAC1D,SAAsB,0BAAkB;QAExC,OAAO,IAAA,wBAAa,EAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;IACnE,CAAC;CACF;AAZD,gCAYC","sourcesContent":["import { neverAbortedSignal } from './common/abort';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { IDefaultPolicyContext, IPolicy } from './Policy';\nimport { AbortSignal } from './common/LocalAbortController';\n\n/**\n * A no-op policy, useful for unit tests and stubs.\n */\nexport class NoopPolicy implements IPolicy {\n  declare readonly _altReturn: never;\n  private readonly executor = new ExecuteWrapper();\n  public readonly onSuccess = this.executor.onSuccess;\n  public readonly onFailure = this.executor.onFailure;\n\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal: AbortSignal = neverAbortedSignal,\n  ): Promise<T> {\n    return returnOrThrow(await this.executor.invoke(fn, { signal }));\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/Policy.d.ts b/node_modules/cockatiel/dist/Policy.d.ts
index d0b1c12..3c73a4b 100644
--- a/node_modules/cockatiel/dist/Policy.d.ts
+++ b/node_modules/cockatiel/dist/Policy.d.ts
@@ -6,6 +6,7 @@ import { FallbackPolicy } from './FallbackPolicy';
 import { NoopPolicy } from './NoopPolicy';
 import { IRetryBackoffContext, RetryPolicy } from './RetryPolicy';
 import { TimeoutPolicy, TimeoutStrategy } from './TimeoutPolicy';
+import { AbortSignal } from './common/LocalAbortController';
 type Constructor<T> = new (...args: any) => T;
 export interface IBasePolicyOptions {
     errorFilter: (error: Error) => boolean;
diff --git a/node_modules/cockatiel/dist/Policy.js b/node_modules/cockatiel/dist/Policy.js
index 5dafc98..9df0978 100644
--- a/node_modules/cockatiel/dist/Policy.js
+++ b/node_modules/cockatiel/dist/Policy.js
@@ -192,7 +192,11 @@ function usePolicy(policy) {
             throw new Error(`Can only decorate functions with @cockatiel, got ${typeof inner}`);
         }
         descriptor.value = function (...args) {
-            const signal = args[args.length - 1] instanceof AbortSignal ? args.pop() : undefined;
+            const signal = args[args.length - 1] &&
+                typeof args[args.length - 1] === 'object' &&
+                'aborted' in args[args.length - 1] &&
+                'addEventListener' in args[args.length - 1]
+                ? args.pop() : undefined;
             return policy.execute(context => inner.apply(this, [...args, context]), signal);
         };
     };
diff --git a/node_modules/cockatiel/dist/Policy.js.map b/node_modules/cockatiel/dist/Policy.js.map
index b257402..aec7ca0 100644
--- a/node_modules/cockatiel/dist/Policy.js.map
+++ b/node_modules/cockatiel/dist/Policy.js.map
@@ -1 +1 @@
-{"version":3,"file":"Policy.js","sourceRoot":"","sources":["../src/Policy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConstantBackoff, IBackoffFactory } from './backoff/Backoff';\nimport { BulkheadPolicy } from './BulkheadPolicy';\nimport { CircuitBreakerPolicy, ICircuitBreakerOptions } from './CircuitBreakerPolicy';\nimport { Event } from './common/Event';\nimport { ExecuteWrapper } from './common/Executor';\nimport { FallbackPolicy } from './FallbackPolicy';\nimport { NoopPolicy } from './NoopPolicy';\nimport { IRetryBackoffContext, RetryPolicy } from './RetryPolicy';\nimport { TimeoutPolicy, TimeoutStrategy } from './TimeoutPolicy';\n\ntype Constructor<T> = new (...args: any) => T;\n\nconst typeFilter = <T>(cls: Constructor<T>, predicate?: (error: T) => boolean) =>\n  predicate ? (v: unknown) => v instanceof cls && predicate(v) : (v: unknown) => v instanceof cls;\n\nconst always = () => true;\nconst never = () => false;\n\nexport interface IBasePolicyOptions {\n  errorFilter: (error: Error) => boolean;\n  resultFilter: (result: unknown) => boolean;\n}\n\n/**\n * The reason for a call failure. Either an error, or the a value that was\n * marked as a failure (when using result filtering).\n */\nexport type FailureReason<ReturnType> = { error: Error } | { value: ReturnType };\n\n/**\n * Event emitted on the `onFailure` calls.\n */\nexport interface IFailureEvent {\n  /**\n   * Call duration, in milliseconds (with nanosecond precision, as the OS allows).\n   */\n  duration: number;\n\n  /**\n   * Whether the error was handled by the policy.\n   */\n  handled: boolean;\n\n  /**\n   * The reason for the error.\n   */\n  reason: FailureReason<unknown>;\n}\n\n/**\n * Event emitted on the `onSuccess` calls.\n */\nexport interface ISuccessEvent {\n  /**\n   * Call duration, in milliseconds (with nanosecond precision, as the OS allows).\n   */\n  duration: number;\n}\n\nexport interface IDefaultPolicyContext {\n  /**\n   * Abort signal for the operation. This is propagated through multiple\n   * retry policies.\n   */\n  signal: AbortSignal;\n}\n\n/**\n * IPolicy is the type of all policies that Cockatiel provides. It describes\n * an execute() function which takes a generic argument.\n */\nexport interface IPolicy<\n  ContextType extends IDefaultPolicyContext = IDefaultPolicyContext,\n  AltReturn = never,\n> {\n  /**\n   * Virtual property only used for TypeScript--will not actually be defined.\n   * @deprecated This property does not exist\n   */\n  readonly _altReturn: AltReturn;\n\n  /**\n   * Fires on the policy when a request successfully completes and some\n   * successful value will be returned. In a retry policy, this is fired once\n   * even if the request took multiple retries to succeed.\n   */\n  readonly onSuccess: Event<ISuccessEvent>;\n\n  /**\n   * Fires on the policy when a request fails *due to a handled reason* fails\n   * and will give rejection to the called.\n   */\n  readonly onFailure: Event<IFailureEvent>;\n\n  /**\n   * Runs the function through behavior specified by the policy.\n   */\n  execute<T>(\n    fn: (context: ContextType) => PromiseLike<T> | T,\n    signal?: AbortSignal,\n  ): Promise<T | AltReturn>;\n}\n\nexport interface IMergedPolicy<A extends IDefaultPolicyContext, B, W extends IPolicy<any, any>[]>\n  extends IPolicy<A, B> {\n  readonly wrapped: W;\n}\n\ntype MergePolicies<A, B> =\n  A extends IPolicy<infer A1, any>\n    ? B extends IPolicy<infer B1, any>\n      ? IMergedPolicy<\n          A1 & B1,\n          A['_altReturn'] | B['_altReturn'],\n          B extends IMergedPolicy<any, any, infer W> ? [A, ...W] : [A, B]\n        >\n      : never\n    : never;\n\nexport class Policy {\n  /**\n   * Factory that builds a base set of filters that can be used in circuit\n   * breakers, retries, etc.\n   */\n  constructor(public readonly options: Readonly<IBasePolicyOptions>) {}\n\n  /**\n   * Allows the policy to additionally handles errors of the given type.\n   *\n   * @param cls Class constructor to check that the error is an instance of.\n   * @param predicate If provided, a function to be called with the error\n   * which should return \"true\" if we want to handle this error.\n   * @example\n   * ```js\n   * // retry both network errors and response errors with a 503 status code\n   * new Policy()\n   *  .orType(NetworkError)\n   *  .orType(ResponseError, err => err.statusCode === 503)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n    const filter = typeFilter(cls, predicate);\n    return new Policy({\n      ...this.options,\n      errorFilter: e => this.options.errorFilter(e) || filter(e),\n    });\n  }\n\n  /**\n   * Allows the policy to additionally handles errors that pass the given\n   * predicate function.\n   *\n   * @param predicate Takes any thrown error, and returns true if it should\n   * be retried by this policy.\n   * @example\n   * ```js\n   * // only retry if the error has a \"shouldBeRetried\" property set\n   * new Policy()\n   *  .orWhen(err => err.shouldBeRetried === true)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orWhen(predicate: (error: Error) => boolean) {\n    return new Policy({\n      ...this.options,\n      errorFilter: e => this.options.errorFilter(e) || predicate(e),\n    });\n  }\n\n  /**\n   * Adds handling for return values. The predicate will be called with\n   * the return value of the executed function,\n   *\n   * @param predicate Takes the returned value, and returns true if it\n   * should be retried by this policy.\n   * @example\n   * ```js\n   * // retry when the response status code is a 5xx\n   * new Policy()\n   *  .orResultWhen(res => res.statusCode >= 500)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orWhenResult(predicate: (r: unknown) => boolean) {\n    return new Policy({\n      ...this.options,\n      resultFilter: r => this.options.resultFilter(r) || predicate(r),\n    });\n  }\n\n  /**\n   * Adds handling for return values. The predicate will be called with\n   * the return value of the executed function,\n   *\n   * @param predicate Takes the returned value, and returns true if it\n   * should be retried by this policy.\n   * @example\n   * ```js\n   * // retry when the response status code is a 5xx\n   * new Policy()\n   *  .orResultType(res => res.statusCode >= 500)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n    const filter = typeFilter(cls, predicate);\n    return new Policy({\n      ...this.options,\n      resultFilter: r => this.options.resultFilter(r) || filter(r),\n    });\n  }\n}\n\nexport const noop = new NoopPolicy();\n\n/**\n * A policy that handles all errors.\n */\nexport const handleAll = new Policy({ errorFilter: always, resultFilter: never });\n\n/**\n * See {@link Policy.orType} for usage.\n */\nexport function handleType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n  return new Policy({ errorFilter: typeFilter(cls, predicate), resultFilter: never });\n}\n\n/**\n * See {@link Policy.orWhen} for usage.\n */\nexport function handleWhen(predicate: (error: Error) => boolean) {\n  return new Policy({ errorFilter: predicate, resultFilter: never });\n}\n/**\n * See {@link Policy.orResultType} for usage.\n */\nexport function handleResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n  return new Policy({ errorFilter: never, resultFilter: typeFilter(cls, predicate) });\n}\n\n/**\n * See {@link Policy.orWhenResult} for usage.\n */\nexport function handleWhenResult(predicate: (error: unknown) => boolean) {\n  return new Policy({ errorFilter: never, resultFilter: predicate });\n}\n\n/**\n * Creates a bulkhead--a policy that limits the number of concurrent calls.\n */\nexport function bulkhead(limit: number, queue: number = 0) {\n  return new BulkheadPolicy(limit, queue);\n}\n\n/**\n * A decorator that can be used to wrap class methods and apply the given\n * policy to them. It also adds the last argument normally given in\n * {@link Policy.execute} as the last argument in the function call.\n * For example:\n *\n * ```ts\n * import { usePolicy, retry, handleAll } from 'cockatiel';\n *\n * const retry = retry(handleAll, { maxAttempts: 3 });\n *\n * class Database {\n *   @usePolicy(retry)\n *   public getUserInfo(userId, context, cancellationToken) {\n *     console.log('Retry attempt number', context.attempt);\n *     // implementation here\n *   }\n * }\n *\n * const db = new Database();\n * db.getUserInfo(3).then(info => console.log('User 3 info:', info))\n * ```\n *\n * Note that it will force the return type to be a Promise, since that's\n * what policies return.\n */\nexport function usePolicy(policy: IPolicy<IDefaultPolicyContext, never>) {\n  return (_target: unknown, _key: string, descriptor: PropertyDescriptor) => {\n    const inner = descriptor.value;\n    if (typeof inner !== 'function') {\n      throw new Error(`Can only decorate functions with @cockatiel, got ${typeof inner}`);\n    }\n\n    descriptor.value = function (this: unknown, ...args: any[]) {\n      const signal = args[args.length - 1] instanceof AbortSignal ? args.pop() : undefined;\n      return policy.execute(context => inner.apply(this, [...args, context]), signal);\n    };\n  };\n}\n\n/**\n * Creates a timeout policy.\n * @param duration - How long to wait before timing out execute()'d functions\n * @param strategy - Strategy for timeouts, \"Cooperative\" or \"Aggressive\".\n * A {@link CancellationToken} will be pass to any executed function, and in\n * cooperative timeouts we'll simply wait for that function to return or\n * throw. In aggressive timeouts, we'll immediately throw a\n * {@link TaskCancelledError} when the timeout is reached, in addition to\n * marking the passed token as failed.\n */\nexport function timeout(\n  duration: number,\n  strategyOrOpts: TimeoutStrategy | { strategy: TimeoutStrategy; abortOnReturn: boolean },\n) {\n  return new TimeoutPolicy(\n    duration,\n    typeof strategyOrOpts === 'string' ? { strategy: strategyOrOpts } : strategyOrOpts,\n  );\n}\n\n/**\n * Wraps the given set of policies into a single policy. For instance, this:\n *\n * ```js\n * retry.execute(() =>\n *  breaker.execute(() =>\n *    timeout.execute(({ cancellationToken }) => getData(cancellationToken))))\n * ```\n *\n * Is the equivalent to:\n *\n * ```js\n * Policy\n *  .wrap(retry, breaker, timeout)\n *  .execute(({ cancellationToken }) => getData(cancellationToken)));\n * ```\n *\n * The `context` argument passed to the executed function is the merged object\n * of all previous policies.\n *\n */\n// The types here a certain unattrative. Ideally we could do\n// `wrap<A, B>(p: IPolicy<A, B>): IPolicy<A, B>`, but TS doesn't narrow the\n// types well in that scenario (unless p is explicitly typed as an IPolicy\n// and not some implementation) and returns `IPolicy<void, unknown>` and\n// the like. This is the best solution I've found for it.\nexport function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A): A;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B): MergePolicies<A, B>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B, p3: C): MergePolicies<C, MergePolicies<A, B>>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n  D extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B, p3: C, p4: D): MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n  D extends IPolicy<IDefaultPolicyContext, unknown>,\n  E extends IPolicy<IDefaultPolicyContext, unknown>,\n>(\n  p1: A,\n  p2: B,\n  p3: C,\n  p4: D,\n  p5: E,\n): MergePolicies<E, MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>>;\nexport function wrap<C extends IDefaultPolicyContext, A>(...p: Array<IPolicy<C, A>>): IPolicy<C, A>;\nexport function wrap<C extends IDefaultPolicyContext, A>(\n  ...p: Array<IPolicy<C, A>>\n): IMergedPolicy<C, A, IPolicy<C, A>[]> {\n  return {\n    _altReturn: undefined as any,\n    onFailure: p[0].onFailure,\n    onSuccess: p[0].onSuccess,\n    wrapped: p,\n    execute<T>(fn: (context: C) => PromiseLike<T> | T, signal: AbortSignal): Promise<T | A> {\n      const run = (context: C, i: number): PromiseLike<T | A> | T | A =>\n        i === p.length\n          ? fn(context)\n          : p[i].execute(next => run({ ...context, ...next }, i + 1), context.signal);\n      return Promise.resolve(run({ signal } as C, 0));\n    },\n  };\n}\n\n/**\n * Creates a retry policy. The options should contain the backoff strategy to\n * use. Included strategies are:\n *  - {@link ConstantBackoff}\n *  - {@link ExponentialBackoff}\n *  - {@link IterableBackoff}\n *  - {@link DelegateBackoff} (advanced)\n *\n * For example:\n *\n * ```\n * import { handleAll, retry } from 'cockatiel';\n *\n * const policy = retry(handleAll, { backoff: new ExponentialBackoff() });\n * ```\n *\n * You can optionally pass in the `attempts` to limit the maximum number of\n * retry attempts per call.\n */\nexport function retry(\n  policy: Policy,\n  opts: {\n    maxAttempts?: number;\n    backoff?: IBackoffFactory<IRetryBackoffContext<unknown>>;\n  },\n) {\n  return new RetryPolicy(\n    { backoff: opts.backoff || new ConstantBackoff(0), maxAttempts: opts.maxAttempts ?? Infinity },\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n  );\n}\n\n/**\n * Returns a circuit breaker for the policy. **Important**: you should share\n * your circuit breaker between executions of whatever function you're\n * wrapping for it to function!\n *\n * ```ts\n * import { SamplingBreaker, Policy } from 'cockatiel';\n *\n * // Break if more than 20% of requests fail in a 30 second time window:\n * const breaker = Policy\n *  .handleAll()\n *  .circuitBreaker(10_000, new SamplingBreaker(0.2, 30 * 1000));\n *\n * export function handleRequest() {\n *   return breaker.execute(() => getInfoFromDatabase());\n * }\n * ```\n *\n * @param halfOpenAfter Time after failures to try to open the circuit\n * breaker again.\n * @param breaker The circuit breaker to use. This package exports\n * ConsecutiveBreaker and SamplingBreakers for you to use.\n */\nexport function circuitBreaker(policy: Policy, opts: ICircuitBreakerOptions) {\n  return new CircuitBreakerPolicy(\n    opts,\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n  );\n}\n\n/**\n * Falls back to the given value in the event of an error.\n *\n * ```ts\n * import { Policy } from 'cockatiel';\n *\n * const fallback = Policy\n *  .handleType(DatabaseError)\n *  .fallback(() => getStaleData());\n *\n * export function handleRequest() {\n *   return fallback.execute(() => getInfoFromDatabase());\n * }\n * ```\n *\n * @param toValue Value to fall back to, or a function that creates the\n * value to return (any may return a promise)\n */\nexport function fallback<R>(policy: Policy, valueOrFactory: (() => Promise<R> | R) | R) {\n  return new FallbackPolicy(\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n    // not technically type-safe, since if they actually want to _return_\n    // a function, that gets lost here. We'll just advice in the docs to\n    // use a higher-order function if necessary.\n    (typeof valueOrFactory === 'function' ? valueOrFactory : () => valueOrFactory) as () => R,\n  );\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"Policy.js","sourceRoot":"","sources":["../src/Policy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConstantBackoff, IBackoffFactory } from './backoff/Backoff';\nimport { BulkheadPolicy } from './BulkheadPolicy';\nimport { CircuitBreakerPolicy, ICircuitBreakerOptions } from './CircuitBreakerPolicy';\nimport { Event } from './common/Event';\nimport { ExecuteWrapper } from './common/Executor';\nimport { FallbackPolicy } from './FallbackPolicy';\nimport { NoopPolicy } from './NoopPolicy';\nimport { IRetryBackoffContext, RetryPolicy } from './RetryPolicy';\nimport { TimeoutPolicy, TimeoutStrategy } from './TimeoutPolicy';\nimport { AbortSignal } from './common/LocalAbortController';\n\ntype Constructor<T> = new (...args: any) => T;\n\nconst typeFilter = <T>(cls: Constructor<T>, predicate?: (error: T) => boolean) =>\n  predicate ? (v: unknown) => v instanceof cls && predicate(v) : (v: unknown) => v instanceof cls;\n\nconst always = () => true;\nconst never = () => false;\n\nexport interface IBasePolicyOptions {\n  errorFilter: (error: Error) => boolean;\n  resultFilter: (result: unknown) => boolean;\n}\n\n/**\n * The reason for a call failure. Either an error, or the a value that was\n * marked as a failure (when using result filtering).\n */\nexport type FailureReason<ReturnType> = { error: Error } | { value: ReturnType };\n\n/**\n * Event emitted on the `onFailure` calls.\n */\nexport interface IFailureEvent {\n  /**\n   * Call duration, in milliseconds (with nanosecond precision, as the OS allows).\n   */\n  duration: number;\n\n  /**\n   * Whether the error was handled by the policy.\n   */\n  handled: boolean;\n\n  /**\n   * The reason for the error.\n   */\n  reason: FailureReason<unknown>;\n}\n\n/**\n * Event emitted on the `onSuccess` calls.\n */\nexport interface ISuccessEvent {\n  /**\n   * Call duration, in milliseconds (with nanosecond precision, as the OS allows).\n   */\n  duration: number;\n}\n\nexport interface IDefaultPolicyContext {\n  /**\n   * Abort signal for the operation. This is propagated through multiple\n   * retry policies.\n   */\n  signal: AbortSignal;\n}\n\n/**\n * IPolicy is the type of all policies that Cockatiel provides. It describes\n * an execute() function which takes a generic argument.\n */\nexport interface IPolicy<\n  ContextType extends IDefaultPolicyContext = IDefaultPolicyContext,\n  AltReturn = never,\n> {\n  /**\n   * Virtual property only used for TypeScript--will not actually be defined.\n   * @deprecated This property does not exist\n   */\n  readonly _altReturn: AltReturn;\n\n  /**\n   * Fires on the policy when a request successfully completes and some\n   * successful value will be returned. In a retry policy, this is fired once\n   * even if the request took multiple retries to succeed.\n   */\n  readonly onSuccess: Event<ISuccessEvent>;\n\n  /**\n   * Fires on the policy when a request fails *due to a handled reason* fails\n   * and will give rejection to the called.\n   */\n  readonly onFailure: Event<IFailureEvent>;\n\n  /**\n   * Runs the function through behavior specified by the policy.\n   */\n  execute<T>(\n    fn: (context: ContextType) => PromiseLike<T> | T,\n    signal?: AbortSignal,\n  ): Promise<T | AltReturn>;\n}\n\nexport interface IMergedPolicy<A extends IDefaultPolicyContext, B, W extends IPolicy<any, any>[]>\n  extends IPolicy<A, B> {\n  readonly wrapped: W;\n}\n\ntype MergePolicies<A, B> =\n  A extends IPolicy<infer A1, any>\n    ? B extends IPolicy<infer B1, any>\n      ? IMergedPolicy<\n          A1 & B1,\n          A['_altReturn'] | B['_altReturn'],\n          B extends IMergedPolicy<any, any, infer W> ? [A, ...W] : [A, B]\n        >\n      : never\n    : never;\n\nexport class Policy {\n  /**\n   * Factory that builds a base set of filters that can be used in circuit\n   * breakers, retries, etc.\n   */\n  constructor(public readonly options: Readonly<IBasePolicyOptions>) {}\n\n  /**\n   * Allows the policy to additionally handles errors of the given type.\n   *\n   * @param cls Class constructor to check that the error is an instance of.\n   * @param predicate If provided, a function to be called with the error\n   * which should return \"true\" if we want to handle this error.\n   * @example\n   * ```js\n   * // retry both network errors and response errors with a 503 status code\n   * new Policy()\n   *  .orType(NetworkError)\n   *  .orType(ResponseError, err => err.statusCode === 503)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n    const filter = typeFilter(cls, predicate);\n    return new Policy({\n      ...this.options,\n      errorFilter: e => this.options.errorFilter(e) || filter(e),\n    });\n  }\n\n  /**\n   * Allows the policy to additionally handles errors that pass the given\n   * predicate function.\n   *\n   * @param predicate Takes any thrown error, and returns true if it should\n   * be retried by this policy.\n   * @example\n   * ```js\n   * // only retry if the error has a \"shouldBeRetried\" property set\n   * new Policy()\n   *  .orWhen(err => err.shouldBeRetried === true)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orWhen(predicate: (error: Error) => boolean) {\n    return new Policy({\n      ...this.options,\n      errorFilter: e => this.options.errorFilter(e) || predicate(e),\n    });\n  }\n\n  /**\n   * Adds handling for return values. The predicate will be called with\n   * the return value of the executed function,\n   *\n   * @param predicate Takes the returned value, and returns true if it\n   * should be retried by this policy.\n   * @example\n   * ```js\n   * // retry when the response status code is a 5xx\n   * new Policy()\n   *  .orResultWhen(res => res.statusCode >= 500)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orWhenResult(predicate: (r: unknown) => boolean) {\n    return new Policy({\n      ...this.options,\n      resultFilter: r => this.options.resultFilter(r) || predicate(r),\n    });\n  }\n\n  /**\n   * Adds handling for return values. The predicate will be called with\n   * the return value of the executed function,\n   *\n   * @param predicate Takes the returned value, and returns true if it\n   * should be retried by this policy.\n   * @example\n   * ```js\n   * // retry when the response status code is a 5xx\n   * new Policy()\n   *  .orResultType(res => res.statusCode >= 500)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n    const filter = typeFilter(cls, predicate);\n    return new Policy({\n      ...this.options,\n      resultFilter: r => this.options.resultFilter(r) || filter(r),\n    });\n  }\n}\n\nexport const noop = new NoopPolicy();\n\n/**\n * A policy that handles all errors.\n */\nexport const handleAll = new Policy({ errorFilter: always, resultFilter: never });\n\n/**\n * See {@link Policy.orType} for usage.\n */\nexport function handleType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n  return new Policy({ errorFilter: typeFilter(cls, predicate), resultFilter: never });\n}\n\n/**\n * See {@link Policy.orWhen} for usage.\n */\nexport function handleWhen(predicate: (error: Error) => boolean) {\n  return new Policy({ errorFilter: predicate, resultFilter: never });\n}\n/**\n * See {@link Policy.orResultType} for usage.\n */\nexport function handleResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n  return new Policy({ errorFilter: never, resultFilter: typeFilter(cls, predicate) });\n}\n\n/**\n * See {@link Policy.orWhenResult} for usage.\n */\nexport function handleWhenResult(predicate: (error: unknown) => boolean) {\n  return new Policy({ errorFilter: never, resultFilter: predicate });\n}\n\n/**\n * Creates a bulkhead--a policy that limits the number of concurrent calls.\n */\nexport function bulkhead(limit: number, queue: number = 0) {\n  return new BulkheadPolicy(limit, queue);\n}\n\n/**\n * A decorator that can be used to wrap class methods and apply the given\n * policy to them. It also adds the last argument normally given in\n * {@link Policy.execute} as the last argument in the function call.\n * For example:\n *\n * ```ts\n * import { usePolicy, retry, handleAll } from 'cockatiel';\n *\n * const retry = retry(handleAll, { maxAttempts: 3 });\n *\n * class Database {\n *   @usePolicy(retry)\n *   public getUserInfo(userId, context, cancellationToken) {\n *     console.log('Retry attempt number', context.attempt);\n *     // implementation here\n *   }\n * }\n *\n * const db = new Database();\n * db.getUserInfo(3).then(info => console.log('User 3 info:', info))\n * ```\n *\n * Note that it will force the return type to be a Promise, since that's\n * what policies return.\n */\nexport function usePolicy(policy: IPolicy<IDefaultPolicyContext, never>) {\n  return (_target: unknown, _key: string, descriptor: PropertyDescriptor) => {\n    const inner = descriptor.value;\n    if (typeof inner !== 'function') {\n      throw new Error(`Can only decorate functions with @cockatiel, got ${typeof inner}`);\n    }\n\n    descriptor.value = function (this: unknown, ...args: any[]) {\n      const signal = args[args.length - 1] && \n        typeof args[args.length - 1] === 'object' && \n        'aborted' in args[args.length - 1] && \n        'addEventListener' in args[args.length - 1] \n        ? args.pop() : undefined;\n      return policy.execute(context => inner.apply(this, [...args, context]), signal);\n    };\n  };\n}\n\n/**\n * Creates a timeout policy.\n * @param duration - How long to wait before timing out execute()'d functions\n * @param strategy - Strategy for timeouts, \"Cooperative\" or \"Aggressive\".\n * A {@link CancellationToken} will be pass to any executed function, and in\n * cooperative timeouts we'll simply wait for that function to return or\n * throw. In aggressive timeouts, we'll immediately throw a\n * {@link TaskCancelledError} when the timeout is reached, in addition to\n * marking the passed token as failed.\n */\nexport function timeout(\n  duration: number,\n  strategyOrOpts: TimeoutStrategy | { strategy: TimeoutStrategy; abortOnReturn: boolean },\n) {\n  return new TimeoutPolicy(\n    duration,\n    typeof strategyOrOpts === 'string' ? { strategy: strategyOrOpts } : strategyOrOpts,\n  );\n}\n\n/**\n * Wraps the given set of policies into a single policy. For instance, this:\n *\n * ```js\n * retry.execute(() =>\n *  breaker.execute(() =>\n *    timeout.execute(({ cancellationToken }) => getData(cancellationToken))))\n * ```\n *\n * Is the equivalent to:\n *\n * ```js\n * Policy\n *  .wrap(retry, breaker, timeout)\n *  .execute(({ cancellationToken }) => getData(cancellationToken)));\n * ```\n *\n * The `context` argument passed to the executed function is the merged object\n * of all previous policies.\n *\n */\n// The types here a certain unattrative. Ideally we could do\n// `wrap<A, B>(p: IPolicy<A, B>): IPolicy<A, B>`, but TS doesn't narrow the\n// types well in that scenario (unless p is explicitly typed as an IPolicy\n// and not some implementation) and returns `IPolicy<void, unknown>` and\n// the like. This is the best solution I've found for it.\nexport function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A): A;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B): MergePolicies<A, B>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B, p3: C): MergePolicies<C, MergePolicies<A, B>>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n  D extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B, p3: C, p4: D): MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n  D extends IPolicy<IDefaultPolicyContext, unknown>,\n  E extends IPolicy<IDefaultPolicyContext, unknown>,\n>(\n  p1: A,\n  p2: B,\n  p3: C,\n  p4: D,\n  p5: E,\n): MergePolicies<E, MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>>;\nexport function wrap<C extends IDefaultPolicyContext, A>(...p: Array<IPolicy<C, A>>): IPolicy<C, A>;\nexport function wrap<C extends IDefaultPolicyContext, A>(\n  ...p: Array<IPolicy<C, A>>\n): IMergedPolicy<C, A, IPolicy<C, A>[]> {\n  return {\n    _altReturn: undefined as any,\n    onFailure: p[0].onFailure,\n    onSuccess: p[0].onSuccess,\n    wrapped: p,\n    execute<T>(fn: (context: C) => PromiseLike<T> | T, signal: AbortSignal): Promise<T | A> {\n      const run = (context: C, i: number): PromiseLike<T | A> | T | A =>\n        i === p.length\n          ? fn(context)\n          : p[i].execute(next => run({ ...context, ...next }, i + 1), context.signal);\n      return Promise.resolve(run({ signal } as C, 0));\n    },\n  };\n}\n\n/**\n * Creates a retry policy. The options should contain the backoff strategy to\n * use. Included strategies are:\n *  - {@link ConstantBackoff}\n *  - {@link ExponentialBackoff}\n *  - {@link IterableBackoff}\n *  - {@link DelegateBackoff} (advanced)\n *\n * For example:\n *\n * ```\n * import { handleAll, retry } from 'cockatiel';\n *\n * const policy = retry(handleAll, { backoff: new ExponentialBackoff() });\n * ```\n *\n * You can optionally pass in the `attempts` to limit the maximum number of\n * retry attempts per call.\n */\nexport function retry(\n  policy: Policy,\n  opts: {\n    maxAttempts?: number;\n    backoff?: IBackoffFactory<IRetryBackoffContext<unknown>>;\n  },\n) {\n  return new RetryPolicy(\n    { backoff: opts.backoff || new ConstantBackoff(0), maxAttempts: opts.maxAttempts ?? Infinity },\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n  );\n}\n\n/**\n * Returns a circuit breaker for the policy. **Important**: you should share\n * your circuit breaker between executions of whatever function you're\n * wrapping for it to function!\n *\n * ```ts\n * import { SamplingBreaker, Policy } from 'cockatiel';\n *\n * // Break if more than 20% of requests fail in a 30 second time window:\n * const breaker = Policy\n *  .handleAll()\n *  .circuitBreaker(10_000, new SamplingBreaker(0.2, 30 * 1000));\n *\n * export function handleRequest() {\n *   return breaker.execute(() => getInfoFromDatabase());\n * }\n * ```\n *\n * @param halfOpenAfter Time after failures to try to open the circuit\n * breaker again.\n * @param breaker The circuit breaker to use. This package exports\n * ConsecutiveBreaker and SamplingBreakers for you to use.\n */\nexport function circuitBreaker(policy: Policy, opts: ICircuitBreakerOptions) {\n  return new CircuitBreakerPolicy(\n    opts,\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n  );\n}\n\n/**\n * Falls back to the given value in the event of an error.\n *\n * ```ts\n * import { Policy } from 'cockatiel';\n *\n * const fallback = Policy\n *  .handleType(DatabaseError)\n *  .fallback(() => getStaleData());\n *\n * export function handleRequest() {\n *   return fallback.execute(() => getInfoFromDatabase());\n * }\n * ```\n *\n * @param toValue Value to fall back to, or a function that creates the\n * value to return (any may return a promise)\n */\nexport function fallback<R>(policy: Policy, valueOrFactory: (() => Promise<R> | R) | R) {\n  return new FallbackPolicy(\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n    // not technically type-safe, since if they actually want to _return_\n    // a function, that gets lost here. We'll just advice in the docs to\n    // use a higher-order function if necessary.\n    (typeof valueOrFactory === 'function' ? valueOrFactory : () => valueOrFactory) as () => R,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/Policy.test.d.ts b/node_modules/cockatiel/dist/Policy.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/Policy.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/Policy.test.js b/node_modules/cockatiel/dist/Policy.test.js
new file mode 100644
index 0000000..26d09d9
--- /dev/null
+++ b/node_modules/cockatiel/dist/Policy.test.js
@@ -0,0 +1,134 @@
+"use strict";
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const sinon_1 = require("sinon");
+const LocalAbortController_1 = require("./common/LocalAbortController");
+const Breaker_1 = require("./breaker/Breaker");
+const Errors_1 = require("./errors/Errors");
+const Policy_1 = require("./Policy");
+const TimeoutPolicy_1 = require("./TimeoutPolicy");
+class MyError1 extends Error {
+}
+class MyError2 extends Error {
+}
+class MyError3 extends Error {
+}
+const assertNever = (_value) => {
+    throw new Error('unreachable');
+};
+describe('Policy', () => {
+    it('wraps', async () => {
+        const policy = (0, Policy_1.wrap)((0, Policy_1.retry)((0, Policy_1.handleType)(MyError1), { maxAttempts: 3 }), (0, Policy_1.circuitBreaker)(Policy_1.handleAll, { halfOpenAfter: 100, breaker: new Breaker_1.ConsecutiveBreaker(2) }));
+        // should retry and break the circuit
+        await (0, chai_1.expect)(policy.execute((0, sinon_1.stub)().throws(new MyError1()))).to.be.rejectedWith(Errors_1.BrokenCircuitError);
+    });
+    it('wraps and keeps correct types', async () => {
+        const policies = [
+            (0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 2 }),
+            (0, Policy_1.circuitBreaker)(Policy_1.handleAll, { halfOpenAfter: 100, breaker: new Breaker_1.ConsecutiveBreaker(2) }),
+            (0, Policy_1.fallback)(Policy_1.handleAll, 'foo'),
+            (0, Policy_1.timeout)(1000, TimeoutPolicy_1.TimeoutStrategy.Aggressive),
+            Policy_1.noop,
+        ];
+        const policy = (0, Policy_1.wrap)(...policies);
+        (0, chai_1.expect)(policy.wrapped).to.deep.equal(policies);
+        const result = await policy.execute(context => {
+            (0, chai_1.expect)(context.signal).to.have.property('aborted');
+            (0, chai_1.expect)(context.signal).to.have.property('reason');
+            (0, chai_1.expect)(context.attempt).to.equal(0);
+            return 1234;
+        });
+        switch (typeof result) {
+            case 'string':
+                result.toUpperCase();
+                break;
+            case 'number':
+                Math.pow(result, 2);
+                break;
+            default:
+                assertNever(result);
+        }
+    });
+    it('applies error filters', async () => {
+        const fn = (0, sinon_1.stub)()
+            .onCall(0)
+            .throws(new MyError1())
+            .onCall(1)
+            .throws(new MyError2())
+            .onCall(2)
+            .throws(new MyError3('foo'))
+            .onCall(3)
+            .throws(new Error('potato'))
+            .onCall(4)
+            .throws(new MyError3('bar'));
+        await (0, chai_1.expect)((0, Policy_1.retry)((0, Policy_1.handleType)(MyError1)
+            .orType(MyError2)
+            .orType(MyError3, e => e.message === 'foo')
+            .orWhen(e => e.message === 'potato'), { maxAttempts: 10 }).execute(fn)).to.be.rejectedWith(MyError3, 'bar');
+        (0, chai_1.expect)(fn).to.have.callCount(5);
+    });
+    it('applies result filters', async () => {
+        const fn = (0, sinon_1.stub)()
+            .onCall(0)
+            .returns(new MyError1())
+            .onCall(1)
+            .returns(new MyError2())
+            .onCall(2)
+            .returns(new MyError3('foo'))
+            .onCall(3)
+            .returns('potato')
+            .onCall(4)
+            .returns('ok!');
+        (0, chai_1.expect)(await (0, Policy_1.retry)((0, Policy_1.handleResultType)(MyError1)
+            .orResultType(MyError2)
+            .orResultType(MyError3, e => e.message === 'foo')
+            .orWhenResult(e => e === 'potato'), { maxAttempts: 10 }).execute(fn)).to.equal('ok!');
+        (0, chai_1.expect)(fn).to.have.callCount(5);
+    });
+    it('applies use', async () => {
+        class Calculator {
+            double(n, context) {
+                if (context.attempt < 2) {
+                    throw new Error('failed');
+                }
+                return { n: n * 2, ...context };
+            }
+        }
+        __decorate([
+            (0, Policy_1.usePolicy)((0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 5 }))
+        ], Calculator.prototype, "double", null);
+        const c = new Calculator();
+        // @ts-ignore
+        const r = await c.double(2);
+        (0, chai_1.expect)(r).to.deep.equal({
+            n: 4,
+            signal: r.signal,
+            attempt: 2,
+        });
+    });
+    it('uses cancellation token in use', async () => {
+        class Calculator {
+            double(n, context) {
+                (0, chai_1.expect)(n).to.equal(2);
+                (0, chai_1.expect)(context.signal.aborted).to.be.false;
+                cts.abort();
+                (0, chai_1.expect)(context.signal.aborted).to.be.true;
+                return n * 2;
+            }
+        }
+        __decorate([
+            (0, Policy_1.usePolicy)((0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 5 }))
+        ], Calculator.prototype, "double", null);
+        const cts = (0, LocalAbortController_1.createAbortController)();
+        const c = new Calculator();
+        // @ts-ignore
+        (0, chai_1.expect)(await c.double(2, cts.signal)).to.equal(4);
+    });
+});
+//# sourceMappingURL=Policy.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/Policy.test.js.map b/node_modules/cockatiel/dist/Policy.test.js.map
new file mode 100644
index 0000000..118840d
--- /dev/null
+++ b/node_modules/cockatiel/dist/Policy.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Policy.test.js","sourceRoot":"","sources":["../src/Policy.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from 'chai';\nimport { stub } from 'sinon';\nimport { createAbortController } from './common/LocalAbortController';\nimport { ConsecutiveBreaker } from './breaker/Breaker';\nimport { BrokenCircuitError } from './errors/Errors';\nimport {\n  circuitBreaker,\n  fallback,\n  handleAll,\n  handleResultType,\n  handleType,\n  noop,\n  retry,\n  timeout,\n  usePolicy,\n  wrap,\n} from './Policy';\nimport { IRetryContext } from './RetryPolicy';\nimport { TimeoutStrategy } from './TimeoutPolicy';\n\nclass MyError1 extends Error {}\nclass MyError2 extends Error {}\nclass MyError3 extends Error {}\n\nconst assertNever = (_value: never) => {\n  throw new Error('unreachable');\n};\n\ndescribe('Policy', () => {\n  it('wraps', async () => {\n    const policy = wrap(\n      retry(handleType(MyError1), { maxAttempts: 3 }),\n      circuitBreaker(handleAll, { halfOpenAfter: 100, breaker: new ConsecutiveBreaker(2) }),\n    );\n\n    // should retry and break the circuit\n    await expect(policy.execute(stub().throws(new MyError1()))).to.be.rejectedWith(\n      BrokenCircuitError,\n    );\n  });\n\n  it('wraps and keeps correct types', async () => {\n    const policies = [\n      retry(handleAll, { maxAttempts: 2 }),\n      circuitBreaker(handleAll, { halfOpenAfter: 100, breaker: new ConsecutiveBreaker(2) }),\n      fallback(handleAll, 'foo'),\n      timeout(1000, TimeoutStrategy.Aggressive),\n      noop,\n    ] as const;\n    const policy = wrap(...policies);\n\n    expect(policy.wrapped).to.deep.equal(policies);\n\n    const result = await policy.execute(context => {\n      expect(context.signal).to.have.property('aborted');\n      expect(context.signal).to.have.property('reason');\n      expect(context.attempt).to.equal(0);\n      return 1234;\n    });\n\n    switch (typeof result) {\n      case 'string':\n        result.toUpperCase();\n        break;\n      case 'number':\n        Math.pow(result, 2);\n        break;\n      default:\n        assertNever(result);\n    }\n  });\n\n  it('applies error filters', async () => {\n    const fn = stub()\n      .onCall(0)\n      .throws(new MyError1())\n      .onCall(1)\n      .throws(new MyError2())\n      .onCall(2)\n      .throws(new MyError3('foo'))\n      .onCall(3)\n      .throws(new Error('potato'))\n      .onCall(4)\n      .throws(new MyError3('bar'));\n\n    await expect(\n      retry(\n        handleType(MyError1)\n          .orType(MyError2)\n          .orType(MyError3, e => e.message === 'foo')\n          .orWhen(e => e.message === 'potato'),\n        { maxAttempts: 10 },\n      ).execute(fn),\n    ).to.be.rejectedWith(MyError3, 'bar');\n\n    expect(fn).to.have.callCount(5);\n  });\n\n  it('applies result filters', async () => {\n    const fn = stub()\n      .onCall(0)\n      .returns(new MyError1())\n      .onCall(1)\n      .returns(new MyError2())\n      .onCall(2)\n      .returns(new MyError3('foo'))\n      .onCall(3)\n      .returns('potato')\n      .onCall(4)\n      .returns('ok!');\n\n    expect(\n      await retry(\n        handleResultType(MyError1)\n          .orResultType(MyError2)\n          .orResultType(MyError3, e => e.message === 'foo')\n          .orWhenResult(e => e === 'potato'),\n        { maxAttempts: 10 },\n      ).execute(fn),\n    ).to.equal('ok!');\n\n    expect(fn).to.have.callCount(5);\n  });\n\n  it('applies use', async () => {\n    class Calculator {\n      @usePolicy(retry(handleAll, { maxAttempts: 5 }))\n      public double(n: number, context: IRetryContext) {\n        if (context!.attempt < 2) {\n          throw new Error('failed');\n        }\n\n        return { n: n * 2, ...context! };\n      }\n    }\n\n    const c = new Calculator();\n    // @ts-ignore\n    const r = await c.double(2);\n    expect(r).to.deep.equal({\n      n: 4,\n      signal: r.signal,\n      attempt: 2,\n    });\n  });\n\n  it('uses cancellation token in use', async () => {\n    class Calculator {\n      @usePolicy(retry(handleAll, { maxAttempts: 5 }))\n      public double(n: number, context: IRetryContext) {\n        expect(n).to.equal(2);\n        expect(context.signal.aborted).to.be.false;\n        cts.abort();\n        expect(context.signal.aborted).to.be.true;\n        return n * 2;\n      }\n    }\n\n    const cts = createAbortController();\n    const c = new Calculator();\n    // @ts-ignore\n    expect(await c.double(2, cts.signal)).to.equal(4);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/RetryPolicy.d.ts b/node_modules/cockatiel/dist/RetryPolicy.d.ts
index 11d86ca..a95a474 100644
--- a/node_modules/cockatiel/dist/RetryPolicy.d.ts
+++ b/node_modules/cockatiel/dist/RetryPolicy.d.ts
@@ -68,5 +68,5 @@ export declare class RetryPolicy implements IPolicy<IRetryContext> {
      * @param fn Function to run
      * @returns a Promise that resolves or rejects with the function results.
      */
-    execute<T>(fn: (context: IRetryContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
+    execute<T>(fn: (context: IRetryContext) => PromiseLike<T> | T, signal?: import("./common/LocalAbortController").LocalAbortSignal): Promise<T>;
 }
diff --git a/node_modules/cockatiel/dist/RetryPolicy.test.d.ts b/node_modules/cockatiel/dist/RetryPolicy.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/RetryPolicy.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/RetryPolicy.test.js b/node_modules/cockatiel/dist/RetryPolicy.test.js
new file mode 100644
index 0000000..20c3ed0
--- /dev/null
+++ b/node_modules/cockatiel/dist/RetryPolicy.test.js
@@ -0,0 +1,141 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const sinon_1 = require("sinon");
+const Backoff_1 = require("./backoff/Backoff");
+const util_test_1 = require("./common/util.test");
+const LocalAbortController_1 = require("./common/LocalAbortController");
+const Policy_1 = require("./Policy");
+(0, chai_1.use)(require('sinon-chai'));
+(0, chai_1.use)(require('chai-as-promised'));
+class MyErrorA extends Error {
+    constructor() {
+        super('Error A');
+    }
+}
+class MyErrorB extends Error {
+    constructor() {
+        super('Error B');
+    }
+}
+describe('RetryPolicy', () => {
+    it('types return data correctly in all cases', async () => {
+        const policy = (0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 1 });
+        const multiply = (n) => n * 2;
+        multiply(await policy.execute(() => 42));
+        multiply(await policy.execute(async () => 42));
+    });
+    describe('setting backoffs', () => {
+        let s;
+        let clock;
+        let delays;
+        beforeEach(() => {
+            clock = (0, sinon_1.useFakeTimers)();
+            delays = [];
+            s = (0, sinon_1.stub)().throws(new MyErrorA());
+        });
+        afterEach(() => clock.restore());
+        const makePolicy = (durations) => {
+            const p = (0, Policy_1.retry)(Policy_1.handleAll, {
+                maxAttempts: durations.length,
+                backoff: new Backoff_1.IterableBackoff(durations),
+            });
+            p.onRetry(({ delay }) => {
+                delays.push(delay);
+                clock.tick(delay);
+            });
+            return p;
+        };
+        it('sets the retry delay', async () => {
+            await (0, chai_1.expect)(makePolicy([50]).execute(s)).to.eventually.be.rejectedWith(MyErrorA);
+            (0, chai_1.expect)(delays).to.deep.equal([50]);
+            (0, chai_1.expect)(s).to.have.been.calledTwice;
+        });
+        it('sets the retry sequence', async () => {
+            await (0, chai_1.expect)(makePolicy([10, 20, 20]).execute(s)).to.eventually.be.rejectedWith(MyErrorA);
+            (0, chai_1.expect)(delays).to.deep.equal([10, 20, 20]);
+            (0, chai_1.expect)(s).to.have.callCount(4);
+        });
+    });
+    it('retries all errors', async () => {
+        const s = (0, sinon_1.stub)().onFirstCall().throws(new MyErrorA()).onSecondCall().returns('ok');
+        (0, chai_1.expect)(await (0, Policy_1.retry)(Policy_1.handleAll, {}).execute(s)).to.equal('ok');
+        (0, chai_1.expect)(s).to.have.been.calledTwice;
+    });
+    it('filters error types', async () => {
+        const s = (0, sinon_1.stub)().onFirstCall().throws(new MyErrorA()).onSecondCall().throws(new MyErrorB());
+        await (0, chai_1.expect)((0, Policy_1.retry)((0, Policy_1.handleType)(MyErrorA), { maxAttempts: 5 }).execute(s)).to.eventually.be.rejectedWith(MyErrorB);
+        (0, chai_1.expect)(s).to.have.been.calledTwice;
+    });
+    it('filters returns', async () => {
+        const s = (0, sinon_1.stub)().onFirstCall().returns(1).onSecondCall().returns(2);
+        (0, chai_1.expect)(await (0, Policy_1.retry)((0, Policy_1.handleWhenResult)(r => typeof r === 'number' && r < 2), { maxAttempts: 5 }).execute(s)).to.equal(2);
+        (0, chai_1.expect)(s).to.have.been.calledTwice;
+    });
+    it('permits specifying exponential backoffs', async () => {
+        const s = (0, sinon_1.stub)().returns(1);
+        (0, chai_1.expect)(await (0, Policy_1.retry)((0, Policy_1.handleWhenResult)(r => typeof r === 'number'), { backoff: new Backoff_1.ExponentialBackoff({ generator: Backoff_1.noJitterGenerator }), maxAttempts: 2 }).execute(s)).to.equal(1);
+        (0, chai_1.expect)(s).to.have.callCount(3);
+    });
+    it('bubbles returns when retry attempts exceeded', async () => {
+        const s = (0, sinon_1.stub)().returns(1);
+        (0, chai_1.expect)(await (0, Policy_1.retry)((0, Policy_1.handleWhenResult)(r => typeof r === 'number' && r < 2), { maxAttempts: 5 }).execute(s)).to.equal(1);
+        (0, chai_1.expect)(s).to.have.callCount(6);
+    });
+    it('bubbles errors when retry attempts exceeded', async () => {
+        const s = (0, sinon_1.stub)().throws(new MyErrorB());
+        await (0, chai_1.expect)((0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 5 }).execute(s)).to.eventually.be.rejectedWith(MyErrorB);
+        (0, chai_1.expect)(s).to.have.callCount(6);
+    });
+    it('does not unref by default', async () => {
+        const output = await (0, util_test_1.runInChild)(`
+      c.retry(c.handleAll, { maxAttempts: 1 }).execute(() => {
+        console.log('attempt');
+        throw new Error('oh no!');
+      });
+    `);
+        (0, chai_1.expect)(output).to.contain('oh no!');
+    });
+    it('unrefs as requested', async () => {
+        const output = await (0, util_test_1.runInChild)(`
+    c.retry(c.handleAll, { maxAttempts: 1 }).dangerouslyUnref().execute(() => {
+      console.log('attempt');
+      throw new Error('oh no!');
+    });
+    `);
+        (0, chai_1.expect)(output).to.equal('attempt');
+    });
+    it('stops retries if cancellation is requested', async () => {
+        const parent = (0, LocalAbortController_1.createAbortController)();
+        const err = new Error();
+        let calls = 0;
+        await (0, chai_1.expect)((0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 3 }).execute(({ signal }) => {
+            calls++;
+            (0, chai_1.expect)(signal.aborted).to.be.false;
+            parent.abort();
+            (0, chai_1.expect)(signal.aborted).to.be.true;
+            throw err;
+        }, parent.signal)).to.eventually.be.rejectedWith(err);
+        (0, chai_1.expect)(calls).to.equal(1);
+    });
+    it('fires onGiveUp', async () => {
+        const err = new MyErrorA();
+        const s = (0, sinon_1.stub)().throws(err);
+        const policy = (0, Policy_1.retry)((0, Policy_1.handleType)(MyErrorA), { maxAttempts: 5 });
+        const onGiveUp = (0, sinon_1.stub)();
+        policy.onGiveUp(onGiveUp);
+        await (0, chai_1.expect)(policy.execute(s)).to.eventually.be.rejectedWith(MyErrorA);
+        (0, chai_1.expect)(onGiveUp).to.have.been.calledWith({ error: err });
+    });
+    it('provides the attempt to the onRetry callback', async () => {
+        const s = (0, sinon_1.stub)().throws(new MyErrorA());
+        const attempts = [];
+        const policy = (0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 3 });
+        policy.onRetry(({ attempt }) => {
+            attempts.push(attempt);
+        });
+        await (0, chai_1.expect)(policy.execute(s)).to.eventually.be.rejectedWith(MyErrorA);
+        (0, chai_1.expect)(attempts).to.deep.equal([1, 2, 3]);
+    });
+});
+//# sourceMappingURL=RetryPolicy.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/RetryPolicy.test.js.map b/node_modules/cockatiel/dist/RetryPolicy.test.js.map
new file mode 100644
index 0000000..123a238
--- /dev/null
+++ b/node_modules/cockatiel/dist/RetryPolicy.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"RetryPolicy.test.js","sourceRoot":"","sources":["../src/RetryPolicy.test.ts"],"names":[],"mappings":";;AAAA,+BAAmC;AACnC,iCAAwE;AACxE,+CAA2F;AAC3F,kDAAgD;AAChD,wEAAsE;AACtE,qCAA0E;AAE1E,IAAA,UAAG,EAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;AAC3B,IAAA,UAAG,EAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC,CAAC;AAEjC,MAAM,QAAS,SAAQ,KAAK;IAC1B;QACE,KAAK,CAAC,SAAS,CAAC,CAAC;IACnB,CAAC;CACF;AACD,MAAM,QAAS,SAAQ,KAAK;IAC1B;QACE,KAAK,CAAC,SAAS,CAAC,CAAC;IACnB,CAAC;CACF;AAED,QAAQ,CAAC,aAAa,EAAE,GAAG,EAAE;IAC3B,EAAE,CAAC,0CAA0C,EAAE,KAAK,IAAI,EAAE;QACxD,MAAM,MAAM,GAAG,IAAA,cAAK,EAAC,kBAAS,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;QACpD,MAAM,QAAQ,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;QACtC,QAAQ,CAAC,MAAM,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACzC,QAAQ,CAAC,MAAM,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACjD,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,kBAAkB,EAAE,GAAG,EAAE;QAChC,IAAI,CAAY,CAAC;QACjB,IAAI,KAAsB,CAAC;QAC3B,IAAI,MAAgB,CAAC;QACrB,UAAU,CAAC,GAAG,EAAE;YACd,KAAK,GAAG,IAAA,qBAAa,GAAE,CAAC;YACxB,MAAM,GAAG,EAAE,CAAC;YACZ,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QAEH,SAAS,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QAEjC,MAAM,UAAU,GAAG,CAAC,SAAmB,EAAE,EAAE;YACzC,MAAM,CAAC,GAAG,IAAA,cAAK,EAAC,kBAAS,EAAE;gBACzB,WAAW,EAAE,SAAS,CAAC,MAAM;gBAC7B,OAAO,EAAE,IAAI,yBAAe,CAAC,SAAS,CAAC;aACxC,CAAC,CAAC;YACH,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE;gBACtB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACnB,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACpB,CAAC,CAAC,CAAC;YACH,OAAO,CAAC,CAAC;QACX,CAAC,CAAC;QAEF,EAAE,CAAC,sBAAsB,EAAE,KAAK,IAAI,EAAE;YACpC,MAAM,IAAA,aAAM,EAAC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;YAClF,IAAA,aAAM,EAAC,MAAM,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACnC,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;QACrC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,yBAAyB,EAAE,KAAK,IAAI,EAAE;YACvC,MAAM,IAAA,aAAM,EAAC,UAAU,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;YAC1F,IAAA,aAAM,EAAC,MAAM,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;YAC3C,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACjC,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,oBAAoB,EAAE,KAAK,IAAI,EAAE;QAClC,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAEnF,IAAA,aAAM,EAAC,MAAM,IAAA,cAAK,EAAC,kBAAS,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAE7D,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;IACrC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,qBAAqB,EAAE,KAAK,IAAI,EAAE;QACnC,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC,YAAY,EAAE,CAAC,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC;QAE5F,MAAM,IAAA,aAAM,EACV,IAAA,cAAK,EAAC,IAAA,mBAAU,EAAC,QAAQ,CAAC,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAC3D,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAE1C,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;IACrC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,iBAAiB,EAAE,KAAK,IAAI,EAAE;QAC/B,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAEpE,IAAA,aAAM,EACJ,MAAM,IAAA,cAAK,EACT,IAAA,yBAAgB,EAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAC,EACrD,EAAE,WAAW,EAAE,CAAC,EAAE,CACnB,CAAC,OAAO,CAAC,CAAC,CAAC,CACb,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAEd,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;IACrC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,yCAAyC,EAAE,KAAK,IAAI,EAAE;QACvD,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAE5B,IAAA,aAAM,EACJ,MAAM,IAAA,cAAK,EACT,IAAA,yBAAgB,EAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,CAAC,EAC5C,EAAE,OAAO,EAAE,IAAI,4BAAkB,CAAC,EAAE,SAAS,EAAE,2BAAiB,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAE,CACtF,CAAC,OAAO,CAAC,CAAC,CAAC,CACb,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAEd,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8CAA8C,EAAE,KAAK,IAAI,EAAE;QAC5D,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAE5B,IAAA,aAAM,EACJ,MAAM,IAAA,cAAK,EACT,IAAA,yBAAgB,EAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAC,EACrD,EAAE,WAAW,EAAE,CAAC,EAAE,CACnB,CAAC,OAAO,CAAC,CAAC,CAAC,CACb,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAEd,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6CAA6C,EAAE,KAAK,IAAI,EAAE;QAC3D,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC;QAExC,MAAM,IAAA,aAAM,EAAC,IAAA,cAAK,EAAC,kBAAS,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,CACzF,QAAQ,CACT,CAAC;QAEF,IAAA,aAAM,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,2BAA2B,EAAE,KAAK,IAAI,EAAE;QACzC,MAAM,MAAM,GAAG,MAAM,IAAA,sBAAU,EAAC;;;;;KAK/B,CAAC,CAAC;QAEH,IAAA,aAAM,EAAC,MAAM,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,qBAAqB,EAAE,KAAK,IAAI,EAAE;QACnC,MAAM,MAAM,GAAG,MAAM,IAAA,sBAAU,EAAC;;;;;KAK/B,CAAC,CAAC;QAEH,IAAA,aAAM,EAAC,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACrC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4CAA4C,EAAE,KAAK,IAAI,EAAE;QAC1D,MAAM,MAAM,GAAG,IAAA,4CAAqB,GAAE,CAAC;QACvC,MAAM,GAAG,GAAG,IAAI,KAAK,EAAE,CAAC;QACxB,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,MAAM,IAAA,aAAM,EACV,IAAA,cAAK,EAAC,kBAAS,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE;YAC1D,KAAK,EAAE,CAAC;YACR,IAAA,aAAM,EAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;YACnC,MAAM,CAAC,KAAK,EAAE,CAAC;YACf,IAAA,aAAM,EAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;YAClC,MAAM,GAAG,CAAC;QACZ,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,CAClB,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;QACrC,IAAA,aAAM,EAAC,KAAK,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,gBAAgB,EAAE,KAAK,IAAI,EAAE;QAC9B,MAAM,GAAG,GAAG,IAAI,QAAQ,EAAE,CAAC;QAC3B,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAC7B,MAAM,MAAM,GAAG,IAAA,cAAK,EAAC,IAAA,mBAAU,EAAC,QAAQ,CAAC,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;QAC/D,MAAM,QAAQ,GAAG,IAAA,YAAI,GAAE,CAAC;QACxB,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAE1B,MAAM,IAAA,aAAM,EAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACxE,IAAA,aAAM,EAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;IAC3D,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8CAA8C,EAAE,KAAK,IAAI,EAAE;QAC5D,MAAM,CAAC,GAAG,IAAA,YAAI,GAAE,CAAC,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC;QACxC,MAAM,QAAQ,GAAa,EAAE,CAAC;QAC9B,MAAM,MAAM,GAAG,IAAA,cAAK,EAAC,kBAAS,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;QACpD,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;YAC7B,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,MAAM,IAAA,aAAM,EAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACxE,IAAA,aAAM,EAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expect, use } from 'chai';\nimport { SinonFakeTimers, SinonStub, stub, useFakeTimers } from 'sinon';\nimport { ExponentialBackoff, IterableBackoff, noJitterGenerator } from './backoff/Backoff';\nimport { runInChild } from './common/util.test';\nimport { createAbortController } from './common/LocalAbortController';\nimport { handleAll, handleType, handleWhenResult, retry } from './Policy';\n\nuse(require('sinon-chai'));\nuse(require('chai-as-promised'));\n\nclass MyErrorA extends Error {\n  constructor() {\n    super('Error A');\n  }\n}\nclass MyErrorB extends Error {\n  constructor() {\n    super('Error B');\n  }\n}\n\ndescribe('RetryPolicy', () => {\n  it('types return data correctly in all cases', async () => {\n    const policy = retry(handleAll, { maxAttempts: 1 });\n    const multiply = (n: number) => n * 2;\n    multiply(await policy.execute(() => 42));\n    multiply(await policy.execute(async () => 42));\n  });\n\n  describe('setting backoffs', () => {\n    let s: SinonStub;\n    let clock: SinonFakeTimers;\n    let delays: number[];\n    beforeEach(() => {\n      clock = useFakeTimers();\n      delays = [];\n      s = stub().throws(new MyErrorA());\n    });\n\n    afterEach(() => clock.restore());\n\n    const makePolicy = (durations: number[]) => {\n      const p = retry(handleAll, {\n        maxAttempts: durations.length,\n        backoff: new IterableBackoff(durations),\n      });\n      p.onRetry(({ delay }) => {\n        delays.push(delay);\n        clock.tick(delay);\n      });\n      return p;\n    };\n\n    it('sets the retry delay', async () => {\n      await expect(makePolicy([50]).execute(s)).to.eventually.be.rejectedWith(MyErrorA);\n      expect(delays).to.deep.equal([50]);\n      expect(s).to.have.been.calledTwice;\n    });\n\n    it('sets the retry sequence', async () => {\n      await expect(makePolicy([10, 20, 20]).execute(s)).to.eventually.be.rejectedWith(MyErrorA);\n      expect(delays).to.deep.equal([10, 20, 20]);\n      expect(s).to.have.callCount(4);\n    });\n  });\n\n  it('retries all errors', async () => {\n    const s = stub().onFirstCall().throws(new MyErrorA()).onSecondCall().returns('ok');\n\n    expect(await retry(handleAll, {}).execute(s)).to.equal('ok');\n\n    expect(s).to.have.been.calledTwice;\n  });\n\n  it('filters error types', async () => {\n    const s = stub().onFirstCall().throws(new MyErrorA()).onSecondCall().throws(new MyErrorB());\n\n    await expect(\n      retry(handleType(MyErrorA), { maxAttempts: 5 }).execute(s),\n    ).to.eventually.be.rejectedWith(MyErrorB);\n\n    expect(s).to.have.been.calledTwice;\n  });\n\n  it('filters returns', async () => {\n    const s = stub().onFirstCall().returns(1).onSecondCall().returns(2);\n\n    expect(\n      await retry(\n        handleWhenResult(r => typeof r === 'number' && r < 2),\n        { maxAttempts: 5 },\n      ).execute(s),\n    ).to.equal(2);\n\n    expect(s).to.have.been.calledTwice;\n  });\n\n  it('permits specifying exponential backoffs', async () => {\n    const s = stub().returns(1);\n\n    expect(\n      await retry(\n        handleWhenResult(r => typeof r === 'number'),\n        { backoff: new ExponentialBackoff({ generator: noJitterGenerator }), maxAttempts: 2 },\n      ).execute(s),\n    ).to.equal(1);\n\n    expect(s).to.have.callCount(3);\n  });\n\n  it('bubbles returns when retry attempts exceeded', async () => {\n    const s = stub().returns(1);\n\n    expect(\n      await retry(\n        handleWhenResult(r => typeof r === 'number' && r < 2),\n        { maxAttempts: 5 },\n      ).execute(s),\n    ).to.equal(1);\n\n    expect(s).to.have.callCount(6);\n  });\n\n  it('bubbles errors when retry attempts exceeded', async () => {\n    const s = stub().throws(new MyErrorB());\n\n    await expect(retry(handleAll, { maxAttempts: 5 }).execute(s)).to.eventually.be.rejectedWith(\n      MyErrorB,\n    );\n\n    expect(s).to.have.callCount(6);\n  });\n\n  it('does not unref by default', async () => {\n    const output = await runInChild(`\n      c.retry(c.handleAll, { maxAttempts: 1 }).execute(() => {\n        console.log('attempt');\n        throw new Error('oh no!');\n      });\n    `);\n\n    expect(output).to.contain('oh no!');\n  });\n\n  it('unrefs as requested', async () => {\n    const output = await runInChild(`\n    c.retry(c.handleAll, { maxAttempts: 1 }).dangerouslyUnref().execute(() => {\n      console.log('attempt');\n      throw new Error('oh no!');\n    });\n    `);\n\n    expect(output).to.equal('attempt');\n  });\n\n  it('stops retries if cancellation is requested', async () => {\n    const parent = createAbortController();\n    const err = new Error();\n    let calls = 0;\n    await expect(\n      retry(handleAll, { maxAttempts: 3 }).execute(({ signal }) => {\n        calls++;\n        expect(signal.aborted).to.be.false;\n        parent.abort();\n        expect(signal.aborted).to.be.true;\n        throw err;\n      }, parent.signal),\n    ).to.eventually.be.rejectedWith(err);\n    expect(calls).to.equal(1);\n  });\n\n  it('fires onGiveUp', async () => {\n    const err = new MyErrorA();\n    const s = stub().throws(err);\n    const policy = retry(handleType(MyErrorA), { maxAttempts: 5 });\n    const onGiveUp = stub();\n    policy.onGiveUp(onGiveUp);\n\n    await expect(policy.execute(s)).to.eventually.be.rejectedWith(MyErrorA);\n    expect(onGiveUp).to.have.been.calledWith({ error: err });\n  });\n\n  it('provides the attempt to the onRetry callback', async () => {\n    const s = stub().throws(new MyErrorA());\n    const attempts: number[] = [];\n    const policy = retry(handleAll, { maxAttempts: 3 });\n    policy.onRetry(({ attempt }) => {\n      attempts.push(attempt);\n    });\n\n    await expect(policy.execute(s)).to.eventually.be.rejectedWith(MyErrorA);\n    expect(attempts).to.deep.equal([1, 2, 3]);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/TimeoutPolicy.d.ts b/node_modules/cockatiel/dist/TimeoutPolicy.d.ts
index a7f38a3..84e3094 100644
--- a/node_modules/cockatiel/dist/TimeoutPolicy.d.ts
+++ b/node_modules/cockatiel/dist/TimeoutPolicy.d.ts
@@ -1,6 +1,7 @@
 import { Event } from './common/Event';
 import { ExecuteWrapper } from './common/Executor';
 import { IPolicy } from './Policy';
+import { AbortSignal } from './common/LocalAbortController';
 export declare enum TimeoutStrategy {
     /**
      * Cooperative timeouts will simply revoke the inner cancellation token,
diff --git a/node_modules/cockatiel/dist/TimeoutPolicy.js.map b/node_modules/cockatiel/dist/TimeoutPolicy.js.map
index b856673..f4e7f6e 100644
--- a/node_modules/cockatiel/dist/TimeoutPolicy.js.map
+++ b/node_modules/cockatiel/dist/TimeoutPolicy.js.map
@@ -1 +1 @@
-{"version":3,"file":"TimeoutPolicy.js","sourceRoot":"","sources":["../src/TimeoutPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["import { deriveAbortController } from './common/abort';\nimport { Event, EventEmitter, onAbort } from './common/Event';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { TaskCancelledError } from './errors/TaskCancelledError';\nimport { IPolicy } from './Policy';\n\nexport enum TimeoutStrategy {\n  /**\n   * Cooperative timeouts will simply revoke the inner cancellation token,\n   * assuming the caller handles cancellation and throws or returns appropriately.\n   */\n  Cooperative = 'optimistic',\n\n  /**\n   * Aggressive cancellation immediately throws\n   */\n  Aggressive = 'aggressive',\n}\n\nexport interface ICancellationContext {\n  signal: AbortSignal;\n}\n\nexport interface ITimeoutOptions {\n  /** Strategy for timeouts, \"Cooperative\", or \"Accessive\" */\n  strategy: TimeoutStrategy;\n  /**\n   * Whether the AbortSignal should be aborted when the\n   * function returns. Defaults to true.\n   */\n  abortOnReturn?: boolean;\n}\n\nexport class TimeoutPolicy implements IPolicy<ICancellationContext> {\n  declare readonly _altReturn: never;\n\n  private readonly timeoutEmitter = new EventEmitter<void>();\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onTimeout = this.timeoutEmitter.addListener;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  constructor(\n    private readonly duration: number,\n    private readonly options: ITimeoutOptions,\n    private readonly executor = new ExecuteWrapper(),\n    private readonly unref = false,\n  ) {}\n\n  /**\n   * When timing out, a referenced timer is created. This means the Node.js\n   * event loop is kept active while we're waiting for the timeout, as long as\n   * the function hasn't returned. Calling this method on the timeout builder\n   * will unreference the timer, allowing the process to exit even if a\n   * timeout might still be happening.\n   */\n  public dangerouslyUnref() {\n    const t = new TimeoutPolicy(this.duration, this.options, this.executor, true);\n    return t;\n  }\n\n  /**\n   * Executes the given function.\n   * @param fn Function to execute. Takes in a nested cancellation token.\n   * @throws a {@link TaskCancelledError} if a timeout occurs\n   */\n  public async execute<T>(\n    fn: (context: ICancellationContext, signal: AbortSignal) => PromiseLike<T> | T,\n    signal?: AbortSignal,\n  ): Promise<T> {\n    const { ctrl: aborter, dispose: disposeAbort } = deriveAbortController(signal);\n    const timer = setTimeout(() => aborter.abort(), this.duration);\n    if (this.unref) {\n      timer.unref();\n    }\n\n    const context = { signal: aborter.signal };\n\n    const onceAborted = onAbort(aborter.signal);\n    const onCancelledListener = onceAborted.event(() => this.timeoutEmitter.emit());\n\n    try {\n      if (this.options.strategy === TimeoutStrategy.Cooperative) {\n        return returnOrThrow(await this.executor.invoke(fn, context, aborter.signal));\n      }\n\n      return await this.executor\n        .invoke(async () =>\n          Promise.race<T>([\n            Promise.resolve(fn(context, aborter.signal)),\n            Event.toPromise(onceAborted.event).then(() => {\n              throw new TaskCancelledError(`Operation timed out after ${this.duration}ms`);\n            }),\n          ]),\n        )\n        .then(returnOrThrow);\n    } finally {\n      onCancelledListener.dispose();\n      onceAborted.dispose();\n      if (this.options.abortOnReturn !== false) {\n        aborter.abort();\n      }\n      clearTimeout(timer);\n      disposeAbort();\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"TimeoutPolicy.js","sourceRoot":"","sources":["../src/TimeoutPolicy.ts"],"names":[],"mappings":";;;AAAA,0CAAuD;AACvD,0CAA8D;AAC9D,gDAAkE;AAClE,oEAAiE;AAIjE,IAAY,eAWX;AAXD,WAAY,eAAe;IACzB;;;OAGG;IACH,6CAA0B,CAAA;IAE1B;;OAEG;IACH,4CAAyB,CAAA;AAC3B,CAAC,EAXW,eAAe,+BAAf,eAAe,QAW1B;AAgBD,MAAa,aAAa;IAoBxB,YACmB,QAAgB,EAChB,OAAwB,EACxB,WAAW,IAAI,yBAAc,EAAE,EAC/B,QAAQ,KAAK;QAHb,aAAQ,GAAR,QAAQ,CAAQ;QAChB,YAAO,GAAP,OAAO,CAAiB;QACxB,aAAQ,GAAR,QAAQ,CAAuB;QAC/B,UAAK,GAAL,KAAK,CAAQ;QArBf,mBAAc,GAAG,IAAI,oBAAY,EAAQ,CAAC;QAE3D;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC;QAE5D;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IAOjD,CAAC;IAEJ;;;;;;OAMG;IACI,gBAAgB;QACrB,MAAM,CAAC,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC9E,OAAO,CAAC,CAAC;IACX,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,OAAO,CAClB,EAA8E,EAC9E,MAAoB;QAEpB,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,IAAA,6BAAqB,EAAC,MAAM,CAAC,CAAC;QAC/E,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC/D,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YACf,KAAK,CAAC,KAAK,EAAE,CAAC;QAChB,CAAC;QAED,MAAM,OAAO,GAAG,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC;QAE3C,MAAM,WAAW,GAAG,IAAA,eAAO,EAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC5C,MAAM,mBAAmB,GAAG,WAAW,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC;QAEhF,IAAI,CAAC;YACH,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,eAAe,CAAC,WAAW,EAAE,CAAC;gBAC1D,OAAO,IAAA,wBAAa,EAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;YAChF,CAAC;YAED,OAAO,MAAM,IAAI,CAAC,QAAQ;iBACvB,MAAM,CAAC,KAAK,IAAI,EAAE,CACjB,OAAO,CAAC,IAAI,CAAI;gBACd,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;gBAC5C,aAAK,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;oBAC3C,MAAM,IAAI,uCAAkB,CAAC,6BAA6B,IAAI,CAAC,QAAQ,IAAI,CAAC,CAAC;gBAC/E,CAAC,CAAC;aACH,CAAC,CACH;iBACA,IAAI,CAAC,wBAAa,CAAC,CAAC;QACzB,CAAC;gBAAS,CAAC;YACT,mBAAmB,CAAC,OAAO,EAAE,CAAC;YAC9B,WAAW,CAAC,OAAO,EAAE,CAAC;YACtB,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa,KAAK,KAAK,EAAE,CAAC;gBACzC,OAAO,CAAC,KAAK,EAAE,CAAC;YAClB,CAAC;YACD,YAAY,CAAC,KAAK,CAAC,CAAC;YACpB,YAAY,EAAE,CAAC;QACjB,CAAC;IACH,CAAC;CACF;AApFD,sCAoFC","sourcesContent":["import { deriveAbortController } from './common/abort';\nimport { Event, EventEmitter, onAbort } from './common/Event';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { TaskCancelledError } from './errors/TaskCancelledError';\nimport { IPolicy } from './Policy';\nimport { AbortSignal } from './common/LocalAbortController';\n\nexport enum TimeoutStrategy {\n  /**\n   * Cooperative timeouts will simply revoke the inner cancellation token,\n   * assuming the caller handles cancellation and throws or returns appropriately.\n   */\n  Cooperative = 'optimistic',\n\n  /**\n   * Aggressive cancellation immediately throws\n   */\n  Aggressive = 'aggressive',\n}\n\nexport interface ICancellationContext {\n  signal: AbortSignal;\n}\n\nexport interface ITimeoutOptions {\n  /** Strategy for timeouts, \"Cooperative\", or \"Accessive\" */\n  strategy: TimeoutStrategy;\n  /**\n   * Whether the AbortSignal should be aborted when the\n   * function returns. Defaults to true.\n   */\n  abortOnReturn?: boolean;\n}\n\nexport class TimeoutPolicy implements IPolicy<ICancellationContext> {\n  declare readonly _altReturn: never;\n\n  private readonly timeoutEmitter = new EventEmitter<void>();\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onTimeout = this.timeoutEmitter.addListener;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  constructor(\n    private readonly duration: number,\n    private readonly options: ITimeoutOptions,\n    private readonly executor = new ExecuteWrapper(),\n    private readonly unref = false,\n  ) {}\n\n  /**\n   * When timing out, a referenced timer is created. This means the Node.js\n   * event loop is kept active while we're waiting for the timeout, as long as\n   * the function hasn't returned. Calling this method on the timeout builder\n   * will unreference the timer, allowing the process to exit even if a\n   * timeout might still be happening.\n   */\n  public dangerouslyUnref() {\n    const t = new TimeoutPolicy(this.duration, this.options, this.executor, true);\n    return t;\n  }\n\n  /**\n   * Executes the given function.\n   * @param fn Function to execute. Takes in a nested cancellation token.\n   * @throws a {@link TaskCancelledError} if a timeout occurs\n   */\n  public async execute<T>(\n    fn: (context: ICancellationContext, signal: AbortSignal) => PromiseLike<T> | T,\n    signal?: AbortSignal,\n  ): Promise<T> {\n    const { ctrl: aborter, dispose: disposeAbort } = deriveAbortController(signal);\n    const timer = setTimeout(() => aborter.abort(), this.duration);\n    if (this.unref) {\n      timer.unref();\n    }\n\n    const context = { signal: aborter.signal };\n\n    const onceAborted = onAbort(aborter.signal);\n    const onCancelledListener = onceAborted.event(() => this.timeoutEmitter.emit());\n\n    try {\n      if (this.options.strategy === TimeoutStrategy.Cooperative) {\n        return returnOrThrow(await this.executor.invoke(fn, context, aborter.signal));\n      }\n\n      return await this.executor\n        .invoke(async () =>\n          Promise.race<T>([\n            Promise.resolve(fn(context, aborter.signal)),\n            Event.toPromise(onceAborted.event).then(() => {\n              throw new TaskCancelledError(`Operation timed out after ${this.duration}ms`);\n            }),\n          ]),\n        )\n        .then(returnOrThrow);\n    } finally {\n      onCancelledListener.dispose();\n      onceAborted.dispose();\n      if (this.options.abortOnReturn !== false) {\n        aborter.abort();\n      }\n      clearTimeout(timer);\n      disposeAbort();\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/TimeoutPolicy.test.d.ts b/node_modules/cockatiel/dist/TimeoutPolicy.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/TimeoutPolicy.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/TimeoutPolicy.test.js b/node_modules/cockatiel/dist/TimeoutPolicy.test.js
new file mode 100644
index 0000000..bc428fa
--- /dev/null
+++ b/node_modules/cockatiel/dist/TimeoutPolicy.test.js
@@ -0,0 +1,192 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const sinon_1 = require("sinon");
+const util_1 = require("util");
+const ExponentialBackoff_1 = require("./backoff/ExponentialBackoff");
+const util_test_1 = require("./common/util.test");
+const LocalAbortController_1 = require("./common/LocalAbortController");
+const TaskCancelledError_1 = require("./errors/TaskCancelledError");
+const Policy_1 = require("./Policy");
+const TimeoutPolicy_1 = require("./TimeoutPolicy");
+const delay = (0, util_1.promisify)(setTimeout);
+describe('TimeoutPolicy', () => {
+    it('works when no timeout happens', async () => {
+        const policy = (0, Policy_1.timeout)(1000, TimeoutPolicy_1.TimeoutStrategy.Cooperative);
+        (0, chai_1.expect)(await policy.execute(() => 42)).to.equal(42);
+    });
+    it('properly cooperatively cancels', async () => {
+        const policy = (0, Policy_1.timeout)(2, TimeoutPolicy_1.TimeoutStrategy.Cooperative);
+        (0, chai_1.expect)(await policy.execute(async ({ signal }) => {
+            (0, chai_1.expect)(signal.aborted).to.be.false;
+            await delay(3);
+            (0, chai_1.expect)(signal.aborted).to.be.true;
+            return 42;
+        })).to.equal(42);
+    });
+    it('properly aggressively cancels', async () => {
+        const policy = (0, Policy_1.timeout)(5, TimeoutPolicy_1.TimeoutStrategy.Aggressive);
+        let verified;
+        await (0, chai_1.expect)(policy.execute(async ({ signal }) => (verified = (async () => {
+            await delay(0);
+            (0, chai_1.expect)(signal.aborted).to.be.false;
+            await delay(5);
+            (0, chai_1.expect)(signal.aborted).to.be.true;
+        })()))).to.eventually.be.rejectedWith(TaskCancelledError_1.TaskCancelledError);
+        await verified;
+    });
+    it('does not unref by default', async () => {
+        // this would timeout if the timers were referenced
+        const output = await (0, util_test_1.runInChild)(`
+      c.timeout(100, 'aggressive')
+        .execute(() => new Promise(() => {}));
+    `);
+        (0, chai_1.expect)(output).to.contain('Operation timed out');
+    });
+    it('unrefs as requested', async () => {
+        // this would timeout if the timers were referenced
+        const output = await (0, util_test_1.runInChild)(`
+      c.timeout(60 * 1000, 'aggressive')
+        .dangerouslyUnref()
+        .execute(() => new Promise(() => {}));
+    `);
+        (0, chai_1.expect)(output).to.be.empty;
+    });
+    it('links parent cancellation token', async () => {
+        const parent = (0, LocalAbortController_1.createAbortController)();
+        await (0, Policy_1.timeout)(1000, TimeoutPolicy_1.TimeoutStrategy.Cooperative).execute((_, signal) => {
+            (0, chai_1.expect)(signal.aborted).to.be.false;
+            parent.abort();
+            (0, chai_1.expect)(signal.aborted).to.be.true;
+        }, parent.signal);
+    });
+    it('still has own timeout if given parent', async () => {
+        const parent = (0, LocalAbortController_1.createAbortController)();
+        await (0, Policy_1.timeout)(1, TimeoutPolicy_1.TimeoutStrategy.Cooperative).execute(async (_, signal) => {
+            (0, chai_1.expect)(signal.aborted).to.be.false;
+            await delay(3);
+            (0, chai_1.expect)(signal.aborted).to.be.true;
+        }, parent.signal);
+    });
+    it('aborts on return by default', async () => {
+        let signal;
+        await (0, Policy_1.timeout)(1, TimeoutPolicy_1.TimeoutStrategy.Cooperative).execute(async (_, s) => {
+            signal = s;
+        });
+        (0, chai_1.expect)(signal.aborted).to.be.true;
+    });
+    it('does not aborts on return if requested', async () => {
+        let signal;
+        await (0, Policy_1.timeout)(1, { strategy: TimeoutPolicy_1.TimeoutStrategy.Aggressive, abortOnReturn: false }).execute(async (_, s) => {
+            signal = s;
+        });
+        (0, chai_1.expect)(signal.aborted).to.be.false;
+    });
+    describe('events', () => {
+        let onSuccess;
+        let onFailure;
+        let onTimeout;
+        let agg;
+        let coop;
+        beforeEach(() => {
+            onSuccess = (0, sinon_1.stub)();
+            onFailure = (0, sinon_1.stub)();
+            onTimeout = (0, sinon_1.stub)();
+            coop = (0, Policy_1.timeout)(2, TimeoutPolicy_1.TimeoutStrategy.Cooperative);
+            agg = (0, Policy_1.timeout)(2, TimeoutPolicy_1.TimeoutStrategy.Aggressive);
+            for (const p of [coop, agg]) {
+                p.onFailure(onFailure);
+                p.onSuccess(onSuccess);
+                p.onTimeout(onTimeout);
+            }
+        });
+        it('emits a success event (cooperative)', async () => {
+            await coop.execute(() => 42);
+            await delay(3);
+            (0, chai_1.expect)(onSuccess).to.have.been.called;
+            (0, chai_1.expect)(onFailure).to.not.have.been.called;
+            (0, chai_1.expect)(onTimeout).to.not.have.been.called;
+        });
+        it('emits a success event (aggressive)', async () => {
+            await agg.execute(() => 42);
+            await delay(3);
+            (0, chai_1.expect)(onSuccess).to.have.been.called;
+            (0, chai_1.expect)(onFailure).to.not.have.been.called;
+            (0, chai_1.expect)(onTimeout).to.not.have.been.called;
+        });
+        it('emits a timeout event (cooperative)', async () => {
+            coop.onTimeout(onTimeout);
+            await coop.execute(() => delay(3));
+            (0, chai_1.expect)(onSuccess).to.have.been.called; // still returned a good value
+            (0, chai_1.expect)(onTimeout).to.have.been.called;
+            (0, chai_1.expect)(onFailure).to.not.have.been.called;
+        });
+        it('emits a timeout event (aggressive)', async () => {
+            await (0, chai_1.expect)(agg.execute(() => delay(3))).to.be.rejectedWith(TaskCancelledError_1.TaskCancelledError);
+            (0, chai_1.expect)(onSuccess).to.not.have.been.called;
+            (0, chai_1.expect)(onTimeout).to.have.been.called;
+            (0, chai_1.expect)(onFailure).to.have.been.called;
+        });
+        it('emits a failure event (cooperative)', async () => {
+            await (0, chai_1.expect)(coop.execute(() => {
+                throw new Error('oh no!');
+            })).to.be.rejected;
+            await delay(3);
+            (0, chai_1.expect)(onSuccess).to.not.have.been.called;
+            (0, chai_1.expect)(onTimeout).to.not.have.been.called;
+            (0, chai_1.expect)(onFailure).to.have.been.called;
+        });
+        it('emits a failure event (aggressive)', async () => {
+            await (0, chai_1.expect)(agg.execute(() => {
+                throw new Error('oh no!');
+            })).to.be.rejected;
+            await delay(3);
+            (0, chai_1.expect)(onSuccess).to.not.have.been.called;
+            (0, chai_1.expect)(onTimeout).to.not.have.been.called;
+            (0, chai_1.expect)(onFailure).to.have.been.called;
+        });
+    });
+    it('does not leak abort listeners (#81)', async () => {
+        const fail = (times) => {
+            let c = times;
+            return async () => {
+                if (c-- > 0) {
+                    throw Error('fail');
+                }
+            };
+        };
+        const timeoutPolicy = (0, Policy_1.timeout)(1, TimeoutPolicy_1.TimeoutStrategy.Cooperative);
+        const retryPolicy = (0, Policy_1.retry)(Policy_1.handleAll, {
+            backoff: new ExponentialBackoff_1.ExponentialBackoff({
+                initialDelay: 1,
+                exponent: 2,
+                maxDelay: 1,
+            }),
+        });
+        const policy = (0, Policy_1.wrap)(retryPolicy, timeoutPolicy);
+        const ac = (0, LocalAbortController_1.createAbortController)();
+        let listenerCount = 0;
+        const sig = new Proxy(ac.signal, {
+            get: (signal, key, receiver) => {
+                const val = Reflect.get(signal, key, receiver);
+                if (key === 'addEventListener') {
+                    return (...args) => {
+                        listenerCount++;
+                        return Reflect.apply(val, signal, args);
+                    };
+                }
+                if (key === 'removeEventListener') {
+                    return (...args) => {
+                        listenerCount--;
+                        return Reflect.apply(val, signal, args);
+                    };
+                }
+                return val;
+            },
+        });
+        const func = fail(15);
+        await policy.execute(() => func(), sig);
+        (0, chai_1.expect)(listenerCount).to.eq(0);
+    });
+});
+//# sourceMappingURL=TimeoutPolicy.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/TimeoutPolicy.test.js.map b/node_modules/cockatiel/dist/TimeoutPolicy.test.js.map
new file mode 100644
index 0000000..b5535db
--- /dev/null
+++ b/node_modules/cockatiel/dist/TimeoutPolicy.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"TimeoutPolicy.test.js","sourceRoot":"","sources":["../src/TimeoutPolicy.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from 'chai';\nimport { SinonStub, stub } from 'sinon';\nimport { promisify } from 'util';\nimport { ExponentialBackoff } from './backoff/ExponentialBackoff';\nimport { runInChild } from './common/util.test';\nimport { createAbortController } from './common/LocalAbortController';\nimport { TaskCancelledError } from './errors/TaskCancelledError';\nimport { handleAll, retry, timeout, wrap } from './Policy';\nimport { TimeoutPolicy, TimeoutStrategy } from './TimeoutPolicy';\n\nconst delay = promisify(setTimeout);\n\ndescribe('TimeoutPolicy', () => {\n  it('works when no timeout happens', async () => {\n    const policy = timeout(1000, TimeoutStrategy.Cooperative);\n    expect(await policy.execute(() => 42)).to.equal(42);\n  });\n\n  it('properly cooperatively cancels', async () => {\n    const policy = timeout(2, TimeoutStrategy.Cooperative);\n    expect(\n      await policy.execute(async ({ signal }) => {\n        expect(signal.aborted).to.be.false;\n        await delay(3);\n        expect(signal.aborted).to.be.true;\n        return 42;\n      }),\n    ).to.equal(42);\n  });\n\n  it('properly aggressively cancels', async () => {\n    const policy = timeout(5, TimeoutStrategy.Aggressive);\n    let verified: Promise<void>;\n    await expect(\n      policy.execute(\n        async ({ signal }) =>\n          (verified = (async () => {\n            await delay(0);\n            expect(signal.aborted).to.be.false;\n            await delay(5);\n            expect(signal.aborted).to.be.true;\n          })()),\n      ),\n    ).to.eventually.be.rejectedWith(TaskCancelledError);\n\n    await verified!;\n  });\n\n  it('does not unref by default', async () => {\n    // this would timeout if the timers were referenced\n    const output = await runInChild(`\n      c.timeout(100, 'aggressive')\n        .execute(() => new Promise(() => {}));\n    `);\n\n    expect(output).to.contain('Operation timed out');\n  });\n\n  it('unrefs as requested', async () => {\n    // this would timeout if the timers were referenced\n    const output = await runInChild(`\n      c.timeout(60 * 1000, 'aggressive')\n        .dangerouslyUnref()\n        .execute(() => new Promise(() => {}));\n    `);\n\n    expect(output).to.be.empty;\n  });\n\n  it('links parent cancellation token', async () => {\n    const parent = createAbortController();\n    await timeout(1000, TimeoutStrategy.Cooperative).execute((_, signal) => {\n      expect(signal.aborted).to.be.false;\n      parent.abort();\n      expect(signal.aborted).to.be.true;\n    }, parent.signal);\n  });\n\n  it('still has own timeout if given parent', async () => {\n    const parent = createAbortController();\n    await timeout(1, TimeoutStrategy.Cooperative).execute(async (_, signal) => {\n      expect(signal.aborted).to.be.false;\n      await delay(3);\n      expect(signal.aborted).to.be.true;\n    }, parent.signal);\n  });\n\n  it('aborts on return by default', async () => {\n    let signal: AbortSignal;\n    await timeout(1, TimeoutStrategy.Cooperative).execute(async (_, s) => {\n      signal = s;\n    });\n    expect(signal!.aborted).to.be.true;\n  });\n\n  it('does not aborts on return if requested', async () => {\n    let signal: AbortSignal;\n    await timeout(1, { strategy: TimeoutStrategy.Aggressive, abortOnReturn: false }).execute(\n      async (_, s) => {\n        signal = s;\n      },\n    );\n    expect(signal!.aborted).to.be.false;\n  });\n\n  describe('events', () => {\n    let onSuccess: SinonStub;\n    let onFailure: SinonStub;\n    let onTimeout: SinonStub;\n    let agg: TimeoutPolicy;\n    let coop: TimeoutPolicy;\n\n    beforeEach(() => {\n      onSuccess = stub();\n      onFailure = stub();\n      onTimeout = stub();\n      coop = timeout(2, TimeoutStrategy.Cooperative);\n      agg = timeout(2, TimeoutStrategy.Aggressive);\n      for (const p of [coop, agg]) {\n        p.onFailure(onFailure);\n        p.onSuccess(onSuccess);\n        p.onTimeout(onTimeout);\n      }\n    });\n\n    it('emits a success event (cooperative)', async () => {\n      await coop.execute(() => 42);\n      await delay(3);\n      expect(onSuccess).to.have.been.called;\n      expect(onFailure).to.not.have.been.called;\n      expect(onTimeout).to.not.have.been.called;\n    });\n\n    it('emits a success event (aggressive)', async () => {\n      await agg.execute(() => 42);\n      await delay(3);\n      expect(onSuccess).to.have.been.called;\n      expect(onFailure).to.not.have.been.called;\n      expect(onTimeout).to.not.have.been.called;\n    });\n\n    it('emits a timeout event (cooperative)', async () => {\n      coop.onTimeout(onTimeout);\n      await coop.execute(() => delay(3));\n      expect(onSuccess).to.have.been.called; // still returned a good value\n      expect(onTimeout).to.have.been.called;\n      expect(onFailure).to.not.have.been.called;\n    });\n\n    it('emits a timeout event (aggressive)', async () => {\n      await expect(agg.execute(() => delay(3))).to.be.rejectedWith(TaskCancelledError);\n      expect(onSuccess).to.not.have.been.called;\n      expect(onTimeout).to.have.been.called;\n      expect(onFailure).to.have.been.called;\n    });\n\n    it('emits a failure event (cooperative)', async () => {\n      await expect(\n        coop.execute(() => {\n          throw new Error('oh no!');\n        }),\n      ).to.be.rejected;\n      await delay(3);\n\n      expect(onSuccess).to.not.have.been.called;\n      expect(onTimeout).to.not.have.been.called;\n      expect(onFailure).to.have.been.called;\n    });\n\n    it('emits a failure event (aggressive)', async () => {\n      await expect(\n        agg.execute(() => {\n          throw new Error('oh no!');\n        }),\n      ).to.be.rejected;\n      await delay(3);\n\n      expect(onSuccess).to.not.have.been.called;\n      expect(onTimeout).to.not.have.been.called;\n      expect(onFailure).to.have.been.called;\n    });\n  });\n\n  it('does not leak abort listeners (#81)', async () => {\n    const fail = (times: number) => {\n      let c = times;\n      return async () => {\n        if (c-- > 0) {\n          throw Error('fail');\n        }\n      };\n    };\n\n    const timeoutPolicy = timeout(1, TimeoutStrategy.Cooperative);\n    const retryPolicy = retry(handleAll, {\n      backoff: new ExponentialBackoff({\n        initialDelay: 1,\n        exponent: 2,\n        maxDelay: 1,\n      }),\n    });\n    const policy = wrap(retryPolicy, timeoutPolicy);\n\n    const ac = createAbortController();\n\n    let listenerCount = 0;\n\n    const sig = new Proxy(ac.signal, {\n      get: (signal, key, receiver) => {\n        const val = Reflect.get(signal, key, receiver);\n        if (key === 'addEventListener') {\n          return (...args: any[]) => {\n            listenerCount++;\n            return Reflect.apply(val, signal, args);\n          };\n        }\n        if (key === 'removeEventListener') {\n          return (...args: any[]) => {\n            listenerCount--;\n            return Reflect.apply(val, signal, args);\n          };\n        }\n        return val;\n      },\n    });\n\n    const func = fail(15);\n\n    await policy.execute(() => func(), sig);\n\n    expect(listenerCount).to.eq(0);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/Backoff.test.d.ts b/node_modules/cockatiel/dist/backoff/Backoff.test.d.ts
new file mode 100644
index 0000000..491673a
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/Backoff.test.d.ts
@@ -0,0 +1,2 @@
+import { IBackoffFactory } from './Backoff';
+export declare const expectDurations: <T>(backoffFactory: IBackoffFactory<T> | undefined, expected: ReadonlyArray<number | undefined>, context?: T) => void;
diff --git a/node_modules/cockatiel/dist/backoff/Backoff.test.js b/node_modules/cockatiel/dist/backoff/Backoff.test.js
new file mode 100644
index 0000000..f7cc1ba
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/Backoff.test.js
@@ -0,0 +1,19 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.expectDurations = void 0;
+const chai_1 = require("chai");
+const expectDurations = (backoffFactory, expected, context) => {
+    const actual = [];
+    let backoff = backoffFactory?.next(context);
+    for (let i = 0; i < expected.length; i++) {
+        if (!backoff) {
+            actual.push(undefined);
+            continue;
+        }
+        actual.push(backoff?.duration);
+        backoff = backoff.next(context);
+    }
+    (0, chai_1.expect)(actual).to.deep.equal(expected);
+};
+exports.expectDurations = expectDurations;
+//# sourceMappingURL=Backoff.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/Backoff.test.js.map b/node_modules/cockatiel/dist/backoff/Backoff.test.js.map
new file mode 100644
index 0000000..6222ac5
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/Backoff.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Backoff.test.js","sourceRoot":"","sources":["../../src/backoff/Backoff.test.ts"],"names":[],"mappings":";;;AAAA,+BAA8B;AAGvB,MAAM,eAAe,GAAG,CAC7B,cAA8C,EAC9C,QAA2C,EAC3C,OAAW,EACX,EAAE;IACF,MAAM,MAAM,GAA8B,EAAE,CAAC;IAC7C,IAAI,OAAO,GAAG,cAAc,EAAE,IAAI,CAAC,OAAY,CAAC,CAAC;IACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACzC,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACvB,SAAS;QACX,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC/B,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,OAAY,CAAC,CAAC;IACvC,CAAC;IAED,IAAA,aAAM,EAAC,MAAM,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AACzC,CAAC,CAAC;AAlBW,QAAA,eAAe,mBAkB1B","sourcesContent":["import { expect } from 'chai';\nimport { IBackoffFactory } from './Backoff';\n\nexport const expectDurations = <T>(\n  backoffFactory: IBackoffFactory<T> | undefined,\n  expected: ReadonlyArray<number | undefined>,\n  context?: T,\n) => {\n  const actual: Array<number | undefined> = [];\n  let backoff = backoffFactory?.next(context as T);\n  for (let i = 0; i < expected.length; i++) {\n    if (!backoff) {\n      actual.push(undefined);\n      continue;\n    }\n\n    actual.push(backoff?.duration);\n    backoff = backoff.next(context as T);\n  }\n\n  expect(actual).to.deep.equal(expected);\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.d.ts b/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.js b/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.js
new file mode 100644
index 0000000..b37a990
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.js
@@ -0,0 +1,10 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const Backoff_test_1 = require("./Backoff.test");
+const ConstantBackoff_1 = require("./ConstantBackoff");
+describe('ConstantBackoff', () => {
+    it('returns its duration', () => {
+        (0, Backoff_test_1.expectDurations)(new ConstantBackoff_1.ConstantBackoff(42), [42, 42, 42]);
+    });
+});
+//# sourceMappingURL=ConstantBackoff.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.js.map b/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.js.map
new file mode 100644
index 0000000..d7b9b80
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ConstantBackoff.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ConstantBackoff.test.js","sourceRoot":"","sources":["../../src/backoff/ConstantBackoff.test.ts"],"names":[],"mappings":";;AAAA,iDAAiD;AACjD,uDAAoD;AAEpD,QAAQ,CAAC,iBAAiB,EAAE,GAAG,EAAE;IAC/B,EAAE,CAAC,sBAAsB,EAAE,GAAG,EAAE;QAC9B,IAAA,8BAAe,EAAC,IAAI,iCAAe,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;IACzD,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expectDurations } from './Backoff.test';\nimport { ConstantBackoff } from './ConstantBackoff';\n\ndescribe('ConstantBackoff', () => {\n  it('returns its duration', () => {\n    expectDurations(new ConstantBackoff(42), [42, 42, 42]);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.d.ts b/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.js b/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.js
new file mode 100644
index 0000000..64cff34
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.js
@@ -0,0 +1,19 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const Backoff_test_1 = require("./Backoff.test");
+const DelegateBackoff_1 = require("./DelegateBackoff");
+describe('DelegateBackoff', () => {
+    it('passes through the context and sets next delay', () => {
+        const b = new DelegateBackoff_1.DelegateBackoff(v => v * 2);
+        (0, chai_1.expect)(b.next(4).duration).to.equal(8);
+    });
+    it('captures and sets delegate state', () => {
+        const b = new DelegateBackoff_1.DelegateBackoff((_, state = 3) => {
+            const n = state * state;
+            return { delay: n, state: n };
+        });
+        (0, Backoff_test_1.expectDurations)(b, [9, 81, 6561, 43046721]);
+    });
+});
+//# sourceMappingURL=DelegateBackoff.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.js.map b/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.js.map
new file mode 100644
index 0000000..2492b52
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/DelegateBackoff.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DelegateBackoff.test.js","sourceRoot":"","sources":["../../src/backoff/DelegateBackoff.test.ts"],"names":[],"mappings":";;AAAA,+BAA8B;AAC9B,iDAAiD;AACjD,uDAAoD;AAEpD,QAAQ,CAAC,iBAAiB,EAAE,GAAG,EAAE;IAC/B,EAAE,CAAC,gDAAgD,EAAE,GAAG,EAAE;QACxD,MAAM,CAAC,GAAG,IAAI,iCAAe,CAAS,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAClD,IAAA,aAAM,EAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1C,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,kCAAkC,EAAE,GAAG,EAAE;QAC1C,MAAM,CAAC,GAAG,IAAI,iCAAe,CAAC,CAAC,CAAC,EAAE,QAAgB,CAAC,EAAE,EAAE;YACrD,MAAM,CAAC,GAAG,KAAK,GAAG,KAAK,CAAC;YACxB,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;QAChC,CAAC,CAAC,CAAC;QAEH,IAAA,8BAAe,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;IAC9C,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expect } from 'chai';\nimport { expectDurations } from './Backoff.test';\nimport { DelegateBackoff } from './DelegateBackoff';\n\ndescribe('DelegateBackoff', () => {\n  it('passes through the context and sets next delay', () => {\n    const b = new DelegateBackoff<number>(v => v * 2);\n    expect(b.next(4)!.duration).to.equal(8);\n  });\n\n  it('captures and sets delegate state', () => {\n    const b = new DelegateBackoff((_, state: number = 3) => {\n      const n = state * state;\n      return { delay: n, state: n };\n    });\n\n    expectDurations(b, [9, 81, 6561, 43046721]);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.d.ts b/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.js b/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.js
new file mode 100644
index 0000000..e9aa110
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.js
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const Backoff_test_1 = require("./Backoff.test");
+const ExponentialBackoff_1 = require("./ExponentialBackoff");
+const ExponentialBackoffGenerators_1 = require("./ExponentialBackoffGenerators");
+describe('ExponentialBackoff', () => {
+    it('works', () => {
+        const b = new ExponentialBackoff_1.ExponentialBackoff({ generator: ExponentialBackoffGenerators_1.noJitterGenerator });
+        (0, Backoff_test_1.expectDurations)(b, [128, 256, 512, 1024, 2048, 4096, 8192, 16384, 30000, 30000, 30000]);
+    });
+});
+//# sourceMappingURL=ExponentialBackoff.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.js.map b/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.js.map
new file mode 100644
index 0000000..4d26a46
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ExponentialBackoff.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ExponentialBackoff.test.js","sourceRoot":"","sources":["../../src/backoff/ExponentialBackoff.test.ts"],"names":[],"mappings":";;AAAA,iDAAiD;AACjD,6DAA0D;AAC1D,iFAAmE;AAEnE,QAAQ,CAAC,oBAAoB,EAAE,GAAG,EAAE;IAClC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;QACf,MAAM,CAAC,GAAG,IAAI,uCAAkB,CAAC,EAAE,SAAS,EAAE,gDAAiB,EAAE,CAAC,CAAC;QACnE,IAAA,8BAAe,EAAC,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IAC1F,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expectDurations } from './Backoff.test';\nimport { ExponentialBackoff } from './ExponentialBackoff';\nimport { noJitterGenerator } from './ExponentialBackoffGenerators';\n\ndescribe('ExponentialBackoff', () => {\n  it('works', () => {\n    const b = new ExponentialBackoff({ generator: noJitterGenerator });\n    expectDurations(b, [128, 256, 512, 1024, 2048, 4096, 8192, 16384, 30000, 30000, 30000]);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.d.ts b/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.js b/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.js
new file mode 100644
index 0000000..a84bd33
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.js
@@ -0,0 +1,47 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const ExponentialBackoffGenerators_1 = require("./ExponentialBackoffGenerators");
+describe('ExponentialBackoff Generators', () => {
+    const generators = [
+        { name: 'noJitterGenerator', generator: ExponentialBackoffGenerators_1.noJitterGenerator },
+        { name: 'fullJitterGenerator', generator: ExponentialBackoffGenerators_1.fullJitterGenerator },
+        { name: 'halfJitterGenerator', generator: ExponentialBackoffGenerators_1.halfJitterGenerator },
+        { name: 'decorrelatedJitterGenerator', generator: ExponentialBackoffGenerators_1.decorrelatedJitterGenerator },
+    ];
+    for (const { name, generator } of generators) {
+        it(`${name} is sane`, () => {
+            const options = {
+                generator,
+                maxDelay: 30000,
+                exponent: 2,
+                initialDelay: 128,
+            };
+            for (let i = 0; i < 10; i++) {
+                let state;
+                for (let k = 1; k < 100; k++) {
+                    const [delay, nextState] = generator(state, options);
+                    (0, chai_1.expect)(delay).to.be.gte(0);
+                    (0, chai_1.expect)(delay).to.be.lte(Math.min(30000, options.initialDelay * 2 ** k));
+                    state = nextState;
+                }
+            }
+        });
+    }
+    it('fixes issue #86', () => {
+        const options = {
+            generator: ExponentialBackoffGenerators_1.decorrelatedJitterGenerator,
+            maxDelay: 15 * 60_000,
+            exponent: 2,
+            initialDelay: 45_000,
+        };
+        let state;
+        for (let k = 1; k < 3000; k++) {
+            const [delay, nextState] = (0, ExponentialBackoffGenerators_1.decorrelatedJitterGenerator)(state, options);
+            (0, chai_1.expect)(delay).to.not.be.NaN;
+            (0, chai_1.expect)(delay).to.be.gte(0);
+            state = nextState;
+        }
+    });
+});
+//# sourceMappingURL=ExponentialBackoffGenerators.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.js.map b/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.js.map
new file mode 100644
index 0000000..9a627f5
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ExponentialBackoffGenerators.test.js","sourceRoot":"","sources":["../../src/backoff/ExponentialBackoffGenerators.test.ts"],"names":[],"mappings":";;AAAA,+BAA8B;AAE9B,iFAKwC;AAExC,QAAQ,CAAC,+BAA+B,EAAE,GAAG,EAAE;IAC7C,MAAM,UAAU,GAAG;QACjB,EAAE,IAAI,EAAE,mBAAmB,EAAE,SAAS,EAAE,gDAAiB,EAAE;QAC3D,EAAE,IAAI,EAAE,qBAAqB,EAAE,SAAS,EAAE,kDAAmB,EAAE;QAC/D,EAAE,IAAI,EAAE,qBAAqB,EAAE,SAAS,EAAE,kDAAmB,EAAE;QAC/D,EAAE,IAAI,EAAE,6BAA6B,EAAE,SAAS,EAAE,0DAA2B,EAAE;KAChF,CAAC;IAEF,KAAK,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,UAAU,EAAE,CAAC;QAC7C,EAAE,CAAC,GAAG,IAAI,UAAU,EAAE,GAAG,EAAE;YACzB,MAAM,OAAO,GAAoC;gBAC/C,SAAS;gBACT,QAAQ,EAAE,KAAK;gBACf,QAAQ,EAAE,CAAC;gBACX,YAAY,EAAE,GAAG;aAClB,CAAC;YAEF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC5B,IAAI,KAAU,CAAC;gBACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC7B,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;oBACrD,IAAA,aAAM,EAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC3B,IAAA,aAAM,EAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,YAAY,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACxE,KAAK,GAAG,SAAS,CAAC;gBACpB,CAAC;YACH,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,EAAE,CAAC,iBAAiB,EAAE,GAAG,EAAE;QACzB,MAAM,OAAO,GAAoC;YAC/C,SAAS,EAAE,0DAA2B;YACtC,QAAQ,EAAE,EAAE,GAAG,MAAM;YACrB,QAAQ,EAAE,CAAC;YACX,YAAY,EAAE,MAAM;SACrB,CAAC;QAEF,IAAI,KAAU,CAAC;QACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;YAC9B,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAA,0DAA2B,EAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACvE,IAAA,aAAM,EAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC;YAC5B,IAAA,aAAM,EAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC3B,KAAK,GAAG,SAAS,CAAC;QACpB,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expect } from 'chai';\nimport { IExponentialBackoffOptions } from './ExponentialBackoff';\nimport {\n  decorrelatedJitterGenerator,\n  fullJitterGenerator,\n  halfJitterGenerator,\n  noJitterGenerator,\n} from './ExponentialBackoffGenerators';\n\ndescribe('ExponentialBackoff Generators', () => {\n  const generators = [\n    { name: 'noJitterGenerator', generator: noJitterGenerator },\n    { name: 'fullJitterGenerator', generator: fullJitterGenerator },\n    { name: 'halfJitterGenerator', generator: halfJitterGenerator },\n    { name: 'decorrelatedJitterGenerator', generator: decorrelatedJitterGenerator },\n  ];\n\n  for (const { name, generator } of generators) {\n    it(`${name} is sane`, () => {\n      const options: IExponentialBackoffOptions<any> = {\n        generator,\n        maxDelay: 30000,\n        exponent: 2,\n        initialDelay: 128,\n      };\n\n      for (let i = 0; i < 10; i++) {\n        let state: any;\n        for (let k = 1; k < 100; k++) {\n          const [delay, nextState] = generator(state, options);\n          expect(delay).to.be.gte(0);\n          expect(delay).to.be.lte(Math.min(30000, options.initialDelay * 2 ** k));\n          state = nextState;\n        }\n      }\n    });\n  }\n\n  it('fixes issue #86', () => {\n    const options: IExponentialBackoffOptions<any> = {\n      generator: decorrelatedJitterGenerator,\n      maxDelay: 15 * 60_000,\n      exponent: 2,\n      initialDelay: 45_000,\n    };\n\n    let state: any;\n    for (let k = 1; k < 3000; k++) {\n      const [delay, nextState] = decorrelatedJitterGenerator(state, options);\n      expect(delay).to.not.be.NaN;\n      expect(delay).to.be.gte(0);\n      state = nextState;\n    }\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/IterableBackoff.test.d.ts b/node_modules/cockatiel/dist/backoff/IterableBackoff.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/IterableBackoff.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/backoff/IterableBackoff.test.js b/node_modules/cockatiel/dist/backoff/IterableBackoff.test.js
new file mode 100644
index 0000000..7ed3553
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/IterableBackoff.test.js
@@ -0,0 +1,11 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const Backoff_test_1 = require("./Backoff.test");
+const IterableBackoff_1 = require("./IterableBackoff");
+describe('IterableBackoff', () => {
+    it('works', () => {
+        const b = new IterableBackoff_1.IterableBackoff([3, 6, 9]);
+        (0, Backoff_test_1.expectDurations)(b, [3, 6, 9, 9]);
+    });
+});
+//# sourceMappingURL=IterableBackoff.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/backoff/IterableBackoff.test.js.map b/node_modules/cockatiel/dist/backoff/IterableBackoff.test.js.map
new file mode 100644
index 0000000..dfbf080
--- /dev/null
+++ b/node_modules/cockatiel/dist/backoff/IterableBackoff.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"IterableBackoff.test.js","sourceRoot":"","sources":["../../src/backoff/IterableBackoff.test.ts"],"names":[],"mappings":";;AAAA,iDAAiD;AACjD,uDAAoD;AAEpD,QAAQ,CAAC,iBAAiB,EAAE,GAAG,EAAE;IAC/B,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;QACf,MAAM,CAAC,GAAG,IAAI,iCAAe,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACzC,IAAA,8BAAe,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACnC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expectDurations } from './Backoff.test';\nimport { IterableBackoff } from './IterableBackoff';\n\ndescribe('IterableBackoff', () => {\n  it('works', () => {\n    const b = new IterableBackoff([3, 6, 9]);\n    expectDurations(b, [3, 6, 9, 9]);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/Breaker.js.map b/node_modules/cockatiel/dist/breaker/Breaker.js.map
index 4fd4a79..883264e 100644
--- a/node_modules/cockatiel/dist/breaker/Breaker.js.map
+++ b/node_modules/cockatiel/dist/breaker/Breaker.js.map
@@ -1 +1 @@
-{"version":3,"file":"Breaker.js","sourceRoot":"","sources":["../../src/breaker/Breaker.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAuBA,uDAAqC;AACrC,iDAA+B;AAC/B,oDAAkC","sourcesContent":["import { CircuitState } from '../CircuitBreakerPolicy';\n\n/**\n * The breaker determines when the circuit breaker should open.\n */\nexport interface IBreaker {\n  /**\n   * Gets or sets the internal state of the breaker. Used for serialization\n   * with {@link CircuitBreaker.toJSON}.\n   */\n  state: unknown;\n\n  /**\n   * Called when a call succeeds.\n   */\n  success(state: CircuitState): void;\n\n  /**\n   * Called when a call fails. Returns true if the circuit should open.\n   */\n  failure(state: CircuitState): boolean;\n}\n\nexport * from './ConsecutiveBreaker';\nexport * from './CountBreaker';\nexport * from './SamplingBreaker';\n\n"]}
\ No newline at end of file
+{"version":3,"file":"Breaker.js","sourceRoot":"","sources":["../../src/breaker/Breaker.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAuBA,uDAAqC;AACrC,iDAA+B;AAC/B,oDAAkC","sourcesContent":["import { CircuitState } from '../CircuitBreakerPolicy';\n\n/**\n * The breaker determines when the circuit breaker should open.\n */\nexport interface IBreaker {\n  /**\n   * Gets or sets the internal state of the breaker. Used for serialization\n   * with {@link CircuitBreaker.toJSON}.\n   */\n  state: unknown;\n\n  /**\n   * Called when a call succeeds.\n   */\n  success(state: CircuitState): void;\n\n  /**\n   * Called when a call fails. Returns true if the circuit should open.\n   */\n  failure(state: CircuitState): boolean;\n}\n\nexport * from './ConsecutiveBreaker';\nexport * from './CountBreaker';\nexport * from './SamplingBreaker';\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.d.ts b/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.js b/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.js
new file mode 100644
index 0000000..e016dc1
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.js
@@ -0,0 +1,31 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const ConsecutiveBreaker_1 = require("./ConsecutiveBreaker");
+describe('ConsecutiveBreaker', () => {
+    it('works', () => {
+        const c = new ConsecutiveBreaker_1.ConsecutiveBreaker(3);
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.true;
+        (0, chai_1.expect)(c.failure()).to.be.true;
+        c.success();
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.true;
+    });
+    it('serializes and deserializes', () => {
+        const c = new ConsecutiveBreaker_1.ConsecutiveBreaker(3);
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.true;
+        const c2 = new ConsecutiveBreaker_1.ConsecutiveBreaker(3);
+        c2.state = c.state;
+        (0, chai_1.expect)(c.failure()).to.be.true;
+        c.success();
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.false;
+        (0, chai_1.expect)(c.failure()).to.be.true;
+    });
+});
+//# sourceMappingURL=ConsecutiveBreaker.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.js.map b/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.js.map
new file mode 100644
index 0000000..c1da062
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ConsecutiveBreaker.test.js","sourceRoot":"","sources":["../../src/breaker/ConsecutiveBreaker.test.ts"],"names":[],"mappings":";;AAAA,+BAA8B;AAC9B,6DAA0D;AAE1D,QAAQ,CAAC,oBAAoB,EAAE,GAAG,EAAE;IAClC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;QACf,MAAM,CAAC,GAAG,IAAI,uCAAkB,CAAC,CAAC,CAAC,CAAC;QACpC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;QAC/B,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;QAE/B,CAAC,CAAC,OAAO,EAAE,CAAC;QACZ,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6BAA6B,EAAE,GAAG,EAAE;QACrC,MAAM,CAAC,GAAG,IAAI,uCAAkB,CAAC,CAAC,CAAC,CAAC;QACpC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;QAE/B,MAAM,EAAE,GAAG,IAAI,uCAAkB,CAAC,CAAC,CAAC,CAAC;QACrC,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;QACnB,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;QAE/B,CAAC,CAAC,OAAO,EAAE,CAAC;QACZ,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QAChC,IAAA,aAAM,EAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;IACjC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expect } from 'chai';\nimport { ConsecutiveBreaker } from './ConsecutiveBreaker';\n\ndescribe('ConsecutiveBreaker', () => {\n  it('works', () => {\n    const c = new ConsecutiveBreaker(3);\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.true;\n    expect(c.failure()).to.be.true;\n\n    c.success();\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.true;\n  });\n\n  it('serializes and deserializes', () => {\n    const c = new ConsecutiveBreaker(3);\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.true;\n\n    const c2 = new ConsecutiveBreaker(3);\n    c2.state = c.state;\n    expect(c.failure()).to.be.true;\n\n    c.success();\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.false;\n    expect(c.failure()).to.be.true;\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/CountBreaker.js.map b/node_modules/cockatiel/dist/breaker/CountBreaker.js.map
index 5e5bc0d..1f2cf56 100644
--- a/node_modules/cockatiel/dist/breaker/CountBreaker.js.map
+++ b/node_modules/cockatiel/dist/breaker/CountBreaker.js.map
@@ -1 +1 @@
-{"version":3,"file":"CountBreaker.js","sourceRoot":"","sources":["../../src/breaker/CountBreaker.ts"],"names":[],"mappings":";;;AAAA,kEAAuD;AAgCvD,MAAa,YAAY;IAavB;;OAEG;IACH,IAAW,KAAK;QACd,OAAO;YACL,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,aAAa,EAAE,IAAI,CAAC,aAAa;YACjC,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,SAAS,EAAE,IAAI,CAAC,SAAS;SACG,CAAC;IACjC,CAAC;IAED;;OAEG;IACH,IAAW,KAAK,CAAC,KAAc;QAC7B,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC7B,CAAC;IAED;;;;;OAKG;IACH,YAAY,EAAE,SAAS,EAAE,IAAI,EAAE,oBAAoB,GAAG,IAAI,EAAwB;QA7B1E,cAAS,GAAG,CAAC,CAAC;QACd,aAAQ,GAAG,CAAC,CAAC;QACb,kBAAa,GAAG,CAAC,CAAC;QA4BxB,IAAI,SAAS,IAAI,CAAC,IAAI,SAAS,IAAI,CAAC,EAAE,CAAC;YACrC,MAAM,IAAI,UAAU,CAAC,wDAAwD,SAAS,EAAE,CAAC,CAAC;QAC5F,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,EAAE,CAAC;YAC5C,MAAM,IAAI,UAAU,CAAC,uDAAuD,IAAI,EAAE,CAAC,CAAC;QACtF,CAAC;QACD,IACE,CAAC,MAAM,CAAC,aAAa,CAAC,oBAAoB,CAAC;YAC3C,oBAAoB,GAAG,CAAC;YACxB,oBAAoB,GAAG,IAAI,EAC3B,CAAC;YACD,MAAM,IAAI,UAAU,CAClB,iEAAiE,oBAAoB,EAAE,CACxF,CAAC;QACJ,CAAC;QAED,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;QACjD,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;IAC1D,CAAC;IAED;;OAEG;IACI,OAAO,CAAC,KAAmB;QAChC,IAAI,KAAK,KAAK,mCAAY,CAAC,QAAQ,EAAE,CAAC;YACpC,IAAI,CAAC,KAAK,EAAE,CAAC;QACf,CAAC;QAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACpB,CAAC;IAED;;OAEG;IACI,OAAO,CAAC,KAAmB;QAChC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEnB,IAAI,KAAK,KAAK,mCAAY,CAAC,MAAM,EAAE,CAAC;YAClC,OAAO,IAAI,CAAC;QACd,CAAC;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE7C,IAAI,KAAK,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;YACtC,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,GAAG,KAAK,EAAE,CAAC;YAC3C,OAAO,IAAI,CAAC;QACd,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAEO,KAAK;QACX,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;IACpB,CAAC;IAEO,MAAM,CAAC,OAAgB;QAC7B,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACjD,IAAI,OAAO,KAAK,IAAI,EAAE,CAAC;YACrB,IAAI,CAAC,SAAS,EAAE,CAAC;QACnB,CAAC;aAAM,IAAI,OAAO,KAAK,KAAK,EAAE,CAAC;YAC7B,IAAI,CAAC,QAAQ,EAAE,CAAC;QAClB,CAAC;QAED,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC;QAC3C,IAAI,OAAO,EAAE,CAAC;YACZ,IAAI,CAAC,SAAS,EAAE,CAAC;QACnB,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,QAAQ,EAAE,CAAC;QAClB,CAAC;QAED,IAAI,CAAC,aAAa,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;IACtE,CAAC;CACF;AArHD,oCAqHC","sourcesContent":["import { CircuitState } from '../CircuitBreakerPolicy';\nimport { IBreaker } from './Breaker';\n\nexport interface ICountBreakerOptions {\n  /**\n   * Percentage (from 0 to 1) of requests that need to fail before we'll\n   * open the circuit.\n   */\n  threshold: number;\n\n  /**\n   * Size of the count based sliding window.\n   */\n  size: number;\n\n  /**\n   * Minimum number of calls needed to (potentially) open the circuit.\n   * Useful to avoid unnecessarily tripping when there are only few samples yet.\n   * Defaults to {@link ICountBreakerOptions.size}.\n   */\n  minimumNumberOfCalls?: number;\n}\n\n\ninterface ICountBreakerState {\n  samples: (boolean | null)[];\n  currentSample: number;\n  failures: number;\n  successes: number;\n}\n\n\nexport class CountBreaker implements IBreaker {\n  private readonly threshold: number;\n  private readonly minimumNumberOfCalls: number;\n\n  /**\n   * The samples in the sliding window. `true` means \"success\", `false` means\n   * \"failure\" and `null` means that there is no sample yet.\n   */\n  private samples: (boolean | null)[];\n  private successes = 0;\n  private failures = 0;\n  private currentSample = 0;\n\n  /**\n   * @inheritdoc\n   */\n  public get state(): unknown {\n    return {\n      samples: this.samples,\n      currentSample: this.currentSample,\n      failures: this.failures,\n      successes: this.successes,\n    } satisfies ICountBreakerState;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public set state(value: unknown) {\n    Object.assign(this, value);\n  }\n\n  /**\n   * CountBreaker breaks if more than `threshold` percentage of the last `size`\n   * calls failed, so long as at least `minimumNumberOfCalls` calls have been\n   * performed (to avoid opening unnecessarily if there are only few samples\n   * in the sliding window yet).\n   */\n  constructor({ threshold, size, minimumNumberOfCalls = size }: ICountBreakerOptions) {\n    if (threshold <= 0 || threshold >= 1) {\n      throw new RangeError(`CountBreaker threshold should be between (0, 1), got ${threshold}`);\n    }\n    if (!Number.isSafeInteger(size) || size < 1) {\n      throw new RangeError(`CountBreaker size should be a positive integer, got ${size}`);\n    }\n    if (\n      !Number.isSafeInteger(minimumNumberOfCalls) ||\n      minimumNumberOfCalls < 1 ||\n      minimumNumberOfCalls > size\n    ) {\n      throw new RangeError(\n        `CountBreaker size should be an integer between (1, size), got ${minimumNumberOfCalls}`,\n      );\n    }\n\n    this.threshold = threshold;\n    this.minimumNumberOfCalls = minimumNumberOfCalls;\n    this.samples = Array.from({ length: size }, () => null);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public success(state: CircuitState) {\n    if (state === CircuitState.HalfOpen) {\n      this.reset();\n    }\n\n    this.sample(true);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public failure(state: CircuitState) {\n    this.sample(false);\n\n    if (state !== CircuitState.Closed) {\n      return true;\n    }\n\n    const total = this.successes + this.failures;\n\n    if (total < this.minimumNumberOfCalls) {\n      return false;\n    }\n\n    if (this.failures > this.threshold * total) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private reset() {\n    this.samples.fill(null);\n    this.successes = 0;\n    this.failures = 0;\n  }\n\n  private sample(success: boolean) {\n    const current = this.samples[this.currentSample];\n    if (current === true) {\n      this.successes--;\n    } else if (current === false) {\n      this.failures--;\n    }\n\n    this.samples[this.currentSample] = success;\n    if (success) {\n      this.successes++;\n    } else {\n      this.failures++;\n    }\n\n    this.currentSample = (this.currentSample + 1) % this.samples.length;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"CountBreaker.js","sourceRoot":"","sources":["../../src/breaker/CountBreaker.ts"],"names":[],"mappings":"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","sourcesContent":["import { CircuitState } from '../CircuitBreakerPolicy';\nimport { IBreaker } from './Breaker';\n\nexport interface ICountBreakerOptions {\n  /**\n   * Percentage (from 0 to 1) of requests that need to fail before we'll\n   * open the circuit.\n   */\n  threshold: number;\n\n  /**\n   * Size of the count based sliding window.\n   */\n  size: number;\n\n  /**\n   * Minimum number of calls needed to (potentially) open the circuit.\n   * Useful to avoid unnecessarily tripping when there are only few samples yet.\n   * Defaults to {@link ICountBreakerOptions.size}.\n   */\n  minimumNumberOfCalls?: number;\n}\n\ninterface ICountBreakerState {\n  samples: (boolean | null)[];\n  currentSample: number;\n  failures: number;\n  successes: number;\n}\n\nexport class CountBreaker implements IBreaker {\n  private readonly threshold: number;\n  private readonly minimumNumberOfCalls: number;\n\n  /**\n   * The samples in the sliding window. `true` means \"success\", `false` means\n   * \"failure\" and `null` means that there is no sample yet.\n   */\n  private samples: (boolean | null)[];\n  private successes = 0;\n  private failures = 0;\n  private currentSample = 0;\n\n  /**\n   * @inheritdoc\n   */\n  public get state(): unknown {\n    return {\n      samples: this.samples,\n      currentSample: this.currentSample,\n      failures: this.failures,\n      successes: this.successes,\n    } satisfies ICountBreakerState;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public set state(value: unknown) {\n    Object.assign(this, value);\n  }\n\n  /**\n   * CountBreaker breaks if more than `threshold` percentage of the last `size`\n   * calls failed, so long as at least `minimumNumberOfCalls` calls have been\n   * performed (to avoid opening unnecessarily if there are only few samples\n   * in the sliding window yet).\n   */\n  constructor({ threshold, size, minimumNumberOfCalls = size }: ICountBreakerOptions) {\n    if (threshold <= 0 || threshold >= 1) {\n      throw new RangeError(`CountBreaker threshold should be between (0, 1), got ${threshold}`);\n    }\n    if (!Number.isSafeInteger(size) || size < 1) {\n      throw new RangeError(`CountBreaker size should be a positive integer, got ${size}`);\n    }\n    if (\n      !Number.isSafeInteger(minimumNumberOfCalls) ||\n      minimumNumberOfCalls < 1 ||\n      minimumNumberOfCalls > size\n    ) {\n      throw new RangeError(\n        `CountBreaker size should be an integer between (1, size), got ${minimumNumberOfCalls}`,\n      );\n    }\n\n    this.threshold = threshold;\n    this.minimumNumberOfCalls = minimumNumberOfCalls;\n    this.samples = Array.from({ length: size }, () => null);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public success(state: CircuitState) {\n    if (state === CircuitState.HalfOpen) {\n      this.reset();\n    }\n\n    this.sample(true);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public failure(state: CircuitState) {\n    this.sample(false);\n\n    if (state !== CircuitState.Closed) {\n      return true;\n    }\n\n    const total = this.successes + this.failures;\n\n    if (total < this.minimumNumberOfCalls) {\n      return false;\n    }\n\n    if (this.failures > this.threshold * total) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private reset() {\n    this.samples.fill(null);\n    this.successes = 0;\n    this.failures = 0;\n  }\n\n  private sample(success: boolean) {\n    const current = this.samples[this.currentSample];\n    if (current === true) {\n      this.successes--;\n    } else if (current === false) {\n      this.failures--;\n    }\n\n    this.samples[this.currentSample] = success;\n    if (success) {\n      this.successes++;\n    } else {\n      this.failures++;\n    }\n\n    this.currentSample = (this.currentSample + 1) % this.samples.length;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/CountBreaker.test.d.ts b/node_modules/cockatiel/dist/breaker/CountBreaker.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/CountBreaker.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/breaker/CountBreaker.test.js b/node_modules/cockatiel/dist/breaker/CountBreaker.test.js
new file mode 100644
index 0000000..2d1b06f
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/CountBreaker.test.js
@@ -0,0 +1,120 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const subset = require("chai-subset");
+const CircuitBreakerPolicy_1 = require("../CircuitBreakerPolicy");
+const CountBreaker_1 = require("./CountBreaker");
+(0, chai_1.use)(subset);
+const getState = (b) => {
+    const untyped = b;
+    return {
+        threshold: untyped.threshold,
+        minimumNumberOfCalls: untyped.minimumNumberOfCalls,
+        samples: [...untyped.samples],
+        successes: untyped.successes,
+        failures: untyped.failures,
+        currentSample: untyped.currentSample,
+    };
+};
+describe('CountBreaker', () => {
+    describe('parameter creation', () => {
+        it('rejects if threshold is out of range', () => {
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: -1, size: 100 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0, size: 100 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 1, size: 100 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 10, size: 100 })).to.throw(RangeError);
+        });
+        it('rejects if size is invalid', () => {
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0.5, size: -1 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 0 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 0.5 })).to.throw(RangeError);
+        });
+        it('rejects if minimumNumberOfCalls is invalid', () => {
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: -1 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 0 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 0.5 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 101 })).to.throw(RangeError);
+        });
+        it('creates good initial params', () => {
+            const b = new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 50 });
+            (0, chai_1.expect)(getState(b)).to.containSubset({
+                threshold: 0.5,
+                minimumNumberOfCalls: 50,
+            });
+            (0, chai_1.expect)(getState(b).samples).to.have.lengthOf(100);
+        });
+    });
+    describe('window', () => {
+        it('correctly wraps around when reaching the end of the window', () => {
+            const b = new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 5 });
+            for (let i = 0; i < 9; i++) {
+                if (i % 3 === 0) {
+                    b.failure(CircuitBreakerPolicy_1.CircuitState.Closed);
+                }
+                else {
+                    b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+                }
+            }
+            const state = getState(b);
+            (0, chai_1.expect)(state.currentSample).to.equal(4);
+            (0, chai_1.expect)(state.samples).to.deep.equal([true, false, true, true, true]);
+        });
+        it('serializes and deserializes', () => {
+            let b = new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 5 });
+            for (let i = 0; i < 9; i++) {
+                if (i % 3 === 0) {
+                    b.failure(CircuitBreakerPolicy_1.CircuitState.Closed);
+                }
+                else {
+                    b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+                }
+                const state = b.state;
+                b = new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 5 });
+                b.state = state;
+            }
+            const state = getState(b);
+            (0, chai_1.expect)(state.currentSample).to.equal(4);
+            (0, chai_1.expect)(state.samples).to.deep.equal([true, false, true, true, true]);
+        });
+    });
+    describe('functionality', () => {
+        let b;
+        beforeEach(() => {
+            b = new CountBreaker_1.CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 50 });
+        });
+        it('does not open as long as the minimum number of calls has not been reached', () => {
+            for (let i = 0; i < 49; i++) {
+                (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+            }
+        });
+        it('does not open when the minimum number of calls has been reached but the threshold has not been surpassed', () => {
+            for (let i = 0; i < 25; i++) {
+                b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+            }
+            for (let i = 0; i < 24; i++) {
+                (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+            }
+            (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+        });
+        it('opens when the minimum number of calls has been reached and threshold has been surpassed', () => {
+            for (let i = 0; i < 24; i++) {
+                b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+            }
+            for (let i = 0; i < 25; i++) {
+                (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+            }
+            (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.true;
+        });
+        it('resets when recoving from a half-open', () => {
+            for (let i = 0; i < 100; i++) {
+                b.failure(CircuitBreakerPolicy_1.CircuitState.Closed);
+            }
+            b.success(CircuitBreakerPolicy_1.CircuitState.HalfOpen);
+            const state = getState(b);
+            (0, chai_1.expect)(state.failures).to.equal(0);
+            (0, chai_1.expect)(state.successes).to.equal(1);
+            (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+        });
+    });
+});
+//# sourceMappingURL=CountBreaker.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/CountBreaker.test.js.map b/node_modules/cockatiel/dist/breaker/CountBreaker.test.js.map
new file mode 100644
index 0000000..2ab9b38
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/CountBreaker.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"CountBreaker.test.js","sourceRoot":"","sources":["../../src/breaker/CountBreaker.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect, use } from 'chai';\nimport * as subset from 'chai-subset';\nimport { CircuitState } from '../CircuitBreakerPolicy';\nimport { CountBreaker } from './CountBreaker';\n\nuse(subset);\n\nconst getState = (b: CountBreaker) => {\n  const untyped: any = b;\n  return {\n    threshold: untyped.threshold,\n    minimumNumberOfCalls: untyped.minimumNumberOfCalls,\n    samples: [...untyped.samples],\n    successes: untyped.successes,\n    failures: untyped.failures,\n    currentSample: untyped.currentSample,\n  };\n};\n\ndescribe('CountBreaker', () => {\n  describe('parameter creation', () => {\n    it('rejects if threshold is out of range', () => {\n      expect(() => new CountBreaker({ threshold: -1, size: 100 })).to.throw(RangeError);\n      expect(() => new CountBreaker({ threshold: 0, size: 100 })).to.throw(RangeError);\n      expect(() => new CountBreaker({ threshold: 1, size: 100 })).to.throw(RangeError);\n      expect(() => new CountBreaker({ threshold: 10, size: 100 })).to.throw(RangeError);\n    });\n\n    it('rejects if size is invalid', () => {\n      expect(() => new CountBreaker({ threshold: 0.5, size: -1 })).to.throw(RangeError);\n      expect(() => new CountBreaker({ threshold: 0.5, size: 0 })).to.throw(RangeError);\n      expect(() => new CountBreaker({ threshold: 0.5, size: 0.5 })).to.throw(RangeError);\n    });\n\n    it('rejects if minimumNumberOfCalls is invalid', () => {\n      expect(\n        () => new CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: -1 }),\n      ).to.throw(RangeError);\n      expect(\n        () => new CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 0 }),\n      ).to.throw(RangeError);\n      expect(\n        () => new CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 0.5 }),\n      ).to.throw(RangeError);\n      expect(\n        () => new CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 101 }),\n      ).to.throw(RangeError);\n    });\n\n    it('creates good initial params', () => {\n      const b = new CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 50 });\n      expect(getState(b)).to.containSubset({\n        threshold: 0.5,\n        minimumNumberOfCalls: 50,\n      });\n\n      expect(getState(b).samples).to.have.lengthOf(100);\n    });\n  });\n\n  describe('window', () => {\n    it('correctly wraps around when reaching the end of the window', () => {\n      const b = new CountBreaker({ threshold: 0.5, size: 5 });\n      for (let i = 0; i < 9; i++) {\n        if (i % 3 === 0) {\n          b.failure(CircuitState.Closed);\n        } else {\n          b.success(CircuitState.Closed);\n        }\n      }\n\n      const state = getState(b);\n      expect(state.currentSample).to.equal(4);\n      expect(state.samples).to.deep.equal([true, false, true, true, true]);\n    });\n\n    it('serializes and deserializes', () => {\n      let b = new CountBreaker({ threshold: 0.5, size: 5 });\n      for (let i = 0; i < 9; i++) {\n        if (i % 3 === 0) {\n          b.failure(CircuitState.Closed);\n        } else {\n          b.success(CircuitState.Closed);\n        }\n        const state = b.state;\n        b = new CountBreaker({ threshold: 0.5, size: 5 });\n        b.state = state;\n      }\n\n      const state = getState(b);\n      expect(state.currentSample).to.equal(4);\n      expect(state.samples).to.deep.equal([true, false, true, true, true]);\n    });\n  });\n\n  describe('functionality', () => {\n    let b: CountBreaker;\n\n    beforeEach(() => {\n      b = new CountBreaker({ threshold: 0.5, size: 100, minimumNumberOfCalls: 50 });\n    });\n\n    it('does not open as long as the minimum number of calls has not been reached', () => {\n      for (let i = 0; i < 49; i++) {\n        expect(b.failure(CircuitState.Closed)).to.be.false;\n      }\n    });\n\n    it('does not open when the minimum number of calls has been reached but the threshold has not been surpassed', () => {\n      for (let i = 0; i < 25; i++) {\n        b.success(CircuitState.Closed);\n      }\n      for (let i = 0; i < 24; i++) {\n        expect(b.failure(CircuitState.Closed)).to.be.false;\n      }\n      expect(b.failure(CircuitState.Closed)).to.be.false;\n    });\n\n    it('opens when the minimum number of calls has been reached and threshold has been surpassed', () => {\n      for (let i = 0; i < 24; i++) {\n        b.success(CircuitState.Closed);\n      }\n      for (let i = 0; i < 25; i++) {\n        expect(b.failure(CircuitState.Closed)).to.be.false;\n      }\n      expect(b.failure(CircuitState.Closed)).to.be.true;\n    });\n\n    it('resets when recoving from a half-open', () => {\n      for (let i = 0; i < 100; i++) {\n        b.failure(CircuitState.Closed);\n      }\n\n      b.success(CircuitState.HalfOpen);\n\n      const state = getState(b);\n      expect(state.failures).to.equal(0);\n      expect(state.successes).to.equal(1);\n      expect(b.failure(CircuitState.Closed)).to.be.false;\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.d.ts b/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.js b/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.js
new file mode 100644
index 0000000..56f20ad
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.js
@@ -0,0 +1,167 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const subset = require("chai-subset");
+const sinon_1 = require("sinon");
+const CircuitBreakerPolicy_1 = require("../CircuitBreakerPolicy");
+const SamplingBreaker_1 = require("./SamplingBreaker");
+(0, chai_1.use)(subset);
+const getState = (b) => {
+    const untyped = b;
+    return {
+        threshold: untyped.threshold,
+        minimumRpms: untyped.minimumRpms,
+        duration: untyped.duration,
+        windowSize: untyped.windowSize,
+        windows: untyped.windows.map((w) => ({ ...w })),
+        currentWindow: untyped.currentWindow,
+        currentFailures: untyped.currentFailures,
+        currentSuccesses: untyped.currentSuccesses,
+    };
+};
+describe('SamplingBreaker', () => {
+    describe('parameter creation', () => {
+        it('rejects if threshold out of range', () => {
+            (0, chai_1.expect)(() => new SamplingBreaker_1.SamplingBreaker({ threshold: -1, duration: 10 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new SamplingBreaker_1.SamplingBreaker({ threshold: 0, duration: 10 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new SamplingBreaker_1.SamplingBreaker({ threshold: 1, duration: 10 })).to.throw(RangeError);
+            (0, chai_1.expect)(() => new SamplingBreaker_1.SamplingBreaker({ threshold: 10, duration: 10 })).to.throw(RangeError);
+        });
+        it('creates good initial params', () => {
+            const b = new SamplingBreaker_1.SamplingBreaker({ threshold: 0.2, duration: 10_000, minimumRps: 5 });
+            (0, chai_1.expect)(getState(b)).to.containSubset({
+                threshold: 0.2,
+                duration: 10_000,
+                minimumRpms: 5 / 1000,
+                windowSize: 1000,
+            });
+            (0, chai_1.expect)(getState(b).windows).to.have.lengthOf(10);
+        });
+        it('creates initial params for small durations', () => {
+            const b = new SamplingBreaker_1.SamplingBreaker({ threshold: 0.2, duration: 103, minimumRps: 5 });
+            (0, chai_1.expect)(getState(b)).to.containSubset({
+                threshold: 0.2,
+                duration: 105,
+                minimumRpms: 5 / 1000,
+                windowSize: 21,
+            });
+            (0, chai_1.expect)(getState(b).windows).to.have.lengthOf(5);
+        });
+        it('creates guess for rpms', () => {
+            const b1 = new SamplingBreaker_1.SamplingBreaker({ threshold: 0.2, duration: 103 });
+            // needs at least 5 failures/sec, threshold of 0.2 means 5 * 5 total req/s
+            (0, chai_1.expect)(getState(b1).minimumRpms).to.equal(25 / 1000);
+            const b2 = new SamplingBreaker_1.SamplingBreaker({ threshold: 0.25, duration: 103 });
+            // 5 * 4 here
+            (0, chai_1.expect)(getState(b2).minimumRpms).to.equal(20 / 1000);
+        });
+    });
+    describe('windowing', () => {
+        let b;
+        let clock;
+        beforeEach(() => {
+            b = new SamplingBreaker_1.SamplingBreaker({ threshold: 0.5, duration: 5_000, minimumRps: 3 });
+            clock = (0, sinon_1.useFakeTimers)();
+        });
+        afterEach(() => {
+            clock.restore();
+        });
+        it('increments and wraps buckets correctly', () => {
+            for (let i = 0; i < 7; i++) {
+                for (let k = 0; k < i; k++) {
+                    b.failure(CircuitBreakerPolicy_1.CircuitState.Closed);
+                    b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+                    b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+                }
+                clock.tick(1000);
+            }
+            (0, chai_1.expect)(getState(b)).to.containSubset({
+                currentFailures: 20,
+                currentSuccesses: 40,
+                currentWindow: 1,
+            });
+            (0, chai_1.expect)(getState(b).windows).to.deep.equal([
+                { failures: 5, successes: 10, startedAt: 5000 },
+                { failures: 6, successes: 12, startedAt: 6000 },
+                { failures: 2, successes: 4, startedAt: 2000 },
+                { failures: 3, successes: 6, startedAt: 3000 },
+                { failures: 4, successes: 8, startedAt: 4000 },
+            ]);
+        });
+        it('serializes and deserializes', () => {
+            for (let i = 0; i < 7; i++) {
+                for (let k = 0; k < i; k++) {
+                    b.failure(CircuitBreakerPolicy_1.CircuitState.Closed);
+                    b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+                    b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+                }
+                clock.tick(1000);
+                const b2 = new SamplingBreaker_1.SamplingBreaker({ threshold: 0.5, duration: 5_000, minimumRps: 3 });
+                b2.state = b.state;
+                b = b2;
+            }
+            (0, chai_1.expect)(getState(b)).to.containSubset({
+                currentFailures: 20,
+                currentSuccesses: 40,
+                currentWindow: 1,
+            });
+            (0, chai_1.expect)(getState(b).windows).to.deep.equal([
+                { failures: 5, successes: 10, startedAt: 5000 },
+                { failures: 6, successes: 12, startedAt: 6000 },
+                { failures: 2, successes: 4, startedAt: 2000 },
+                { failures: 3, successes: 6, startedAt: 3000 },
+                { failures: 4, successes: 8, startedAt: 4000 },
+            ]);
+        });
+    });
+    describe('functionality', () => {
+        let b;
+        let clock;
+        const createTestBreaker = () => (b = new SamplingBreaker_1.SamplingBreaker({ threshold: 0.5, duration: 5_000, minimumRps: 3 }));
+        beforeEach(() => {
+            createTestBreaker();
+            clock = (0, sinon_1.useFakeTimers)();
+        });
+        afterEach(() => {
+            clock.restore();
+        });
+        it('does not start failing if below threshold rps', () => {
+            for (let i = 0; i < 10; i++) {
+                (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+                clock.tick(500); // advancing 0.5s each, never hits 3rps
+            }
+        });
+        it('fails once above rps', () => {
+            for (let i = 0; i < 3 * 5; i++) {
+                clock.tick(334);
+                (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+            }
+            b.failure(CircuitBreakerPolicy_1.CircuitState.Closed);
+            // need one extra due to bucket approximation:
+            (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.true;
+        });
+        it('calculates rps correctly over time', () => {
+            // keep us right on the edge of closing (50% failure rate) for amounts of
+            // time, and verify that adding another failure
+            // right after each opens the circuit
+            for (let runLength = 10; runLength < 20; runLength++) {
+                createTestBreaker();
+                for (let i = 0; i < runLength; i++) {
+                    b.success(CircuitBreakerPolicy_1.CircuitState.Closed);
+                    (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+                    clock.tick(250);
+                }
+                (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.true;
+            }
+        });
+        it('resets when recoving from a half-open', () => {
+            for (let i = 0; i < 10; i++) {
+                b.failure(CircuitBreakerPolicy_1.CircuitState.Closed);
+            }
+            b.success(CircuitBreakerPolicy_1.CircuitState.HalfOpen);
+            (0, chai_1.expect)(getState(b).currentFailures).to.equal(0);
+            (0, chai_1.expect)(b.failure(CircuitBreakerPolicy_1.CircuitState.Closed)).to.be.false;
+        });
+    });
+});
+//# sourceMappingURL=SamplingBreaker.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.js.map b/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.js.map
new file mode 100644
index 0000000..64bb334
--- /dev/null
+++ b/node_modules/cockatiel/dist/breaker/SamplingBreaker.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SamplingBreaker.test.js","sourceRoot":"","sources":["../../src/breaker/SamplingBreaker.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect, use } from 'chai';\nimport * as subset from 'chai-subset';\nimport { SinonFakeTimers, useFakeTimers } from 'sinon';\nimport { CircuitState } from '../CircuitBreakerPolicy';\nimport { SamplingBreaker } from './SamplingBreaker';\n\nuse(subset);\n\nconst getState = (b: SamplingBreaker) => {\n  const untyped: any = b;\n  return {\n    threshold: untyped.threshold,\n    minimumRpms: untyped.minimumRpms,\n    duration: untyped.duration,\n    windowSize: untyped.windowSize,\n    windows: untyped.windows.map((w: object) => ({ ...w })),\n    currentWindow: untyped.currentWindow,\n    currentFailures: untyped.currentFailures,\n    currentSuccesses: untyped.currentSuccesses,\n  };\n};\n\ndescribe('SamplingBreaker', () => {\n  describe('parameter creation', () => {\n    it('rejects if threshold out of range', () => {\n      expect(() => new SamplingBreaker({ threshold: -1, duration: 10 })).to.throw(RangeError);\n      expect(() => new SamplingBreaker({ threshold: 0, duration: 10 })).to.throw(RangeError);\n      expect(() => new SamplingBreaker({ threshold: 1, duration: 10 })).to.throw(RangeError);\n      expect(() => new SamplingBreaker({ threshold: 10, duration: 10 })).to.throw(RangeError);\n    });\n\n    it('creates good initial params', () => {\n      const b = new SamplingBreaker({ threshold: 0.2, duration: 10_000, minimumRps: 5 });\n      expect(getState(b)).to.containSubset({\n        threshold: 0.2,\n        duration: 10_000,\n        minimumRpms: 5 / 1000,\n        windowSize: 1000,\n      });\n\n      expect(getState(b).windows).to.have.lengthOf(10);\n    });\n\n    it('creates initial params for small durations', () => {\n      const b = new SamplingBreaker({ threshold: 0.2, duration: 103, minimumRps: 5 });\n      expect(getState(b)).to.containSubset({\n        threshold: 0.2,\n        duration: 105,\n        minimumRpms: 5 / 1000,\n        windowSize: 21,\n      });\n      expect(getState(b).windows).to.have.lengthOf(5);\n    });\n\n    it('creates guess for rpms', () => {\n      const b1 = new SamplingBreaker({ threshold: 0.2, duration: 103 });\n      // needs at least 5 failures/sec, threshold of 0.2 means 5 * 5 total req/s\n      expect(getState(b1).minimumRpms).to.equal(25 / 1000);\n\n      const b2 = new SamplingBreaker({ threshold: 0.25, duration: 103 });\n      // 5 * 4 here\n      expect(getState(b2).minimumRpms).to.equal(20 / 1000);\n    });\n  });\n\n  describe('windowing', () => {\n    let b: SamplingBreaker;\n    let clock: SinonFakeTimers;\n\n    beforeEach(() => {\n      b = new SamplingBreaker({ threshold: 0.5, duration: 5_000, minimumRps: 3 });\n      clock = useFakeTimers();\n    });\n\n    afterEach(() => {\n      clock.restore();\n    });\n\n    it('increments and wraps buckets correctly', () => {\n      for (let i = 0; i < 7; i++) {\n        for (let k = 0; k < i; k++) {\n          b.failure(CircuitState.Closed);\n          b.success(CircuitState.Closed);\n          b.success(CircuitState.Closed);\n        }\n\n        clock.tick(1000);\n      }\n\n      expect(getState(b)).to.containSubset({\n        currentFailures: 20,\n        currentSuccesses: 40,\n        currentWindow: 1,\n      });\n      expect(getState(b).windows).to.deep.equal([\n        { failures: 5, successes: 10, startedAt: 5000 },\n        { failures: 6, successes: 12, startedAt: 6000 },\n        { failures: 2, successes: 4, startedAt: 2000 },\n        { failures: 3, successes: 6, startedAt: 3000 },\n        { failures: 4, successes: 8, startedAt: 4000 },\n      ]);\n    });\n\n    it('serializes and deserializes', () => {\n      for (let i = 0; i < 7; i++) {\n        for (let k = 0; k < i; k++) {\n          b.failure(CircuitState.Closed);\n          b.success(CircuitState.Closed);\n          b.success(CircuitState.Closed);\n        }\n\n        clock.tick(1000);\n        const b2 = new SamplingBreaker({ threshold: 0.5, duration: 5_000, minimumRps: 3 });\n        b2.state = b.state;\n        b = b2;\n      }\n\n      expect(getState(b)).to.containSubset({\n        currentFailures: 20,\n        currentSuccesses: 40,\n        currentWindow: 1,\n      });\n      expect(getState(b).windows).to.deep.equal([\n        { failures: 5, successes: 10, startedAt: 5000 },\n        { failures: 6, successes: 12, startedAt: 6000 },\n        { failures: 2, successes: 4, startedAt: 2000 },\n        { failures: 3, successes: 6, startedAt: 3000 },\n        { failures: 4, successes: 8, startedAt: 4000 },\n      ]);\n    });\n  });\n\n  describe('functionality', () => {\n    let b: SamplingBreaker;\n    let clock: SinonFakeTimers;\n\n    const createTestBreaker = () =>\n      (b = new SamplingBreaker({ threshold: 0.5, duration: 5_000, minimumRps: 3 }));\n\n    beforeEach(() => {\n      createTestBreaker();\n      clock = useFakeTimers();\n    });\n\n    afterEach(() => {\n      clock.restore();\n    });\n\n    it('does not start failing if below threshold rps', () => {\n      for (let i = 0; i < 10; i++) {\n        expect(b.failure(CircuitState.Closed)).to.be.false;\n        clock.tick(500); // advancing 0.5s each, never hits 3rps\n      }\n    });\n\n    it('fails once above rps', () => {\n      for (let i = 0; i < 3 * 5; i++) {\n        clock.tick(334);\n        expect(b.failure(CircuitState.Closed)).to.be.false;\n      }\n\n      b.failure(CircuitState.Closed);\n      // need one extra due to bucket approximation:\n      expect(b.failure(CircuitState.Closed)).to.be.true;\n    });\n\n    it('calculates rps correctly over time', () => {\n      // keep us right on the edge of closing (50% failure rate) for amounts of\n      // time, and verify that adding another failure\n      // right after each opens the circuit\n      for (let runLength = 10; runLength < 20; runLength++) {\n        createTestBreaker();\n\n        for (let i = 0; i < runLength; i++) {\n          b.success(CircuitState.Closed);\n          expect(b.failure(CircuitState.Closed)).to.be.false;\n          clock.tick(250);\n        }\n\n        expect(b.failure(CircuitState.Closed)).to.be.true;\n      }\n    });\n\n    it('resets when recoving from a half-open', () => {\n      for (let i = 0; i < 10; i++) {\n        b.failure(CircuitState.Closed);\n      }\n\n      b.success(CircuitState.HalfOpen);\n      expect(getState(b).currentFailures).to.equal(0);\n      expect(b.failure(CircuitState.Closed)).to.be.false;\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/Event.d.ts b/node_modules/cockatiel/dist/common/Event.d.ts
index f681344..b1956c7 100644
--- a/node_modules/cockatiel/dist/common/Event.d.ts
+++ b/node_modules/cockatiel/dist/common/Event.d.ts
@@ -1,3 +1,4 @@
+import { AbortSignal } from './LocalAbortController';
 /**
  * Type that can be disposed.
  */
@@ -22,7 +23,7 @@ export declare namespace Event {
 }
 /** Creates an Event that fires when the signal is aborted. */
 export declare const onAbort: (signal: AbortSignal) => {
-    event: Event<void>;
+    event: Event<unknown>;
 } & IDisposable;
 /**
  * Base event emitter. Calls listeners when data is emitted.
diff --git a/node_modules/cockatiel/dist/common/Event.js b/node_modules/cockatiel/dist/common/Event.js
index 09728b0..d69605c 100644
--- a/node_modules/cockatiel/dist/common/Event.js
+++ b/node_modules/cockatiel/dist/common/Event.js
@@ -58,13 +58,12 @@ var Event;
 const onAbort = (signal) => {
     const evt = new OneShotEvent();
     if (signal.aborted) {
-        evt.emit();
+        evt.emit(signal.reason);
         return { event: evt.addListener, dispose: () => { } };
     }
     const dispose = () => signal.removeEventListener('abort', l);
-    // @types/node is currently missing the event types on AbortSignal
     const l = () => {
-        evt.emit();
+        evt.emit(signal.reason);
         dispose();
     };
     signal.addEventListener('abort', l);
diff --git a/node_modules/cockatiel/dist/common/Event.js.map b/node_modules/cockatiel/dist/common/Event.js.map
index a512c58..27d046f 100644
--- a/node_modules/cockatiel/dist/common/Event.js.map
+++ b/node_modules/cockatiel/dist/common/Event.js.map
@@ -1 +1 @@
-{"version":3,"file":"Event.js","sourceRoot":"","sources":["../../src/common/Event.ts"],"names":[],"mappings":"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","sourcesContent":["import { TaskCancelledError } from '../errors/TaskCancelledError';\n\n/**\n * Type that can be disposed.\n */\nexport interface IDisposable {\n  dispose(): void;\n}\n\nexport const noopDisposable: IDisposable = { dispose: () => undefined };\n\n/**\n * Function that subscribes the method to receive data.\n */\nexport type Event<T> = (listener: (data: T) => void) => IDisposable;\n\nexport namespace Event {\n  /**\n   * Adds a handler that handles one event on the emitter.\n   */\n  export const once = <T>(event: Event<T>, listener: (data: T) => void): IDisposable => {\n    let syncDispose = false;\n    let disposable: IDisposable | void;\n\n    disposable = event(value => {\n      listener(value);\n\n      if (disposable) {\n        disposable.dispose();\n      } else {\n        syncDispose = true; // callback can fire before disposable is returned\n      }\n    });\n\n    if (syncDispose) {\n      disposable.dispose();\n      return noopDisposable; // no reason to keep the ref around\n    }\n\n    return disposable;\n  };\n\n  /**\n   * Returns a promise that resolves when the event fires, or when cancellation\n   * is requested, whichever happens first.\n   */\n  export const toPromise = <T>(event: Event<T>, signal?: AbortSignal): Promise<T> => {\n    if (!signal) {\n      return new Promise<T>(resolve => once(event, resolve));\n    }\n\n    if (signal.aborted) {\n      return Promise.reject(new TaskCancelledError());\n    }\n\n    const toDispose: IDisposable[] = [];\n\n    return new Promise<T>((resolve, reject) => {\n      const abortEvt = onAbort(signal);\n      toDispose.push(abortEvt);\n\n      toDispose.push(\n        abortEvt.event(() => {\n          reject(new TaskCancelledError());\n        }),\n      );\n\n      toDispose.push(\n        once(event, data => {\n          resolve(data);\n        }),\n      );\n    }).finally(() => {\n      for (const d of toDispose) {\n        d.dispose();\n      }\n    });\n  };\n}\n\n/** Creates an Event that fires when the signal is aborted. */\nexport const onAbort = (signal: AbortSignal): { event: Event<void> } & IDisposable => {\n  const evt = new OneShotEvent<void>();\n  if (signal.aborted) {\n    evt.emit();\n    return { event: evt.addListener, dispose: () => {} };\n  }\n\n  const dispose = () => (signal as any).removeEventListener('abort', l);\n\n  // @types/node is currently missing the event types on AbortSignal\n  const l = () => {\n    evt.emit();\n    dispose();\n  };\n\n  (signal as any).addEventListener('abort', l);\n\n  return { event: evt.addListener, dispose };\n};\n\n/**\n * Base event emitter. Calls listeners when data is emitted.\n */\nexport class EventEmitter<T> {\n  protected listeners?: Array<(data: T) => void> | ((data: T) => void);\n\n  /**\n   * Event<T> function.\n   */\n  public readonly addListener: Event<T> = listener => this.addListenerInner(listener);\n\n  /**\n   * Gets the number of event listeners.\n   */\n  public get size() {\n    if (!this.listeners) {\n      return 0;\n    } else if (typeof this.listeners === 'function') {\n      return 1;\n    } else {\n      return this.listeners.length;\n    }\n  }\n\n  /**\n   * Emits event data.\n   */\n  public emit(value: T) {\n    if (!this.listeners) {\n      // no-op\n    } else if (typeof this.listeners === 'function') {\n      this.listeners(value);\n    } else {\n      for (const listener of this.listeners) {\n        listener(value);\n      }\n    }\n  }\n\n  protected addListenerInner(listener: (data: T) => void): IDisposable {\n    if (!this.listeners) {\n      this.listeners = listener;\n    } else if (typeof this.listeners === 'function') {\n      this.listeners = [this.listeners, listener];\n    } else {\n      this.listeners.push(listener);\n    }\n\n    return { dispose: () => this.removeListener(listener) };\n  }\n\n  private removeListener(listener: (data: T) => void) {\n    if (!this.listeners) {\n      return;\n    }\n\n    if (typeof this.listeners === 'function') {\n      if (this.listeners === listener) {\n        this.listeners = undefined;\n      }\n      return;\n    }\n\n    const index = this.listeners.indexOf(listener);\n    if (index === -1) {\n      return;\n    }\n\n    if (this.listeners.length === 2) {\n      this.listeners = index === 0 ? this.listeners[1] : this.listeners[0];\n    } else {\n      this.listeners = this.listeners.slice(0, index).concat(this.listeners.slice(index + 1));\n    }\n  }\n}\n\n/**\n * An event emitter that memorizes and instantly re-emits its last value\n * to attached listeners.\n */\nexport class MemorizingEventEmitter<T> extends EventEmitter<T> {\n  /**\n   * Last emitted value, wrapped in an object so that we can correctly detect\n   * emission of 'undefined' values.\n   */\n  private lastValue?: { value: T };\n\n  /**\n   * Gets whether this emitter has yet emitted any event.\n   */\n  public get hasEmitted() {\n    return !!this.lastValue;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public readonly addListener: Event<T> = listener => {\n    const disposable = this.addListenerInner(listener);\n    if (this.lastValue) {\n      listener(this.lastValue.value);\n    }\n\n    return disposable;\n  };\n\n  /**\n   * @inheritdoc\n   */\n  public emit(value: T) {\n    this.lastValue = { value };\n    super.emit(value);\n  }\n}\n\n/**\n * An event emitter that fires a value once and removes all\n * listeners automatically after doing so.\n */\nclass OneShotEvent<T> extends EventEmitter<T> {\n  /**\n   * Last emitted value, wrapped in an object so that we can correctly detect\n   * emission of 'undefined' values.\n   */\n  private lastValue?: { value: T };\n\n  /**\n   * @inheritdoc\n   */\n  public readonly addListener: Event<T> = listener => {\n    if (this.lastValue) {\n      listener(this.lastValue.value);\n      return noopDisposable;\n    } else {\n      return this.addListenerInner(listener);\n    }\n  };\n\n  /**\n   * @inheritdoc\n   */\n  public emit(value: T) {\n    this.lastValue = { value };\n    super.emit(value);\n    this.listeners = undefined;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"Event.js","sourceRoot":"","sources":["../../src/common/Event.ts"],"names":[],"mappings":"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","sourcesContent":["import { TaskCancelledError } from '../errors/TaskCancelledError';\nimport { AbortSignal } from './LocalAbortController';\n\n/**\n * Type that can be disposed.\n */\nexport interface IDisposable {\n  dispose(): void;\n}\n\nexport const noopDisposable: IDisposable = { dispose: () => undefined };\n\n/**\n * Function that subscribes the method to receive data.\n */\nexport type Event<T> = (listener: (data: T) => void) => IDisposable;\n\nexport namespace Event {\n  /**\n   * Adds a handler that handles one event on the emitter.\n   */\n  export const once = <T>(event: Event<T>, listener: (data: T) => void): IDisposable => {\n    let syncDispose = false;\n    let disposable: IDisposable | void;\n\n    disposable = event(value => {\n      listener(value);\n\n      if (disposable) {\n        disposable.dispose();\n      } else {\n        syncDispose = true; // callback can fire before disposable is returned\n      }\n    });\n\n    if (syncDispose) {\n      disposable.dispose();\n      return noopDisposable; // no reason to keep the ref around\n    }\n\n    return disposable;\n  };\n\n  /**\n   * Returns a promise that resolves when the event fires, or when cancellation\n   * is requested, whichever happens first.\n   */\n  export const toPromise = <T>(event: Event<T>, signal?: AbortSignal): Promise<T> => {\n    if (!signal) {\n      return new Promise<T>(resolve => once(event, resolve));\n    }\n\n    if (signal.aborted) {\n      return Promise.reject(new TaskCancelledError());\n    }\n\n    const toDispose: IDisposable[] = [];\n\n    return new Promise<T>((resolve, reject) => {\n      const abortEvt = onAbort(signal);\n      toDispose.push(abortEvt);\n\n      toDispose.push(\n        abortEvt.event(() => {\n          reject(new TaskCancelledError());\n        }),\n      );\n\n      toDispose.push(\n        once(event, data => {\n          resolve(data);\n        }),\n      );\n    }).finally(() => {\n      for (const d of toDispose) {\n        d.dispose();\n      }\n    });\n  };\n}\n\n/** Creates an Event that fires when the signal is aborted. */\nexport const onAbort = (signal: AbortSignal): { event: Event<unknown> } & IDisposable => {\n  const evt = new OneShotEvent<unknown>();\n  if (signal.aborted) {\n    evt.emit(signal.reason);\n    return { event: evt.addListener, dispose: () => {} };\n  }\n\n  const dispose = () => signal.removeEventListener('abort', l);\n\n  const l = () => {\n    evt.emit(signal.reason);\n    dispose();\n  };\n\n  signal.addEventListener('abort', l);\n\n  return { event: evt.addListener, dispose };\n};\n\n/**\n * Base event emitter. Calls listeners when data is emitted.\n */\nexport class EventEmitter<T> {\n  protected listeners?: Array<(data: T) => void> | ((data: T) => void);\n\n  /**\n   * Event<T> function.\n   */\n  public readonly addListener: Event<T> = listener => this.addListenerInner(listener);\n\n  /**\n   * Gets the number of event listeners.\n   */\n  public get size() {\n    if (!this.listeners) {\n      return 0;\n    } else if (typeof this.listeners === 'function') {\n      return 1;\n    } else {\n      return this.listeners.length;\n    }\n  }\n\n  /**\n   * Emits event data.\n   */\n  public emit(value: T) {\n    if (!this.listeners) {\n      // no-op\n    } else if (typeof this.listeners === 'function') {\n      this.listeners(value);\n    } else {\n      for (const listener of this.listeners) {\n        listener(value);\n      }\n    }\n  }\n\n  protected addListenerInner(listener: (data: T) => void): IDisposable {\n    if (!this.listeners) {\n      this.listeners = listener;\n    } else if (typeof this.listeners === 'function') {\n      this.listeners = [this.listeners, listener];\n    } else {\n      this.listeners.push(listener);\n    }\n\n    return { dispose: () => this.removeListener(listener) };\n  }\n\n  private removeListener(listener: (data: T) => void) {\n    if (!this.listeners) {\n      return;\n    }\n\n    if (typeof this.listeners === 'function') {\n      if (this.listeners === listener) {\n        this.listeners = undefined;\n      }\n      return;\n    }\n\n    const index = this.listeners.indexOf(listener);\n    if (index === -1) {\n      return;\n    }\n\n    if (this.listeners.length === 2) {\n      this.listeners = index === 0 ? this.listeners[1] : this.listeners[0];\n    } else {\n      this.listeners = this.listeners.slice(0, index).concat(this.listeners.slice(index + 1));\n    }\n  }\n}\n\n/**\n * An event emitter that memorizes and instantly re-emits its last value\n * to attached listeners.\n */\nexport class MemorizingEventEmitter<T> extends EventEmitter<T> {\n  /**\n   * Last emitted value, wrapped in an object so that we can correctly detect\n   * emission of 'undefined' values.\n   */\n  private lastValue?: { value: T };\n\n  /**\n   * Gets whether this emitter has yet emitted any event.\n   */\n  public get hasEmitted() {\n    return !!this.lastValue;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public readonly addListener: Event<T> = listener => {\n    const disposable = this.addListenerInner(listener);\n    if (this.lastValue) {\n      listener(this.lastValue.value);\n    }\n\n    return disposable;\n  };\n\n  /**\n   * @inheritdoc\n   */\n  public emit(value: T) {\n    this.lastValue = { value };\n    super.emit(value);\n  }\n}\n\n/**\n * An event emitter that fires a value once and removes all\n * listeners automatically after doing so.\n */\nclass OneShotEvent<T> extends EventEmitter<T> {\n  /**\n   * Last emitted value, wrapped in an object so that we can correctly detect\n   * emission of 'undefined' values.\n   */\n  private lastValue?: { value: T };\n\n  /**\n   * @inheritdoc\n   */\n  public readonly addListener: Event<T> = listener => {\n    if (this.lastValue) {\n      listener(this.lastValue.value);\n      return noopDisposable;\n    } else {\n      return this.addListenerInner(listener);\n    }\n  };\n\n  /**\n   * @inheritdoc\n   */\n  public emit(value: T) {\n    this.lastValue = { value };\n    super.emit(value);\n    this.listeners = undefined;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/Event.test.d.ts b/node_modules/cockatiel/dist/common/Event.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/Event.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/common/Event.test.js b/node_modules/cockatiel/dist/common/Event.test.js
new file mode 100644
index 0000000..1b8f834
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/Event.test.js
@@ -0,0 +1,81 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const sinon_1 = require("sinon");
+const TaskCancelledError_1 = require("../errors/TaskCancelledError");
+const abort_1 = require("./abort");
+const Event_1 = require("./Event");
+const LocalAbortController_1 = require("./LocalAbortController");
+describe('Event', () => {
+    it('emits events', () => {
+        const s1 = (0, sinon_1.stub)();
+        const s2 = (0, sinon_1.stub)();
+        const s3 = (0, sinon_1.stub)();
+        const emitter = new Event_1.EventEmitter();
+        const l1 = emitter.addListener(s1);
+        emitter.emit(1);
+        const l2 = emitter.addListener(s2);
+        emitter.emit(2);
+        const l3 = emitter.addListener(s3);
+        emitter.emit(3);
+        l1.dispose();
+        emitter.emit(4);
+        l2.dispose();
+        emitter.emit(5);
+        l3.dispose();
+        emitter.emit(6);
+        (0, chai_1.expect)(s1.args).to.deep.equal([[1], [2], [3]]);
+        (0, chai_1.expect)(s2.args).to.deep.equal([[2], [3], [4]]);
+        (0, chai_1.expect)(s3.args).to.deep.equal([[3], [4], [5]]);
+    });
+    it('memorizes event emissions', () => {
+        const s1 = (0, sinon_1.stub)();
+        const s2 = (0, sinon_1.stub)();
+        const emitter = new Event_1.MemorizingEventEmitter();
+        (0, chai_1.expect)(emitter.hasEmitted).to.be.false;
+        emitter.addListener(s1);
+        emitter.emit(42);
+        (0, chai_1.expect)(emitter.hasEmitted).to.be.true;
+        emitter.addListener(s2);
+        (0, chai_1.expect)(s1).to.have.been.calledOnceWith(42);
+        (0, chai_1.expect)(s2).to.have.been.calledOnceWith(42);
+    });
+    it('emits events once', () => {
+        const s = (0, sinon_1.stub)();
+        const emitter = new Event_1.EventEmitter();
+        Event_1.Event.once(emitter.addListener, s);
+        emitter.emit(42);
+        emitter.emit(42);
+        (0, chai_1.expect)(s).to.have.been.calledOnceWith(42);
+    });
+    it('emits events once with sync call', () => {
+        const s = (0, sinon_1.stub)();
+        const emitter = new Event_1.MemorizingEventEmitter();
+        emitter.emit(42);
+        Event_1.Event.once(emitter.addListener, s);
+        emitter.emit(42);
+        (0, chai_1.expect)(s).to.have.been.calledOnceWith(42);
+    });
+    it('converts to promise', async () => {
+        const emitter = new Event_1.EventEmitter();
+        const v = Event_1.Event.toPromise(emitter.addListener);
+        emitter.emit(42);
+        (0, chai_1.expect)(await v).to.equal(42);
+        (0, chai_1.expect)(emitter.size).to.equal(0);
+    });
+    it('cancels conversion to promise', async () => {
+        const emitter = new Event_1.EventEmitter();
+        const cts = (0, LocalAbortController_1.createAbortController)();
+        setTimeout(() => cts.abort(), 1);
+        const v = Event_1.Event.toPromise(emitter.addListener, cts.signal);
+        await (0, chai_1.expect)(v).to.eventually.be.rejectedWith(TaskCancelledError_1.TaskCancelledError);
+        (0, chai_1.expect)(emitter.size).to.equal(0);
+    });
+    it('cancels conversion to promise sync', async () => {
+        const emitter = new Event_1.EventEmitter();
+        const v = Event_1.Event.toPromise(emitter.addListener, abort_1.abortedSignal);
+        await (0, chai_1.expect)(v).to.eventually.be.rejectedWith(TaskCancelledError_1.TaskCancelledError);
+        (0, chai_1.expect)(emitter.size).to.equal(0);
+    });
+});
+//# sourceMappingURL=Event.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/Event.test.js.map b/node_modules/cockatiel/dist/common/Event.test.js.map
new file mode 100644
index 0000000..af669ba
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/Event.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Event.test.js","sourceRoot":"","sources":["../../src/common/Event.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from 'chai';\nimport { stub } from 'sinon';\nimport { TaskCancelledError } from '../errors/TaskCancelledError';\nimport { abortedSignal } from './abort';\nimport { Event, EventEmitter, MemorizingEventEmitter } from './Event';\nimport { createAbortController } from './LocalAbortController';\n\ndescribe('Event', () => {\n  it('emits events', () => {\n    const s1 = stub();\n    const s2 = stub();\n    const s3 = stub();\n    const emitter = new EventEmitter<number>();\n\n    const l1 = emitter.addListener(s1);\n    emitter.emit(1);\n    const l2 = emitter.addListener(s2);\n    emitter.emit(2);\n    const l3 = emitter.addListener(s3);\n    emitter.emit(3);\n\n    l1.dispose();\n    emitter.emit(4);\n    l2.dispose();\n    emitter.emit(5);\n    l3.dispose();\n    emitter.emit(6);\n\n    expect(s1.args).to.deep.equal([[1], [2], [3]]);\n    expect(s2.args).to.deep.equal([[2], [3], [4]]);\n    expect(s3.args).to.deep.equal([[3], [4], [5]]);\n  });\n\n  it('memorizes event emissions', () => {\n    const s1 = stub();\n    const s2 = stub();\n    const emitter = new MemorizingEventEmitter<number>();\n    expect(emitter.hasEmitted).to.be.false;\n    emitter.addListener(s1);\n    emitter.emit(42);\n\n    expect(emitter.hasEmitted).to.be.true;\n    emitter.addListener(s2);\n\n    expect(s1).to.have.been.calledOnceWith(42);\n    expect(s2).to.have.been.calledOnceWith(42);\n  });\n\n  it('emits events once', () => {\n    const s = stub();\n    const emitter = new EventEmitter<number>();\n\n    Event.once(emitter.addListener, s);\n    emitter.emit(42);\n    emitter.emit(42);\n\n    expect(s).to.have.been.calledOnceWith(42);\n  });\n\n  it('emits events once with sync call', () => {\n    const s = stub();\n    const emitter = new MemorizingEventEmitter<number>();\n\n    emitter.emit(42);\n    Event.once(emitter.addListener, s);\n    emitter.emit(42);\n\n    expect(s).to.have.been.calledOnceWith(42);\n  });\n\n  it('converts to promise', async () => {\n    const emitter = new EventEmitter<number>();\n    const v = Event.toPromise(emitter.addListener);\n    emitter.emit(42);\n    expect(await v).to.equal(42);\n\n    expect(emitter.size).to.equal(0);\n  });\n\n  it('cancels conversion to promise', async () => {\n    const emitter = new EventEmitter<number>();\n    const cts = createAbortController();\n    setTimeout(() => cts.abort(), 1);\n    const v = Event.toPromise(emitter.addListener, cts.signal);\n    await expect(v).to.eventually.be.rejectedWith(TaskCancelledError);\n    expect(emitter.size).to.equal(0);\n  });\n\n  it('cancels conversion to promise sync', async () => {\n    const emitter = new EventEmitter<number>();\n    const v = Event.toPromise(emitter.addListener, abortedSignal);\n    await expect(v).to.eventually.be.rejectedWith(TaskCancelledError);\n    expect(emitter.size).to.equal(0);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/Executor.test.d.ts b/node_modules/cockatiel/dist/common/Executor.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/Executor.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/common/Executor.test.js b/node_modules/cockatiel/dist/common/Executor.test.js
new file mode 100644
index 0000000..4d4785b
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/Executor.test.js
@@ -0,0 +1,47 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const sinon_1 = require("sinon");
+const Executor_1 = require("./Executor");
+class HandledError extends Error {
+}
+describe('executor', () => {
+    let executor;
+    let onSuccess;
+    let onFailure;
+    beforeEach(() => {
+        executor = new Executor_1.ExecuteWrapper(error => error instanceof HandledError, r => typeof r === 'number' && r % 2 === 0);
+        onSuccess = (0, sinon_1.stub)();
+        onFailure = (0, sinon_1.stub)();
+        executor.onFailure(onFailure);
+        executor.onSuccess(onSuccess);
+    });
+    it('handles successful calls', async () => {
+        const r = await executor.invoke(x => x * 3, 5);
+        (0, chai_1.expect)(r).to.deep.equal({ success: 15 });
+        (0, chai_1.expect)(onSuccess).to.been.calledOnce;
+        (0, chai_1.expect)(onSuccess.args[0][0].duration).to.be.greaterThan(0);
+    });
+    it('deals with handled errors', async () => {
+        const error = new HandledError();
+        const r = await executor.invoke(() => {
+            throw error;
+        });
+        (0, chai_1.expect)(r).to.deep.equal({ error });
+        (0, chai_1.expect)(onFailure).to.been.calledOnce;
+        (0, chai_1.expect)(onFailure.args[0][0].duration).to.be.greaterThan(0);
+        (0, chai_1.expect)(onFailure.args[0][0].handled).to.be.true;
+        (0, chai_1.expect)(onFailure.args[0][0].reason).to.deep.equal({ error });
+    });
+    it('deals with unhandled errors', async () => {
+        const error = new Error();
+        await (0, chai_1.expect)(executor.invoke(() => {
+            throw error;
+        })).to.eventually.be.rejectedWith(error);
+        (0, chai_1.expect)(onFailure).to.been.calledOnce;
+        (0, chai_1.expect)(onFailure.args[0][0].duration).to.be.greaterThan(0);
+        (0, chai_1.expect)(onFailure.args[0][0].handled).to.be.false;
+        (0, chai_1.expect)(onFailure.args[0][0].reason).to.deep.equal({ error });
+    });
+});
+//# sourceMappingURL=Executor.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/Executor.test.js.map b/node_modules/cockatiel/dist/common/Executor.test.js.map
new file mode 100644
index 0000000..77cfdda
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/Executor.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Executor.test.js","sourceRoot":"","sources":["../../src/common/Executor.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from 'chai';\nimport { SinonStub, stub } from 'sinon';\nimport { ExecuteWrapper } from './Executor';\n\nclass HandledError extends Error {}\n\ndescribe('executor', () => {\n  let executor: ExecuteWrapper;\n  let onSuccess: SinonStub;\n  let onFailure: SinonStub;\n\n  beforeEach(() => {\n    executor = new ExecuteWrapper(\n      error => error instanceof HandledError,\n      r => typeof r === 'number' && r % 2 === 0,\n    );\n    onSuccess = stub();\n    onFailure = stub();\n    executor.onFailure(onFailure);\n    executor.onSuccess(onSuccess);\n  });\n\n  it('handles successful calls', async () => {\n    const r = await executor.invoke(x => x * 3, 5);\n    expect(r).to.deep.equal({ success: 15 });\n    expect(onSuccess).to.been.calledOnce;\n    expect(onSuccess.args[0][0].duration).to.be.greaterThan(0);\n  });\n\n  it('deals with handled errors', async () => {\n    const error = new HandledError();\n    const r = await executor.invoke(() => {\n      throw error;\n    });\n    expect(r).to.deep.equal({ error });\n    expect(onFailure).to.been.calledOnce;\n    expect(onFailure.args[0][0].duration).to.be.greaterThan(0);\n    expect(onFailure.args[0][0].handled).to.be.true;\n    expect(onFailure.args[0][0].reason).to.deep.equal({ error });\n  });\n\n  it('deals with unhandled errors', async () => {\n    const error = new Error();\n    await expect(\n      executor.invoke(() => {\n        throw error;\n      }),\n    ).to.eventually.be.rejectedWith(error);\n\n    expect(onFailure).to.been.calledOnce;\n    expect(onFailure.args[0][0].duration).to.be.greaterThan(0);\n    expect(onFailure.args[0][0].handled).to.be.false;\n    expect(onFailure.args[0][0].reason).to.deep.equal({ error });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/LocalAbortController.d.ts b/node_modules/cockatiel/dist/common/LocalAbortController.d.ts
new file mode 100644
index 0000000..1d10f51
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/LocalAbortController.d.ts
@@ -0,0 +1,23 @@
+/**
+ * Localized AbortController and AbortSignal implementation for Cloudflare Workers compatibility.
+ * This provides the essential functionality needed by cockatiel without relying on native APIs.
+ */
+export interface LocalAbortSignal {
+    readonly aborted: boolean;
+    readonly reason: any;
+    addEventListener(type: 'abort', listener: (this: LocalAbortSignal, ev: any) => any): void;
+    removeEventListener(type: 'abort', listener: (this: LocalAbortSignal, ev: any) => any): void;
+}
+export interface LocalAbortController {
+    readonly signal: LocalAbortSignal;
+    abort(reason?: any): void;
+}
+/**
+ * Creates a new AbortController that works in Cloudflare Workers.
+ */
+export declare const createAbortController: () => LocalAbortController;
+/**
+ * Type alias to maintain compatibility with existing code.
+ */
+export type AbortController = LocalAbortController;
+export type AbortSignal = LocalAbortSignal;
diff --git a/node_modules/cockatiel/dist/common/LocalAbortController.js b/node_modules/cockatiel/dist/common/LocalAbortController.js
new file mode 100644
index 0000000..323cd0a
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/LocalAbortController.js
@@ -0,0 +1,75 @@
+"use strict";
+/**
+ * Localized AbortController and AbortSignal implementation for Cloudflare Workers compatibility.
+ * This provides the essential functionality needed by cockatiel without relying on native APIs.
+ */
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.createAbortController = void 0;
+class LocalAbortSignalImpl {
+    constructor() {
+        this._aborted = false;
+        this._reason = undefined;
+        this._listeners = new Set();
+    }
+    get aborted() {
+        return this._aborted;
+    }
+    get reason() {
+        return this._reason;
+    }
+    addEventListener(type, listener) {
+        if (type === 'abort') {
+            this._listeners.add(listener);
+            // If already aborted, fire the listener immediately
+            if (this._aborted) {
+                try {
+                    listener.call(this, { type: 'abort', target: this });
+                }
+                catch (error) {
+                    // Ignore listener errors to match native behavior
+                }
+            }
+        }
+    }
+    removeEventListener(type, listener) {
+        if (type === 'abort') {
+            this._listeners.delete(listener);
+        }
+    }
+    _abort(reason) {
+        if (this._aborted) {
+            return; // Already aborted, ignore subsequent calls
+        }
+        this._aborted = true;
+        this._reason = reason;
+        // Fire all listeners
+        const event = { type: 'abort', target: this };
+        for (const listener of this._listeners) {
+            try {
+                listener.call(this, event);
+            }
+            catch (error) {
+                // Ignore listener errors to match native behavior
+            }
+        }
+    }
+}
+class LocalAbortControllerImpl {
+    constructor() {
+        this._signal = new LocalAbortSignalImpl();
+    }
+    get signal() {
+        return this._signal;
+    }
+    abort(reason) {
+        this._signal._abort(reason);
+    }
+}
+/**
+ * Creates a new AbortController that works in Cloudflare Workers.
+ */
+const createAbortController = () => {
+    return new LocalAbortControllerImpl();
+};
+exports.createAbortController = createAbortController;
+//# sourceMappingURL=LocalAbortController.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/LocalAbortController.js.map b/node_modules/cockatiel/dist/common/LocalAbortController.js.map
new file mode 100644
index 0000000..f96670f
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/LocalAbortController.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"LocalAbortController.js","sourceRoot":"","sources":["../../src/common/LocalAbortController.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AAcH,MAAM,oBAAoB;IAA1B;QACU,aAAQ,GAAG,KAAK,CAAC;QACjB,YAAO,GAAQ,SAAS,CAAC;QACzB,eAAU,GAAkD,IAAI,GAAG,EAAE,CAAC;IAgDhF,CAAC;IA9CC,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED,gBAAgB,CAAC,IAAa,EAAE,QAAkD;QAChF,IAAI,IAAI,KAAK,OAAO,EAAE,CAAC;YACrB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC9B,oDAAoD;YACpD,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClB,IAAI,CAAC;oBACH,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;gBACvD,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,kDAAkD;gBACpD,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,mBAAmB,CAAC,IAAa,EAAE,QAAkD;QACnF,IAAI,IAAI,KAAK,OAAO,EAAE,CAAC;YACrB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAED,MAAM,CAAC,MAAY;QACjB,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,OAAO,CAAC,2CAA2C;QACrD,CAAC;QAED,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QAEtB,qBAAqB;QACrB,MAAM,KAAK,GAAG,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC;QAC9C,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACvC,IAAI,CAAC;gBACH,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC7B,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,kDAAkD;YACpD,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAED,MAAM,wBAAwB;IAG5B;QACE,IAAI,CAAC,OAAO,GAAG,IAAI,oBAAoB,EAAE,CAAC;IAC5C,CAAC;IAED,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,MAAY;QAChB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAC9B,CAAC;CACF;AAED;;GAEG;AACI,MAAM,qBAAqB,GAAG,GAAyB,EAAE;IAC9D,OAAO,IAAI,wBAAwB,EAAE,CAAC;AACxC,CAAC,CAAC;AAFW,QAAA,qBAAqB,yBAEhC","sourcesContent":["/**\n * Localized AbortController and AbortSignal implementation for Cloudflare Workers compatibility.\n * This provides the essential functionality needed by cockatiel without relying on native APIs.\n */\n\nexport interface LocalAbortSignal {\n  readonly aborted: boolean;\n  readonly reason: any;\n  addEventListener(type: 'abort', listener: (this: LocalAbortSignal, ev: any) => any): void;\n  removeEventListener(type: 'abort', listener: (this: LocalAbortSignal, ev: any) => any): void;\n}\n\nexport interface LocalAbortController {\n  readonly signal: LocalAbortSignal;\n  abort(reason?: any): void;\n}\n\nclass LocalAbortSignalImpl implements LocalAbortSignal {\n  private _aborted = false;\n  private _reason: any = undefined;\n  private _listeners: Set<(this: LocalAbortSignal, ev: any) => any> = new Set();\n\n  get aborted(): boolean {\n    return this._aborted;\n  }\n\n  get reason(): any {\n    return this._reason;\n  }\n\n  addEventListener(type: 'abort', listener: (this: LocalAbortSignal, ev: any) => any): void {\n    if (type === 'abort') {\n      this._listeners.add(listener);\n      // If already aborted, fire the listener immediately\n      if (this._aborted) {\n        try {\n          listener.call(this, { type: 'abort', target: this });\n        } catch (error) {\n          // Ignore listener errors to match native behavior\n        }\n      }\n    }\n  }\n\n  removeEventListener(type: 'abort', listener: (this: LocalAbortSignal, ev: any) => any): void {\n    if (type === 'abort') {\n      this._listeners.delete(listener);\n    }\n  }\n\n  _abort(reason?: any): void {\n    if (this._aborted) {\n      return; // Already aborted, ignore subsequent calls\n    }\n\n    this._aborted = true;\n    this._reason = reason;\n\n    // Fire all listeners\n    const event = { type: 'abort', target: this };\n    for (const listener of this._listeners) {\n      try {\n        listener.call(this, event);\n      } catch (error) {\n        // Ignore listener errors to match native behavior\n      }\n    }\n  }\n}\n\nclass LocalAbortControllerImpl implements LocalAbortController {\n  private _signal: LocalAbortSignalImpl;\n\n  constructor() {\n    this._signal = new LocalAbortSignalImpl();\n  }\n\n  get signal(): LocalAbortSignal {\n    return this._signal;\n  }\n\n  abort(reason?: any): void {\n    this._signal._abort(reason);\n  }\n}\n\n/**\n * Creates a new AbortController that works in Cloudflare Workers.\n */\nexport const createAbortController = (): LocalAbortController => {\n  return new LocalAbortControllerImpl();\n};\n\n/**\n * Type alias to maintain compatibility with existing code.\n */\nexport type AbortController = LocalAbortController;\nexport type AbortSignal = LocalAbortSignal;"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/abort.d.ts b/node_modules/cockatiel/dist/common/abort.d.ts
index fb20c21..9da722a 100644
--- a/node_modules/cockatiel/dist/common/abort.d.ts
+++ b/node_modules/cockatiel/dist/common/abort.d.ts
@@ -1,6 +1,7 @@
 import { IDisposable } from './Event';
-export declare const neverAbortedSignal: AbortSignal;
-export declare const abortedSignal: AbortSignal;
+import { AbortController, AbortSignal } from './LocalAbortController';
+export declare const neverAbortedSignal: import("./LocalAbortController").LocalAbortSignal;
+export declare const abortedSignal: import("./LocalAbortController").LocalAbortSignal;
 /**
  * Creates a new AbortController that is aborted when the parent signal aborts.
  * @private
diff --git a/node_modules/cockatiel/dist/common/abort.js b/node_modules/cockatiel/dist/common/abort.js
index 8047990..691a671 100644
--- a/node_modules/cockatiel/dist/common/abort.js
+++ b/node_modules/cockatiel/dist/common/abort.js
@@ -2,8 +2,9 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.deriveAbortController = exports.abortedSignal = exports.neverAbortedSignal = void 0;
 const Event_1 = require("./Event");
-exports.neverAbortedSignal = new AbortController().signal;
-const cancelledSrc = new AbortController();
+const LocalAbortController_1 = require("./LocalAbortController");
+exports.neverAbortedSignal = (0, LocalAbortController_1.createAbortController)().signal;
+const cancelledSrc = (0, LocalAbortController_1.createAbortController)();
 cancelledSrc.abort();
 exports.abortedSignal = cancelledSrc.signal;
 const noop = () => { };
@@ -12,17 +13,17 @@ const noop = () => { };
  * @private
  */
 const deriveAbortController = (signal) => {
-    const ctrl = new AbortController();
+    const ctrl = (0, LocalAbortController_1.createAbortController)();
     let dispose = noop;
     if (!signal) {
         return { ctrl, dispose };
     }
     if (signal.aborted) {
-        ctrl.abort();
+        ctrl.abort(signal.reason);
     }
     else {
         const abortEvt = (0, Event_1.onAbort)(signal);
-        abortEvt.event(() => ctrl.abort());
+        abortEvt.event(reason => ctrl.abort(reason));
         dispose = abortEvt.dispose;
     }
     return { ctrl, dispose };
diff --git a/node_modules/cockatiel/dist/common/abort.js.map b/node_modules/cockatiel/dist/common/abort.js.map
index ec141a6..29d0a4b 100644
--- a/node_modules/cockatiel/dist/common/abort.js.map
+++ b/node_modules/cockatiel/dist/common/abort.js.map
@@ -1 +1 @@
-{"version":3,"file":"abort.js","sourceRoot":"","sources":["../../src/common/abort.ts"],"names":[],"mappings":";;;AAAA,mCAA+C;AAElC,QAAA,kBAAkB,GAAG,IAAI,eAAe,EAAE,CAAC,MAAM,CAAC;AAE/D,MAAM,YAAY,GAAG,IAAI,eAAe,EAAE,CAAC;AAC3C,YAAY,CAAC,KAAK,EAAE,CAAC;AACR,QAAA,aAAa,GAAG,YAAY,CAAC,MAAM,CAAC;AAEjD,MAAM,IAAI,GAAe,GAAG,EAAE,GAAE,CAAC,CAAC;AAElC;;;GAGG;AACI,MAAM,qBAAqB,GAAG,CACnC,MAAoB,EACqB,EAAE;IAC3C,MAAM,IAAI,GAAG,IAAI,eAAe,EAAE,CAAC;IACnC,IAAI,OAAO,GAAe,IAAI,CAAC;IAC/B,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;QACnB,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;SAAM,CAAC;QACN,MAAM,QAAQ,GAAG,IAAA,eAAO,EAAC,MAAM,CAAC,CAAC;QACjC,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;QACnC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IAC7B,CAAC;IAED,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;AAC3B,CAAC,CAAC;AAlBW,QAAA,qBAAqB,yBAkBhC","sourcesContent":["import { IDisposable, onAbort } from './Event';\n\nexport const neverAbortedSignal = new AbortController().signal;\n\nconst cancelledSrc = new AbortController();\ncancelledSrc.abort();\nexport const abortedSignal = cancelledSrc.signal;\n\nconst noop: () => void = () => {};\n\n/**\n * Creates a new AbortController that is aborted when the parent signal aborts.\n * @private\n */\nexport const deriveAbortController = (\n  signal?: AbortSignal,\n): { ctrl: AbortController } & IDisposable => {\n  const ctrl = new AbortController();\n  let dispose: () => void = noop;\n  if (!signal) {\n    return { ctrl, dispose };\n  }\n\n  if (signal.aborted) {\n    ctrl.abort();\n  } else {\n    const abortEvt = onAbort(signal);\n    abortEvt.event(() => ctrl.abort());\n    dispose = abortEvt.dispose;\n  }\n\n  return { ctrl, dispose };\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"abort.js","sourceRoot":"","sources":["../../src/common/abort.ts"],"names":[],"mappings":";;;AAAA,mCAA+C;AAC/C,iEAA6F;AAEhF,QAAA,kBAAkB,GAAG,IAAA,4CAAqB,GAAE,CAAC,MAAM,CAAC;AAEjE,MAAM,YAAY,GAAG,IAAA,4CAAqB,GAAE,CAAC;AAC7C,YAAY,CAAC,KAAK,EAAE,CAAC;AACR,QAAA,aAAa,GAAG,YAAY,CAAC,MAAM,CAAC;AAEjD,MAAM,IAAI,GAAe,GAAG,EAAE,GAAE,CAAC,CAAC;AAElC;;;GAGG;AACI,MAAM,qBAAqB,GAAG,CACnC,MAAoB,EACqB,EAAE;IAC3C,MAAM,IAAI,GAAG,IAAA,4CAAqB,GAAE,CAAC;IACrC,IAAI,OAAO,GAAe,IAAI,CAAC;IAC/B,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;QACnB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAC5B,CAAC;SAAM,CAAC;QACN,MAAM,QAAQ,GAAG,IAAA,eAAO,EAAC,MAAM,CAAC,CAAC;QACjC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QAC7C,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IAC7B,CAAC;IAED,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;AAC3B,CAAC,CAAC;AAlBW,QAAA,qBAAqB,yBAkBhC","sourcesContent":["import { IDisposable, onAbort } from './Event';\nimport { createAbortController, AbortController, AbortSignal } from './LocalAbortController';\n\nexport const neverAbortedSignal = createAbortController().signal;\n\nconst cancelledSrc = createAbortController();\ncancelledSrc.abort();\nexport const abortedSignal = cancelledSrc.signal;\n\nconst noop: () => void = () => {};\n\n/**\n * Creates a new AbortController that is aborted when the parent signal aborts.\n * @private\n */\nexport const deriveAbortController = (\n  signal?: AbortSignal,\n): { ctrl: AbortController } & IDisposable => {\n  const ctrl = createAbortController();\n  let dispose: () => void = noop;\n  if (!signal) {\n    return { ctrl, dispose };\n  }\n\n  if (signal.aborted) {\n    ctrl.abort(signal.reason);\n  } else {\n    const abortEvt = onAbort(signal);\n    abortEvt.event(reason => ctrl.abort(reason));\n    dispose = abortEvt.dispose;\n  }\n\n  return { ctrl, dispose };\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/abort.test.d.ts b/node_modules/cockatiel/dist/common/abort.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/abort.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/common/abort.test.js b/node_modules/cockatiel/dist/common/abort.test.js
new file mode 100644
index 0000000..e72cc15
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/abort.test.js
@@ -0,0 +1,23 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const abort_1 = require("./abort");
+const LocalAbortController_1 = require("./LocalAbortController");
+describe('deriveAbortController', () => {
+    it('should return an aborted AbortController when the provided signal is already aborted', () => {
+        const parentCtrl = (0, LocalAbortController_1.createAbortController)();
+        parentCtrl.abort(new Error('asdf'));
+        const { ctrl } = (0, abort_1.deriveAbortController)(parentCtrl.signal);
+        (0, chai_1.expect)(ctrl.signal.aborted).to.be.true;
+        (0, chai_1.expect)(ctrl.signal.reason).to.equal(parentCtrl.signal.reason);
+    });
+    it('should abort the new AbortController when the provided signal aborts', () => {
+        const parentCtrl = (0, LocalAbortController_1.createAbortController)();
+        const { ctrl } = (0, abort_1.deriveAbortController)(parentCtrl.signal);
+        (0, chai_1.expect)(ctrl.signal.aborted).to.be.false;
+        parentCtrl.abort(new Error('asdf'));
+        (0, chai_1.expect)(ctrl.signal.aborted).to.be.true;
+        (0, chai_1.expect)(ctrl.signal.reason).to.equal(parentCtrl.signal.reason);
+    });
+});
+//# sourceMappingURL=abort.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/abort.test.js.map b/node_modules/cockatiel/dist/common/abort.test.js.map
new file mode 100644
index 0000000..c2efaa2
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/abort.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"abort.test.js","sourceRoot":"","sources":["../../src/common/abort.test.ts"],"names":[],"mappings":";;AAAA,+BAA8B;AAC9B,mCAAgD;AAChD,iEAA+D;AAE/D,QAAQ,CAAC,uBAAuB,EAAE,GAAG,EAAE;IACrC,EAAE,CAAC,sFAAsF,EAAE,GAAG,EAAE;QAC9F,MAAM,UAAU,GAAG,IAAA,4CAAqB,GAAE,CAAC;QAC3C,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QACpC,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,6BAAqB,EAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAC1D,IAAA,aAAM,EAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;QACvC,IAAA,aAAM,EAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAChE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,sEAAsE,EAAE,GAAG,EAAE;QAC9E,MAAM,UAAU,GAAG,IAAA,4CAAqB,GAAE,CAAC;QAC3C,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,6BAAqB,EAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAC1D,IAAA,aAAM,EAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC;QACxC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QACpC,IAAA,aAAM,EAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;QACvC,IAAA,aAAM,EAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAChE,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { expect } from 'chai';\nimport { deriveAbortController } from './abort';\nimport { createAbortController } from './LocalAbortController';\n\ndescribe('deriveAbortController', () => {\n  it('should return an aborted AbortController when the provided signal is already aborted', () => {\n    const parentCtrl = createAbortController();\n    parentCtrl.abort(new Error('asdf'));\n    const { ctrl } = deriveAbortController(parentCtrl.signal);\n    expect(ctrl.signal.aborted).to.be.true;\n    expect(ctrl.signal.reason).to.equal(parentCtrl.signal.reason);\n  });\n\n  it('should abort the new AbortController when the provided signal aborts', () => {\n    const parentCtrl = createAbortController();\n    const { ctrl } = deriveAbortController(parentCtrl.signal);\n    expect(ctrl.signal.aborted).to.be.false;\n    parentCtrl.abort(new Error('asdf'));\n    expect(ctrl.signal.aborted).to.be.true;\n    expect(ctrl.signal.reason).to.equal(parentCtrl.signal.reason);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/util.test.d.ts b/node_modules/cockatiel/dist/common/util.test.d.ts
new file mode 100644
index 0000000..fb77e89
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/util.test.d.ts
@@ -0,0 +1,4 @@
+/**
+ * Runs the code in a child process, and returns its stdout/err string.
+ */
+export declare function runInChild(code: string): Promise<string>;
diff --git a/node_modules/cockatiel/dist/common/util.test.js b/node_modules/cockatiel/dist/common/util.test.js
new file mode 100644
index 0000000..9244083
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/util.test.js
@@ -0,0 +1,25 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.runInChild = runInChild;
+const child_process_1 = require("child_process");
+const fs_1 = require("fs");
+const path = require("path");
+/**
+ * Runs the code in a child process, and returns its stdout/err string.
+ */
+async function runInChild(code) {
+    const cwd = path.resolve(__dirname, '..', '..');
+    const file = path.resolve(cwd, '.test.js');
+    after(done => (0, fs_1.unlink)(file, () => done()));
+    (0, fs_1.writeFileSync)(file, `const c = require('./');\n${code}`);
+    const child = (0, child_process_1.fork)(file, [], { cwd, stdio: 'pipe' });
+    const output = [];
+    child.stderr?.on('data', d => output.push(d));
+    child.stdout?.on('data', d => output.push(d));
+    await new Promise((resolve, reject) => {
+        child.on('error', reject);
+        child.on('exit', resolve);
+    });
+    return Buffer.concat(output).toString().replace(/\r?\n/g, '\n').trim();
+}
+//# sourceMappingURL=util.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/common/util.test.js.map b/node_modules/cockatiel/dist/common/util.test.js.map
new file mode 100644
index 0000000..dfded5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/common/util.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"util.test.js","sourceRoot":"","sources":["../../src/common/util.test.ts"],"names":[],"mappings":";;AAOA,gCAmBC;AA1BD,iDAAqC;AACrC,2BAA2C;AAC3C,6BAA6B;AAE7B;;GAEG;AACI,KAAK,UAAU,UAAU,CAAC,IAAY;IAC3C,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAChD,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;IAE3C,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAA,WAAM,EAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IAE1C,IAAA,kBAAa,EAAC,IAAI,EAAE,6BAA6B,IAAI,EAAE,CAAC,CAAC;IAEzD,MAAM,KAAK,GAAG,IAAA,oBAAI,EAAC,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,CAAC;IACrD,MAAM,MAAM,GAAa,EAAE,CAAC;IAC5B,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9C,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAE9C,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACpC,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAC1B,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;AACzE,CAAC","sourcesContent":["import { fork } from 'child_process';\nimport { unlink, writeFileSync } from 'fs';\nimport * as path from 'path';\n\n/**\n * Runs the code in a child process, and returns its stdout/err string.\n */\nexport async function runInChild(code: string) {\n  const cwd = path.resolve(__dirname, '..', '..');\n  const file = path.resolve(cwd, '.test.js');\n\n  after(done => unlink(file, () => done()));\n\n  writeFileSync(file, `const c = require('./');\\n${code}`);\n\n  const child = fork(file, [], { cwd, stdio: 'pipe' });\n  const output: Buffer[] = [];\n  child.stderr?.on('data', d => output.push(d));\n  child.stdout?.on('data', d => output.push(d));\n\n  await new Promise((resolve, reject) => {\n    child.on('error', reject);\n    child.on('exit', resolve);\n  });\n\n  return Buffer.concat(output).toString().replace(/\\r?\\n/g, '\\n').trim();\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/errors/Errors.js b/node_modules/cockatiel/dist/errors/Errors.js
index 324e0c0..f8a5882 100644
--- a/node_modules/cockatiel/dist/errors/Errors.js
+++ b/node_modules/cockatiel/dist/errors/Errors.js
@@ -24,9 +24,9 @@ const isBrokenCircuitError = (e) => !!e && e instanceof Error && 'isBrokenCircui
 exports.isBrokenCircuitError = isBrokenCircuitError;
 const isBulkheadRejectedError = (e) => !!e && e instanceof Error && 'isBulkheadRejectedError' in e;
 exports.isBulkheadRejectedError = isBulkheadRejectedError;
-const isIsolatedCircuitError = (e) => !!e && e instanceof Error && 'isBulkheadRejectedError' in e;
+const isIsolatedCircuitError = (e) => !!e && e instanceof Error && 'isIsolatedCircuitError' in e;
 exports.isIsolatedCircuitError = isIsolatedCircuitError;
-const isTaskCancelledError = (e) => !!e && e instanceof Error && 'isBulkheadRejectedError' in e;
+const isTaskCancelledError = (e) => !!e && e instanceof Error && 'isTaskCancelledError' in e;
 exports.isTaskCancelledError = isTaskCancelledError;
 const isHydratingCircuitError = (e) => !!e && e instanceof Error && 'isHydratingCircuitError' in e;
 exports.isHydratingCircuitError = isHydratingCircuitError;
diff --git a/node_modules/cockatiel/dist/errors/Errors.js.map b/node_modules/cockatiel/dist/errors/Errors.js.map
index e2e0421..ba45c3e 100644
--- a/node_modules/cockatiel/dist/errors/Errors.js.map
+++ b/node_modules/cockatiel/dist/errors/Errors.js.map
@@ -1 +1 @@
-{"version":3,"file":"Errors.js","sourceRoot":"","sources":["../../src/errors/Errors.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAMA,uDAAqC;AACrC,0DAAwC;AACxC,0DAAwC;AACxC,yDAAuC;AACvC,uDAAqC;AAE9B,MAAM,oBAAoB,GAAG,CAAC,CAAU,EAA2B,EAAE,CAC1E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,sBAAsB,IAAI,CAAC,CAAC;AAD9C,QAAA,oBAAoB,wBAC0B;AAEpD,MAAM,uBAAuB,GAAG,CAAC,CAAU,EAA8B,EAAE,CAChF,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AADjD,QAAA,uBAAuB,2BAC0B;AAEvD,MAAM,sBAAsB,GAAG,CAAC,CAAU,EAA6B,EAAE,CAC9E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AADjD,QAAA,sBAAsB,0BAC2B;AAEvD,MAAM,oBAAoB,GAAG,CAAC,CAAU,EAA2B,EAAE,CAC1E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AADjD,QAAA,oBAAoB,wBAC6B;AAEvD,MAAM,uBAAuB,GAAG,CAAC,CAAU,EAA8B,EAAE,CAChF,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AADjD,QAAA,uBAAuB,2BAC0B","sourcesContent":["import { BrokenCircuitError } from './BrokenCircuitError';\nimport { BulkheadRejectedError } from './BulkheadRejectedError';\nimport { HydratingCircuitError } from './HydratingCircuitError';\nimport { IsolatedCircuitError } from './IsolatedCircuitError';\nimport { TaskCancelledError } from './TaskCancelledError';\n\nexport * from './BrokenCircuitError';\nexport * from './BulkheadRejectedError';\nexport * from './HydratingCircuitError';\nexport * from './IsolatedCircuitError';\nexport * from './TaskCancelledError';\n\nexport const isBrokenCircuitError = (e: unknown): e is BrokenCircuitError =>\n  !!e && e instanceof Error && 'isBrokenCircuitError' in e;\n\nexport const isBulkheadRejectedError = (e: unknown): e is BulkheadRejectedError =>\n  !!e && e instanceof Error && 'isBulkheadRejectedError' in e;\n\nexport const isIsolatedCircuitError = (e: unknown): e is IsolatedCircuitError =>\n  !!e && e instanceof Error && 'isBulkheadRejectedError' in e;\n\nexport const isTaskCancelledError = (e: unknown): e is TaskCancelledError =>\n  !!e && e instanceof Error && 'isBulkheadRejectedError' in e;\n\nexport const isHydratingCircuitError = (e: unknown): e is HydratingCircuitError =>\n  !!e && e instanceof Error && 'isHydratingCircuitError' in e;\n"]}
\ No newline at end of file
+{"version":3,"file":"Errors.js","sourceRoot":"","sources":["../../src/errors/Errors.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAMA,uDAAqC;AACrC,0DAAwC;AACxC,0DAAwC;AACxC,yDAAuC;AACvC,uDAAqC;AAE9B,MAAM,oBAAoB,GAAG,CAAC,CAAU,EAA2B,EAAE,CAC1E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,sBAAsB,IAAI,CAAC,CAAC;AAD9C,QAAA,oBAAoB,wBAC0B;AAEpD,MAAM,uBAAuB,GAAG,CAAC,CAAU,EAA8B,EAAE,CAChF,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AADjD,QAAA,uBAAuB,2BAC0B;AAEvD,MAAM,sBAAsB,GAAG,CAAC,CAAU,EAA6B,EAAE,CAC9E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,wBAAwB,IAAI,CAAC,CAAC;AADhD,QAAA,sBAAsB,0BAC0B;AAEtD,MAAM,oBAAoB,GAAG,CAAC,CAAU,EAA2B,EAAE,CAC1E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,sBAAsB,IAAI,CAAC,CAAC;AAD9C,QAAA,oBAAoB,wBAC0B;AAEpD,MAAM,uBAAuB,GAAG,CAAC,CAAU,EAA8B,EAAE,CAChF,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AADjD,QAAA,uBAAuB,2BAC0B","sourcesContent":["import { BrokenCircuitError } from './BrokenCircuitError';\nimport { BulkheadRejectedError } from './BulkheadRejectedError';\nimport { HydratingCircuitError } from './HydratingCircuitError';\nimport { IsolatedCircuitError } from './IsolatedCircuitError';\nimport { TaskCancelledError } from './TaskCancelledError';\n\nexport * from './BrokenCircuitError';\nexport * from './BulkheadRejectedError';\nexport * from './HydratingCircuitError';\nexport * from './IsolatedCircuitError';\nexport * from './TaskCancelledError';\n\nexport const isBrokenCircuitError = (e: unknown): e is BrokenCircuitError =>\n  !!e && e instanceof Error && 'isBrokenCircuitError' in e;\n\nexport const isBulkheadRejectedError = (e: unknown): e is BulkheadRejectedError =>\n  !!e && e instanceof Error && 'isBulkheadRejectedError' in e;\n\nexport const isIsolatedCircuitError = (e: unknown): e is IsolatedCircuitError =>\n  !!e && e instanceof Error && 'isIsolatedCircuitError' in e;\n\nexport const isTaskCancelledError = (e: unknown): e is TaskCancelledError =>\n  !!e && e instanceof Error && 'isTaskCancelledError' in e;\n\nexport const isHydratingCircuitError = (e: unknown): e is HydratingCircuitError =>\n  !!e && e instanceof Error && 'isHydratingCircuitError' in e;\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/errors/Errors.test.d.ts b/node_modules/cockatiel/dist/errors/Errors.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/cockatiel/dist/errors/Errors.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/cockatiel/dist/errors/Errors.test.js b/node_modules/cockatiel/dist/errors/Errors.test.js
new file mode 100644
index 0000000..a11a7dc
--- /dev/null
+++ b/node_modules/cockatiel/dist/errors/Errors.test.js
@@ -0,0 +1,102 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const chai_1 = require("chai");
+const BrokenCircuitError_1 = require("./BrokenCircuitError");
+const BulkheadRejectedError_1 = require("./BulkheadRejectedError");
+const Errors_1 = require("./Errors");
+const HydratingCircuitError_1 = require("./HydratingCircuitError");
+const IsolatedCircuitError_1 = require("./IsolatedCircuitError");
+const TaskCancelledError_1 = require("./TaskCancelledError");
+describe('Errors', () => {
+    describe('isBrokenCircuitError', () => {
+        const error = new BrokenCircuitError_1.BrokenCircuitError();
+        it('returns true for an instance of BrokenCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBrokenCircuitError)(error)).to.be.true;
+        });
+        it('returns true for an instance of IsolatedCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBrokenCircuitError)(new IsolatedCircuitError_1.IsolatedCircuitError())).to.be.true;
+        });
+        it('returns false for an instance of BulkheadRejectedError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBrokenCircuitError)(new BulkheadRejectedError_1.BulkheadRejectedError(0, 0))).to.be.false;
+        });
+        it('returns false for an instance of TaskCancelledError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBrokenCircuitError)(new TaskCancelledError_1.TaskCancelledError())).to.be.false;
+        });
+        it('returns false for an instance of HydratingCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBrokenCircuitError)(new HydratingCircuitError_1.HydratingCircuitError())).to.be.false;
+        });
+    });
+    describe('BulkheadRejectedError', () => {
+        const error = new BulkheadRejectedError_1.BulkheadRejectedError(0, 0);
+        it('returns true for an instance of BulkheadRejectedError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBulkheadRejectedError)(error)).to.be.true;
+        });
+        it('returns false for an instance of BrokenCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBulkheadRejectedError)(new BrokenCircuitError_1.BrokenCircuitError())).to.be.false;
+        });
+        it('returns false for an instance of IsolatedCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBulkheadRejectedError)(new IsolatedCircuitError_1.IsolatedCircuitError())).to.be.false;
+        });
+        it('returns false for an instance of TaskCancelledError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBulkheadRejectedError)(new TaskCancelledError_1.TaskCancelledError())).to.be.false;
+        });
+        it('returns false for an instance of HydratingCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isBulkheadRejectedError)(new HydratingCircuitError_1.HydratingCircuitError())).to.be.false;
+        });
+    });
+    describe('IsolatedCircuitError', () => {
+        const error = new IsolatedCircuitError_1.IsolatedCircuitError();
+        it('returns true for an instance of IsolatedCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isIsolatedCircuitError)(error)).to.be.true;
+        });
+        it('returns false for an instance of BrokenCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isIsolatedCircuitError)(new BrokenCircuitError_1.BrokenCircuitError())).to.be.false;
+        });
+        it('returns false for an instance of BulkheadRejectedError', () => {
+            (0, chai_1.expect)((0, Errors_1.isIsolatedCircuitError)(new BulkheadRejectedError_1.BulkheadRejectedError(0, 0))).to.be.false;
+        });
+        it('returns false for an instance of TaskCancelledError', () => {
+            (0, chai_1.expect)((0, Errors_1.isIsolatedCircuitError)(new TaskCancelledError_1.TaskCancelledError())).to.be.false;
+        });
+        it('returns false for an instance of HydratingCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isIsolatedCircuitError)(new HydratingCircuitError_1.HydratingCircuitError())).to.be.false;
+        });
+    });
+    describe('TaskCancelledError', () => {
+        const error = new TaskCancelledError_1.TaskCancelledError();
+        it('returns true for an instance of TaskCancelledError', () => {
+            (0, chai_1.expect)((0, Errors_1.isTaskCancelledError)(error)).to.be.true;
+        });
+        it('returns false for an instance of BrokenCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isTaskCancelledError)(new BrokenCircuitError_1.BrokenCircuitError())).to.be.false;
+        });
+        it('returns false for an instance of BulkheadRejectedError', () => {
+            (0, chai_1.expect)((0, Errors_1.isTaskCancelledError)(new BulkheadRejectedError_1.BulkheadRejectedError(0, 0))).to.be.false;
+        });
+        it('returns false for an instance of IsolatedCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isTaskCancelledError)(new IsolatedCircuitError_1.IsolatedCircuitError())).to.be.false;
+        });
+        it('returns false for an instance of HydratingCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isTaskCancelledError)(new HydratingCircuitError_1.HydratingCircuitError())).to.be.false;
+        });
+    });
+    describe('HydratingCircuitError', () => {
+        const error = new HydratingCircuitError_1.HydratingCircuitError();
+        it('returns true for an instance of HydratingCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isHydratingCircuitError)(error)).to.be.true;
+        });
+        it('returns false for an instance of BrokenCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isHydratingCircuitError)(new BrokenCircuitError_1.BrokenCircuitError())).to.be.false;
+        });
+        it('returns false for an instance of BulkheadRejectedError', () => {
+            (0, chai_1.expect)((0, Errors_1.isHydratingCircuitError)(new BulkheadRejectedError_1.BulkheadRejectedError(0, 0))).to.be.false;
+        });
+        it('returns false for an instance of IsolatedCircuitError', () => {
+            (0, chai_1.expect)((0, Errors_1.isHydratingCircuitError)(new IsolatedCircuitError_1.IsolatedCircuitError())).to.be.false;
+        });
+        it('returns false for an instance of TaskCancelledError', () => {
+            (0, chai_1.expect)((0, Errors_1.isHydratingCircuitError)(new TaskCancelledError_1.TaskCancelledError())).to.be.false;
+        });
+    });
+});
+//# sourceMappingURL=Errors.test.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/errors/Errors.test.js.map b/node_modules/cockatiel/dist/errors/Errors.test.js.map
new file mode 100644
index 0000000..5e7585c
--- /dev/null
+++ b/node_modules/cockatiel/dist/errors/Errors.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Errors.test.js","sourceRoot":"","sources":["../../src/errors/Errors.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from 'chai';\nimport { BrokenCircuitError } from './BrokenCircuitError';\nimport { BulkheadRejectedError } from './BulkheadRejectedError';\nimport {\n  isBrokenCircuitError,\n  isBulkheadRejectedError,\n  isHydratingCircuitError,\n  isIsolatedCircuitError,\n  isTaskCancelledError,\n} from './Errors';\nimport { HydratingCircuitError } from './HydratingCircuitError';\nimport { IsolatedCircuitError } from './IsolatedCircuitError';\nimport { TaskCancelledError } from './TaskCancelledError';\n\ndescribe('Errors', () => {\n  describe('isBrokenCircuitError', () => {\n    const error = new BrokenCircuitError();\n\n    it('returns true for an instance of BrokenCircuitError', () => {\n      expect(isBrokenCircuitError(error)).to.be.true;\n    });\n\n    it('returns true for an instance of IsolatedCircuitError', () => {\n      expect(isBrokenCircuitError(new IsolatedCircuitError())).to.be.true;\n    });\n\n    it('returns false for an instance of BulkheadRejectedError', () => {\n      expect(isBrokenCircuitError(new BulkheadRejectedError(0, 0))).to.be.false;\n    });\n\n    it('returns false for an instance of TaskCancelledError', () => {\n      expect(isBrokenCircuitError(new TaskCancelledError())).to.be.false;\n    });\n\n    it('returns false for an instance of HydratingCircuitError', () => {\n      expect(isBrokenCircuitError(new HydratingCircuitError())).to.be.false;\n    });\n  });\n\n  describe('BulkheadRejectedError', () => {\n    const error = new BulkheadRejectedError(0, 0);\n\n    it('returns true for an instance of BulkheadRejectedError', () => {\n      expect(isBulkheadRejectedError(error)).to.be.true;\n    });\n\n    it('returns false for an instance of BrokenCircuitError', () => {\n      expect(isBulkheadRejectedError(new BrokenCircuitError())).to.be.false;\n    });\n\n    it('returns false for an instance of IsolatedCircuitError', () => {\n      expect(isBulkheadRejectedError(new IsolatedCircuitError())).to.be.false;\n    });\n\n    it('returns false for an instance of TaskCancelledError', () => {\n      expect(isBulkheadRejectedError(new TaskCancelledError())).to.be.false;\n    });\n\n    it('returns false for an instance of HydratingCircuitError', () => {\n      expect(isBulkheadRejectedError(new HydratingCircuitError())).to.be.false;\n    });\n  });\n\n  describe('IsolatedCircuitError', () => {\n    const error = new IsolatedCircuitError();\n\n    it('returns true for an instance of IsolatedCircuitError', () => {\n      expect(isIsolatedCircuitError(error)).to.be.true;\n    });\n\n    it('returns false for an instance of BrokenCircuitError', () => {\n      expect(isIsolatedCircuitError(new BrokenCircuitError())).to.be.false;\n    });\n\n    it('returns false for an instance of BulkheadRejectedError', () => {\n      expect(isIsolatedCircuitError(new BulkheadRejectedError(0, 0))).to.be.false;\n    });\n\n    it('returns false for an instance of TaskCancelledError', () => {\n      expect(isIsolatedCircuitError(new TaskCancelledError())).to.be.false;\n    });\n\n    it('returns false for an instance of HydratingCircuitError', () => {\n      expect(isIsolatedCircuitError(new HydratingCircuitError())).to.be.false;\n    });\n  });\n\n  describe('TaskCancelledError', () => {\n    const error = new TaskCancelledError();\n\n    it('returns true for an instance of TaskCancelledError', () => {\n      expect(isTaskCancelledError(error)).to.be.true;\n    });\n\n    it('returns false for an instance of BrokenCircuitError', () => {\n      expect(isTaskCancelledError(new BrokenCircuitError())).to.be.false;\n    });\n\n    it('returns false for an instance of BulkheadRejectedError', () => {\n      expect(isTaskCancelledError(new BulkheadRejectedError(0, 0))).to.be.false;\n    });\n\n    it('returns false for an instance of IsolatedCircuitError', () => {\n      expect(isTaskCancelledError(new IsolatedCircuitError())).to.be.false;\n    });\n\n    it('returns false for an instance of HydratingCircuitError', () => {\n      expect(isTaskCancelledError(new HydratingCircuitError())).to.be.false;\n    });\n  });\n\n  describe('HydratingCircuitError', () => {\n    const error = new HydratingCircuitError();\n\n    it('returns true for an instance of HydratingCircuitError', () => {\n      expect(isHydratingCircuitError(error)).to.be.true;\n    });\n\n    it('returns false for an instance of BrokenCircuitError', () => {\n      expect(isHydratingCircuitError(new BrokenCircuitError())).to.be.false;\n    });\n\n    it('returns false for an instance of BulkheadRejectedError', () => {\n      expect(isHydratingCircuitError(new BulkheadRejectedError(0, 0))).to.be.false;\n    });\n\n    it('returns false for an instance of IsolatedCircuitError', () => {\n      expect(isHydratingCircuitError(new IsolatedCircuitError())).to.be.false;\n    });\n\n    it('returns false for an instance of TaskCancelledError', () => {\n      expect(isHydratingCircuitError(new TaskCancelledError())).to.be.false;\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/BulkheadPolicy.d.ts b/node_modules/cockatiel/dist/esm/BulkheadPolicy.d.ts
deleted file mode 100644
index c7f64e5..0000000
--- a/node_modules/cockatiel/dist/esm/BulkheadPolicy.d.ts
+++ /dev/null
@@ -1,41 +0,0 @@
-import { IDefaultPolicyContext, IPolicy } from './Policy';
-export declare class BulkheadPolicy implements IPolicy {
-    private readonly capacity;
-    private readonly queueCapacity;
-    readonly _altReturn: never;
-    private active;
-    private readonly queue;
-    private readonly onRejectEmitter;
-    private readonly executor;
-    /**
-     * @inheritdoc
-     */
-    readonly onSuccess: import("./common/Event").Event<import("./Policy").ISuccessEvent>;
-    /**
-     * @inheritdoc
-     */
-    readonly onFailure: import("./common/Event").Event<import("./Policy").IFailureEvent>;
-    /**
-     * Emitter that fires when an item is rejected from the bulkhead.
-     */
-    readonly onReject: import("./common/Event").Event<void>;
-    /**
-     * Returns the number of available execution slots at this point in time.
-     */
-    get executionSlots(): number;
-    /**
-     * Returns the number of queue slots at this point in time.
-     */
-    get queueSlots(): number;
-    /**
-     * Bulkhead limits concurrent requests made.
-     */
-    constructor(capacity: number, queueCapacity: number);
-    /**
-     * Executes the given function.
-     * @param fn Function to execute
-     * @throws a {@link BulkheadRejectedException} if the bulkhead limits are exceeeded
-     */
-    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
-    private dequeue;
-}
diff --git a/node_modules/cockatiel/dist/esm/BulkheadPolicy.js b/node_modules/cockatiel/dist/esm/BulkheadPolicy.js
deleted file mode 100644
index 92837f9..0000000
--- a/node_modules/cockatiel/dist/esm/BulkheadPolicy.js
+++ /dev/null
@@ -1,81 +0,0 @@
-import { neverAbortedSignal } from './common/abort';
-import { defer } from './common/defer';
-import { EventEmitter } from './common/Event';
-import { ExecuteWrapper } from './common/Executor';
-import { BulkheadRejectedError } from './errors/BulkheadRejectedError';
-import { TaskCancelledError } from './errors/Errors';
-export class BulkheadPolicy {
-    /**
-     * Returns the number of available execution slots at this point in time.
-     */
-    get executionSlots() {
-        return this.capacity - this.active;
-    }
-    /**
-     * Returns the number of queue slots at this point in time.
-     */
-    get queueSlots() {
-        return this.queueCapacity - this.queue.length;
-    }
-    /**
-     * Bulkhead limits concurrent requests made.
-     */
-    constructor(capacity, queueCapacity) {
-        this.capacity = capacity;
-        this.queueCapacity = queueCapacity;
-        this.active = 0;
-        this.queue = [];
-        this.onRejectEmitter = new EventEmitter();
-        this.executor = new ExecuteWrapper();
-        /**
-         * @inheritdoc
-         */
-        this.onSuccess = this.executor.onSuccess;
-        /**
-         * @inheritdoc
-         */
-        this.onFailure = this.executor.onFailure;
-        /**
-         * Emitter that fires when an item is rejected from the bulkhead.
-         */
-        this.onReject = this.onRejectEmitter.addListener;
-    }
-    /**
-     * Executes the given function.
-     * @param fn Function to execute
-     * @throws a {@link BulkheadRejectedException} if the bulkhead limits are exceeeded
-     */
-    async execute(fn, signal = neverAbortedSignal) {
-        if (signal.aborted) {
-            throw new TaskCancelledError();
-        }
-        if (this.active < this.capacity) {
-            this.active++;
-            try {
-                return await fn({ signal });
-            }
-            finally {
-                this.active--;
-                this.dequeue();
-            }
-        }
-        if (this.queue.length < this.queueCapacity) {
-            const { resolve, reject, promise } = defer();
-            this.queue.push({ signal, fn, resolve, reject });
-            return promise;
-        }
-        this.onRejectEmitter.emit();
-        throw new BulkheadRejectedError(this.capacity, this.queueCapacity);
-    }
-    dequeue() {
-        const item = this.queue.shift();
-        if (!item) {
-            return;
-        }
-        Promise.resolve()
-            .then(() => this.execute(item.fn, item.signal))
-            .then(item.resolve)
-            .catch(item.reject);
-    }
-}
-//# sourceMappingURL=BulkheadPolicy.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/BulkheadPolicy.js.map b/node_modules/cockatiel/dist/esm/BulkheadPolicy.js.map
deleted file mode 100644
index 65a270d..0000000
--- a/node_modules/cockatiel/dist/esm/BulkheadPolicy.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"BulkheadPolicy.js","sourceRoot":"","sources":["../../src/BulkheadPolicy.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AACpD,OAAO,EAAE,KAAK,EAAE,MAAM,gBAAgB,CAAC;AACvC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AACnD,OAAO,EAAE,qBAAqB,EAAE,MAAM,gCAAgC,CAAC;AACvE,OAAO,EAAE,kBAAkB,EAAE,MAAM,iBAAiB,CAAC;AAUrD,MAAM,OAAO,cAAc;IAuBzB;;OAEG;IACH,IAAW,cAAc;QACvB,OAAO,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;IACrC,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,YACmB,QAAgB,EAChB,aAAqB;QADrB,aAAQ,GAAR,QAAQ,CAAQ;QAChB,kBAAa,GAAb,aAAa,CAAQ;QAvChC,WAAM,GAAG,CAAC,CAAC;QACF,UAAK,GAA+B,EAAE,CAAC;QACvC,oBAAe,GAAG,IAAI,YAAY,EAAQ,CAAC;QAC3C,aAAQ,GAAG,IAAI,cAAc,EAAE,CAAC;QAEjD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,aAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC;IAsBzD,CAAC;IAEJ;;;;OAIG;IACI,KAAK,CAAC,OAAO,CAClB,EAA0D,EAC1D,MAAM,GAAG,kBAAkB;QAE3B,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,kBAAkB,EAAE,CAAC;QACjC,CAAC;QAED,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAChC,IAAI,CAAC,MAAM,EAAE,CAAC;YACd,IAAI,CAAC;gBACH,OAAO,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;YAC9B,CAAC;oBAAS,CAAC;gBACT,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,IAAI,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACH,CAAC;QAED,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YAC3C,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,KAAK,EAAK,CAAC;YAChD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;YACjD,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QAC5B,MAAM,IAAI,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;IACrE,CAAC;IAEO,OAAO;QACb,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAChC,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,OAAO;QACT,CAAC;QAED,OAAO,CAAC,OAAO,EAAE;aACd,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aAC9C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;aAClB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACxB,CAAC;CACF","sourcesContent":["import { neverAbortedSignal } from './common/abort';\nimport { defer } from './common/defer';\nimport { EventEmitter } from './common/Event';\nimport { ExecuteWrapper } from './common/Executor';\nimport { BulkheadRejectedError } from './errors/BulkheadRejectedError';\nimport { TaskCancelledError } from './errors/Errors';\nimport { IDefaultPolicyContext, IPolicy } from './Policy';\n\ninterface IQueueItem<T> {\n  signal: AbortSignal;\n  fn(context: IDefaultPolicyContext): Promise<T> | T;\n  resolve(value: T): void;\n  reject(error: Error): void;\n}\n\nexport class BulkheadPolicy implements IPolicy {\n  public declare readonly _altReturn: never;\n\n  private active = 0;\n  private readonly queue: Array<IQueueItem<unknown>> = [];\n  private readonly onRejectEmitter = new EventEmitter<void>();\n  private readonly executor = new ExecuteWrapper();\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * Emitter that fires when an item is rejected from the bulkhead.\n   */\n  public readonly onReject = this.onRejectEmitter.addListener;\n\n  /**\n   * Returns the number of available execution slots at this point in time.\n   */\n  public get executionSlots() {\n    return this.capacity - this.active;\n  }\n\n  /**\n   * Returns the number of queue slots at this point in time.\n   */\n  public get queueSlots() {\n    return this.queueCapacity - this.queue.length;\n  }\n\n  /**\n   * Bulkhead limits concurrent requests made.\n   */\n  constructor(\n    private readonly capacity: number,\n    private readonly queueCapacity: number,\n  ) {}\n\n  /**\n   * Executes the given function.\n   * @param fn Function to execute\n   * @throws a {@link BulkheadRejectedException} if the bulkhead limits are exceeeded\n   */\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T> {\n    if (signal.aborted) {\n      throw new TaskCancelledError();\n    }\n\n    if (this.active < this.capacity) {\n      this.active++;\n      try {\n        return await fn({ signal });\n      } finally {\n        this.active--;\n        this.dequeue();\n      }\n    }\n\n    if (this.queue.length < this.queueCapacity) {\n      const { resolve, reject, promise } = defer<T>();\n      this.queue.push({ signal, fn, resolve, reject });\n      return promise;\n    }\n\n    this.onRejectEmitter.emit();\n    throw new BulkheadRejectedError(this.capacity, this.queueCapacity);\n  }\n\n  private dequeue() {\n    const item = this.queue.shift();\n    if (!item) {\n      return;\n    }\n\n    Promise.resolve()\n      .then(() => this.execute(item.fn, item.signal))\n      .then(item.resolve)\n      .catch(item.reject);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.d.ts b/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.d.ts
deleted file mode 100644
index b519a94..0000000
--- a/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.d.ts
+++ /dev/null
@@ -1,127 +0,0 @@
-import { IBackoffFactory } from './backoff/Backoff';
-import { IBreaker } from './breaker/Breaker';
-import { ExecuteWrapper } from './common/Executor';
-import { FailureReason, IDefaultPolicyContext, IPolicy } from './Policy';
-export declare enum CircuitState {
-    /**
-     * Normal operation. Execution of actions allowed.
-     */
-    Closed = 0,
-    /**
-     * The automated controller has opened the circuit. Execution of actions blocked.
-     */
-    Open = 1,
-    /**
-     * Recovering from open state, after the automated break duration has
-     * expired. Execution of actions permitted. Success of subsequent action/s
-     * controls onward transition to Open or Closed state.
-     */
-    HalfOpen = 2,
-    /**
-     * Circuit held manually in an open state. Execution of actions blocked.
-     */
-    Isolated = 3
-}
-/**
- * Context passed into halfOpenAfter backoff delegate.
- */
-export interface IHalfOpenAfterBackoffContext extends IDefaultPolicyContext {
-    /**
-     * The consecutive number of times the circuit has entered the
-     * {@link CircuitState.Open} state.
-     */
-    attempt: number;
-    /**
-     * The result of the last method call that caused the circuit to enter the
-     * {@link CircuitState.Open} state. Either a thrown error, or a value that we
-     * determined should open the circuit.
-     */
-    result: FailureReason<unknown>;
-}
-export interface ICircuitBreakerOptions {
-    breaker: IBreaker;
-    /**
-     * When to (potentially) enter the {@link CircuitState.HalfOpen} state from
-     * the {@link CircuitState.Open} state. Either a duration in milliseconds or a
-     * backoff factory.
-     */
-    halfOpenAfter: number | IBackoffFactory<IHalfOpenAfterBackoffContext>;
-    /**
-     * Initial state from a previous call to {@link CircuitBreakerPolicy.toJSON}.
-     */
-    initialState?: unknown;
-}
-export declare class CircuitBreakerPolicy implements IPolicy {
-    private readonly options;
-    private readonly executor;
-    readonly _altReturn: never;
-    private readonly breakEmitter;
-    private readonly resetEmitter;
-    private readonly halfOpenEmitter;
-    private readonly stateChangeEmitter;
-    private readonly halfOpenAfterBackoffFactory;
-    private innerLastFailure?;
-    private innerState;
-    /**
-     * Event emitted when the circuit breaker opens.
-     */
-    readonly onBreak: import("./common/Event").Event<FailureReason<unknown> | {
-        isolated: true;
-    }>;
-    /**
-     * Event emitted when the circuit breaker resets.
-     */
-    readonly onReset: import("./common/Event").Event<void>;
-    /**
-     * Event emitted when the circuit breaker is half open (running a test call).
-     * Either `onBreak` on `onReset` will subsequently fire.
-     */
-    readonly onHalfOpen: import("./common/Event").Event<void>;
-    /**
-     * Fired whenever the circuit breaker state changes.
-     */
-    readonly onStateChange: import("./common/Event").Event<CircuitState>;
-    /**
-     * @inheritdoc
-     */
-    readonly onSuccess: import("./common/Event").Event<import("./Policy").ISuccessEvent>;
-    /**
-     * @inheritdoc
-     */
-    readonly onFailure: import("./common/Event").Event<import("./Policy").IFailureEvent>;
-    /**
-     * Gets the current circuit breaker state.
-     */
-    get state(): CircuitState;
-    /**
-     * Gets the last reason the circuit breaker failed.
-     */
-    get lastFailure(): FailureReason<unknown> | undefined;
-    constructor(options: ICircuitBreakerOptions, executor: ExecuteWrapper);
-    /**
-     * Manually holds open the circuit breaker.
-     * @returns A handle that keeps the breaker open until `.dispose()` is called.
-     */
-    isolate(): {
-        dispose: () => void;
-    };
-    /**
-     * Executes the given function.
-     * @param fn Function to run
-     * @throws a {@link BrokenCircuitError} if the circuit is open
-     * @throws a {@link IsolatedCircuitError} if the circuit is held
-     * open via {@link CircuitBreakerPolicy.isolate}
-     * @returns a Promise that resolves or rejects with the function results.
-     */
-    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
-    /**
-     * Captures circuit breaker state that can later be used to recreate the
-     * breaker by passing `state` to the `circuitBreaker` function. This is
-     * useful in cases like serverless functions where you may want to keep
-     * the breaker state across multiple executions.
-     */
-    toJSON(): unknown;
-    private halfOpen;
-    private open;
-    private close;
-}
diff --git a/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.js b/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.js
deleted file mode 100644
index 824e1af..0000000
--- a/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.js
+++ /dev/null
@@ -1,246 +0,0 @@
-import { ConstantBackoff } from './backoff/Backoff';
-import { neverAbortedSignal } from './common/abort';
-import { EventEmitter } from './common/Event';
-import { returnOrThrow } from './common/Executor';
-import { BrokenCircuitError, HydratingCircuitError, TaskCancelledError } from './errors/Errors';
-import { IsolatedCircuitError } from './errors/IsolatedCircuitError';
-export var CircuitState;
-(function (CircuitState) {
-    /**
-     * Normal operation. Execution of actions allowed.
-     */
-    CircuitState[CircuitState["Closed"] = 0] = "Closed";
-    /**
-     * The automated controller has opened the circuit. Execution of actions blocked.
-     */
-    CircuitState[CircuitState["Open"] = 1] = "Open";
-    /**
-     * Recovering from open state, after the automated break duration has
-     * expired. Execution of actions permitted. Success of subsequent action/s
-     * controls onward transition to Open or Closed state.
-     */
-    CircuitState[CircuitState["HalfOpen"] = 2] = "HalfOpen";
-    /**
-     * Circuit held manually in an open state. Execution of actions blocked.
-     */
-    CircuitState[CircuitState["Isolated"] = 3] = "Isolated";
-})(CircuitState || (CircuitState = {}));
-export class CircuitBreakerPolicy {
-    /**
-     * Gets the current circuit breaker state.
-     */
-    get state() {
-        return this.innerState.value;
-    }
-    /**
-     * Gets the last reason the circuit breaker failed.
-     */
-    get lastFailure() {
-        return this.innerLastFailure;
-    }
-    constructor(options, executor) {
-        this.options = options;
-        this.executor = executor;
-        this.breakEmitter = new EventEmitter();
-        this.resetEmitter = new EventEmitter();
-        this.halfOpenEmitter = new EventEmitter();
-        this.stateChangeEmitter = new EventEmitter();
-        this.innerState = { value: CircuitState.Closed };
-        /**
-         * Event emitted when the circuit breaker opens.
-         */
-        this.onBreak = this.breakEmitter.addListener;
-        /**
-         * Event emitted when the circuit breaker resets.
-         */
-        this.onReset = this.resetEmitter.addListener;
-        /**
-         * Event emitted when the circuit breaker is half open (running a test call).
-         * Either `onBreak` on `onReset` will subsequently fire.
-         */
-        this.onHalfOpen = this.halfOpenEmitter.addListener;
-        /**
-         * Fired whenever the circuit breaker state changes.
-         */
-        this.onStateChange = this.stateChangeEmitter.addListener;
-        /**
-         * @inheritdoc
-         */
-        this.onSuccess = this.executor.onSuccess;
-        /**
-         * @inheritdoc
-         */
-        this.onFailure = this.executor.onFailure;
-        this.halfOpenAfterBackoffFactory =
-            typeof options.halfOpenAfter === 'number'
-                ? new ConstantBackoff(options.halfOpenAfter)
-                : options.halfOpenAfter;
-        if (options.initialState) {
-            const initialState = options.initialState;
-            this.innerState = initialState.ownState;
-            this.options.breaker.state = initialState.breakerState;
-            if (this.innerState.value === CircuitState.Open ||
-                this.innerState.value === CircuitState.HalfOpen) {
-                this.innerLastFailure = { error: new HydratingCircuitError() };
-                let backoff = this.halfOpenAfterBackoffFactory.next({
-                    attempt: 1,
-                    result: this.innerLastFailure,
-                    signal: neverAbortedSignal,
-                });
-                for (let i = 2; i <= this.innerState.attemptNo; i++) {
-                    backoff = backoff.next({
-                        attempt: i,
-                        result: this.innerLastFailure,
-                        signal: neverAbortedSignal,
-                    });
-                }
-                this.innerState.backoff = backoff;
-            }
-        }
-    }
-    /**
-     * Manually holds open the circuit breaker.
-     * @returns A handle that keeps the breaker open until `.dispose()` is called.
-     */
-    isolate() {
-        if (this.innerState.value !== CircuitState.Isolated) {
-            this.innerState = { value: CircuitState.Isolated, counters: 0 };
-            this.breakEmitter.emit({ isolated: true });
-            this.stateChangeEmitter.emit(CircuitState.Isolated);
-        }
-        this.innerState.counters++;
-        let disposed = false;
-        return {
-            dispose: () => {
-                if (disposed) {
-                    return;
-                }
-                disposed = true;
-                if (this.innerState.value === CircuitState.Isolated && !--this.innerState.counters) {
-                    this.innerState = { value: CircuitState.Closed };
-                    this.resetEmitter.emit();
-                    this.stateChangeEmitter.emit(CircuitState.Closed);
-                }
-            },
-        };
-    }
-    /**
-     * Executes the given function.
-     * @param fn Function to run
-     * @throws a {@link BrokenCircuitError} if the circuit is open
-     * @throws a {@link IsolatedCircuitError} if the circuit is held
-     * open via {@link CircuitBreakerPolicy.isolate}
-     * @returns a Promise that resolves or rejects with the function results.
-     */
-    async execute(fn, signal = neverAbortedSignal) {
-        const state = this.innerState;
-        switch (state.value) {
-            case CircuitState.Closed:
-                const result = await this.executor.invoke(fn, { signal });
-                if ('success' in result) {
-                    this.options.breaker.success(state.value);
-                }
-                else {
-                    this.innerLastFailure = result;
-                    if (this.options.breaker.failure(state.value)) {
-                        this.open(result, signal);
-                    }
-                }
-                return returnOrThrow(result);
-            case CircuitState.HalfOpen:
-                await state.test.catch(() => undefined);
-                if (this.state === CircuitState.Closed && signal.aborted) {
-                    throw new TaskCancelledError();
-                }
-                return this.execute(fn);
-            case CircuitState.Open:
-                if (Date.now() - state.openedAt < state.backoff.duration) {
-                    throw new BrokenCircuitError();
-                }
-                const test = this.halfOpen(fn, signal);
-                this.innerState = {
-                    value: CircuitState.HalfOpen,
-                    test,
-                    backoff: state.backoff,
-                    attemptNo: state.attemptNo + 1,
-                };
-                this.stateChangeEmitter.emit(CircuitState.HalfOpen);
-                return test;
-            case CircuitState.Isolated:
-                throw new IsolatedCircuitError();
-            default:
-                throw new Error(`Unexpected circuit state ${state}`);
-        }
-    }
-    /**
-     * Captures circuit breaker state that can later be used to recreate the
-     * breaker by passing `state` to the `circuitBreaker` function. This is
-     * useful in cases like serverless functions where you may want to keep
-     * the breaker state across multiple executions.
-     */
-    toJSON() {
-        const state = this.innerState;
-        let ownState;
-        if (state.value === CircuitState.HalfOpen) {
-            ownState = {
-                value: CircuitState.Open,
-                openedAt: 0,
-                attemptNo: state.attemptNo,
-            };
-        }
-        else if (state.value === CircuitState.Open) {
-            ownState = {
-                value: CircuitState.Open,
-                openedAt: state.openedAt,
-                attemptNo: state.attemptNo,
-            };
-        }
-        else {
-            ownState = state;
-        }
-        return { ownState, breakerState: this.options.breaker.state };
-    }
-    async halfOpen(fn, signal) {
-        this.halfOpenEmitter.emit();
-        try {
-            const result = await this.executor.invoke(fn, { signal });
-            if ('success' in result) {
-                this.options.breaker.success(CircuitState.HalfOpen);
-                this.close();
-            }
-            else {
-                this.innerLastFailure = result;
-                this.options.breaker.failure(CircuitState.HalfOpen);
-                this.open(result, signal);
-            }
-            return returnOrThrow(result);
-        }
-        catch (err) {
-            // It's an error, but not one the circuit is meant to retry, so
-            // for our purposes it's a success. Task failed successfully!
-            this.close();
-            throw err;
-        }
-    }
-    open(reason, signal) {
-        if (this.state === CircuitState.Isolated || this.state === CircuitState.Open) {
-            return;
-        }
-        const attemptNo = this.innerState.value === CircuitState.HalfOpen ? this.innerState.attemptNo : 1;
-        const context = { attempt: attemptNo, result: reason, signal };
-        const backoff = this.innerState.value === CircuitState.HalfOpen
-            ? this.innerState.backoff.next(context)
-            : this.halfOpenAfterBackoffFactory.next(context);
-        this.innerState = { value: CircuitState.Open, openedAt: Date.now(), backoff, attemptNo };
-        this.breakEmitter.emit(reason);
-        this.stateChangeEmitter.emit(CircuitState.Open);
-    }
-    close() {
-        if (this.state === CircuitState.HalfOpen) {
-            this.innerState = { value: CircuitState.Closed };
-            this.resetEmitter.emit();
-            this.stateChangeEmitter.emit(CircuitState.Closed);
-        }
-    }
-}
-//# sourceMappingURL=CircuitBreakerPolicy.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.js.map b/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.js.map
deleted file mode 100644
index 3f42b97..0000000
--- a/node_modules/cockatiel/dist/esm/CircuitBreakerPolicy.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"CircuitBreakerPolicy.js","sourceRoot":"","sources":["../../src/CircuitBreakerPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConstantBackoff, IBackoff, IBackoffFactory } from './backoff/Backoff';\nimport { IBreaker } from './breaker/Breaker';\nimport { neverAbortedSignal } from './common/abort';\nimport { EventEmitter } from './common/Event';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { BrokenCircuitError, HydratingCircuitError, TaskCancelledError } from './errors/Errors';\nimport { IsolatedCircuitError } from './errors/IsolatedCircuitError';\nimport { FailureReason, IDefaultPolicyContext, IPolicy } from './Policy';\n\nexport enum CircuitState {\n  /**\n   * Normal operation. Execution of actions allowed.\n   */\n  Closed,\n\n  /**\n   * The automated controller has opened the circuit. Execution of actions blocked.\n   */\n  Open,\n\n  /**\n   * Recovering from open state, after the automated break duration has\n   * expired. Execution of actions permitted. Success of subsequent action/s\n   * controls onward transition to Open or Closed state.\n   */\n  HalfOpen,\n\n  /**\n   * Circuit held manually in an open state. Execution of actions blocked.\n   */\n  Isolated,\n}\n\n/**\n * Context passed into halfOpenAfter backoff delegate.\n */\nexport interface IHalfOpenAfterBackoffContext extends IDefaultPolicyContext {\n  /**\n   * The consecutive number of times the circuit has entered the\n   * {@link CircuitState.Open} state.\n   */\n  attempt: number;\n  /**\n   * The result of the last method call that caused the circuit to enter the\n   * {@link CircuitState.Open} state. Either a thrown error, or a value that we\n   * determined should open the circuit.\n   */\n  result: FailureReason<unknown>;\n}\n\nexport interface ICircuitBreakerOptions {\n  breaker: IBreaker;\n\n  /**\n   * When to (potentially) enter the {@link CircuitState.HalfOpen} state from\n   * the {@link CircuitState.Open} state. Either a duration in milliseconds or a\n   * backoff factory.\n   */\n  halfOpenAfter: number | IBackoffFactory<IHalfOpenAfterBackoffContext>;\n\n  /**\n   * Initial state from a previous call to {@link CircuitBreakerPolicy.toJSON}.\n   */\n  initialState?: unknown;\n}\n\ntype InnerState =\n  | { value: CircuitState.Closed }\n  | { value: CircuitState.Isolated; counters: number }\n  | {\n      value: CircuitState.Open;\n      openedAt: number;\n      attemptNo: number;\n      backoff: IBackoff<IHalfOpenAfterBackoffContext>;\n    }\n  | {\n      value: CircuitState.HalfOpen;\n      test: Promise<any>;\n      attemptNo: number;\n      backoff: IBackoff<IHalfOpenAfterBackoffContext>;\n    };\n\ninterface ISerializedState {\n  ownState: Partial<InnerState>;\n  breakerState: unknown;\n}\n\nexport class CircuitBreakerPolicy implements IPolicy {\n  declare readonly _altReturn: never;\n\n  private readonly breakEmitter = new EventEmitter<FailureReason<unknown> | { isolated: true }>();\n  private readonly resetEmitter = new EventEmitter<void>();\n  private readonly halfOpenEmitter = new EventEmitter<void>();\n  private readonly stateChangeEmitter = new EventEmitter<CircuitState>();\n  private readonly halfOpenAfterBackoffFactory: IBackoffFactory<IHalfOpenAfterBackoffContext>;\n  private innerLastFailure?: FailureReason<unknown>;\n  private innerState: InnerState = { value: CircuitState.Closed };\n\n  /**\n   * Event emitted when the circuit breaker opens.\n   */\n  public readonly onBreak = this.breakEmitter.addListener;\n\n  /**\n   * Event emitted when the circuit breaker resets.\n   */\n  public readonly onReset = this.resetEmitter.addListener;\n\n  /**\n   * Event emitted when the circuit breaker is half open (running a test call).\n   * Either `onBreak` on `onReset` will subsequently fire.\n   */\n  public readonly onHalfOpen = this.halfOpenEmitter.addListener;\n\n  /**\n   * Fired whenever the circuit breaker state changes.\n   */\n  public readonly onStateChange = this.stateChangeEmitter.addListener;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * Gets the current circuit breaker state.\n   */\n  public get state(): CircuitState {\n    return this.innerState.value;\n  }\n\n  /**\n   * Gets the last reason the circuit breaker failed.\n   */\n  public get lastFailure() {\n    return this.innerLastFailure;\n  }\n\n  constructor(\n    private readonly options: ICircuitBreakerOptions,\n    private readonly executor: ExecuteWrapper,\n  ) {\n    this.halfOpenAfterBackoffFactory =\n      typeof options.halfOpenAfter === 'number'\n        ? new ConstantBackoff(options.halfOpenAfter)\n        : options.halfOpenAfter;\n\n    if (options.initialState) {\n      const initialState = options.initialState as ISerializedState;\n      this.innerState = initialState.ownState as InnerState;\n      this.options.breaker.state = initialState.breakerState;\n\n      if (\n        this.innerState.value === CircuitState.Open ||\n        this.innerState.value === CircuitState.HalfOpen\n      ) {\n        this.innerLastFailure = { error: new HydratingCircuitError() };\n        let backoff = this.halfOpenAfterBackoffFactory.next({\n          attempt: 1,\n          result: this.innerLastFailure,\n          signal: neverAbortedSignal,\n        });\n        for (let i = 2; i <= this.innerState.attemptNo; i++) {\n          backoff = backoff.next({\n            attempt: i,\n            result: this.innerLastFailure,\n            signal: neverAbortedSignal,\n          });\n        }\n        this.innerState.backoff = backoff;\n      }\n    }\n  }\n\n  /**\n   * Manually holds open the circuit breaker.\n   * @returns A handle that keeps the breaker open until `.dispose()` is called.\n   */\n  public isolate() {\n    if (this.innerState.value !== CircuitState.Isolated) {\n      this.innerState = { value: CircuitState.Isolated, counters: 0 };\n      this.breakEmitter.emit({ isolated: true });\n      this.stateChangeEmitter.emit(CircuitState.Isolated);\n    }\n\n    this.innerState.counters++;\n\n    let disposed = false;\n    return {\n      dispose: () => {\n        if (disposed) {\n          return;\n        }\n\n        disposed = true;\n        if (this.innerState.value === CircuitState.Isolated && !--this.innerState.counters) {\n          this.innerState = { value: CircuitState.Closed };\n          this.resetEmitter.emit();\n          this.stateChangeEmitter.emit(CircuitState.Closed);\n        }\n      },\n    };\n  }\n\n  /**\n   * Executes the given function.\n   * @param fn Function to run\n   * @throws a {@link BrokenCircuitError} if the circuit is open\n   * @throws a {@link IsolatedCircuitError} if the circuit is held\n   * open via {@link CircuitBreakerPolicy.isolate}\n   * @returns a Promise that resolves or rejects with the function results.\n   */\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T> {\n    const state = this.innerState;\n    switch (state.value) {\n      case CircuitState.Closed:\n        const result = await this.executor.invoke(fn, { signal });\n        if ('success' in result) {\n          this.options.breaker.success(state.value);\n        } else {\n          this.innerLastFailure = result;\n          if (this.options.breaker.failure(state.value)) {\n            this.open(result, signal);\n          }\n        }\n\n        return returnOrThrow(result);\n\n      case CircuitState.HalfOpen:\n        await state.test.catch(() => undefined);\n        if (this.state === CircuitState.Closed && signal.aborted) {\n          throw new TaskCancelledError();\n        }\n\n        return this.execute(fn);\n\n      case CircuitState.Open:\n        if (Date.now() - state.openedAt < state.backoff.duration) {\n          throw new BrokenCircuitError();\n        }\n        const test = this.halfOpen(fn, signal);\n        this.innerState = {\n          value: CircuitState.HalfOpen,\n          test,\n          backoff: state.backoff,\n          attemptNo: state.attemptNo + 1,\n        };\n        this.stateChangeEmitter.emit(CircuitState.HalfOpen);\n        return test;\n\n      case CircuitState.Isolated:\n        throw new IsolatedCircuitError();\n\n      default:\n        throw new Error(`Unexpected circuit state ${state}`);\n    }\n  }\n\n  /**\n   * Captures circuit breaker state that can later be used to recreate the\n   * breaker by passing `state` to the `circuitBreaker` function. This is\n   * useful in cases like serverless functions where you may want to keep\n   * the breaker state across multiple executions.\n   */\n  public toJSON(): unknown {\n    const state = this.innerState;\n    let ownState: Partial<InnerState>;\n    if (state.value === CircuitState.HalfOpen) {\n      ownState = {\n        value: CircuitState.Open,\n        openedAt: 0,\n        attemptNo: state.attemptNo,\n      };\n    } else if (state.value === CircuitState.Open) {\n      ownState = {\n        value: CircuitState.Open,\n        openedAt: state.openedAt,\n        attemptNo: state.attemptNo,\n      };\n    } else {\n      ownState = state;\n    }\n\n    return { ownState, breakerState: this.options.breaker.state } satisfies ISerializedState;\n  }\n\n  private async halfOpen<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal: AbortSignal,\n  ): Promise<T> {\n    this.halfOpenEmitter.emit();\n\n    try {\n      const result = await this.executor.invoke(fn, { signal });\n      if ('success' in result) {\n        this.options.breaker.success(CircuitState.HalfOpen);\n        this.close();\n      } else {\n        this.innerLastFailure = result;\n        this.options.breaker.failure(CircuitState.HalfOpen);\n        this.open(result, signal);\n      }\n\n      return returnOrThrow(result);\n    } catch (err) {\n      // It's an error, but not one the circuit is meant to retry, so\n      // for our purposes it's a success. Task failed successfully!\n      this.close();\n      throw err;\n    }\n  }\n\n  private open(reason: FailureReason<unknown>, signal: AbortSignal) {\n    if (this.state === CircuitState.Isolated || this.state === CircuitState.Open) {\n      return;\n    }\n\n    const attemptNo =\n      this.innerState.value === CircuitState.HalfOpen ? this.innerState.attemptNo : 1;\n    const context = { attempt: attemptNo, result: reason, signal };\n    const backoff =\n      this.innerState.value === CircuitState.HalfOpen\n        ? this.innerState.backoff.next(context)\n        : this.halfOpenAfterBackoffFactory.next(context);\n\n    this.innerState = { value: CircuitState.Open, openedAt: Date.now(), backoff, attemptNo };\n    this.breakEmitter.emit(reason);\n    this.stateChangeEmitter.emit(CircuitState.Open);\n  }\n\n  private close() {\n    if (this.state === CircuitState.HalfOpen) {\n      this.innerState = { value: CircuitState.Closed };\n      this.resetEmitter.emit();\n      this.stateChangeEmitter.emit(CircuitState.Closed);\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/FallbackPolicy.d.ts b/node_modules/cockatiel/dist/esm/FallbackPolicy.d.ts
deleted file mode 100644
index c4e35c5..0000000
--- a/node_modules/cockatiel/dist/esm/FallbackPolicy.d.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { ExecuteWrapper } from './common/Executor';
-import { IDefaultPolicyContext, IPolicy } from './Policy';
-export declare class FallbackPolicy<AltReturn> implements IPolicy<IDefaultPolicyContext, AltReturn> {
-    private readonly executor;
-    private readonly value;
-    readonly _altReturn: AltReturn;
-    /**
-     * @inheritdoc
-     */
-    readonly onSuccess: import(".").Event<import("./Policy").ISuccessEvent>;
-    /**
-     * @inheritdoc
-     */
-    readonly onFailure: import(".").Event<import("./Policy").IFailureEvent>;
-    constructor(executor: ExecuteWrapper, value: () => AltReturn);
-    /**
-     * Executes the given function.
-     * @param fn Function to execute.
-     * @returns The function result or fallback value.
-     */
-    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T | AltReturn>;
-}
diff --git a/node_modules/cockatiel/dist/esm/FallbackPolicy.js b/node_modules/cockatiel/dist/esm/FallbackPolicy.js
deleted file mode 100644
index 949499a..0000000
--- a/node_modules/cockatiel/dist/esm/FallbackPolicy.js
+++ /dev/null
@@ -1,28 +0,0 @@
-import { neverAbortedSignal } from './common/abort';
-export class FallbackPolicy {
-    constructor(executor, value) {
-        this.executor = executor;
-        this.value = value;
-        /**
-         * @inheritdoc
-         */
-        this.onSuccess = this.executor.onSuccess;
-        /**
-         * @inheritdoc
-         */
-        this.onFailure = this.executor.onFailure;
-    }
-    /**
-     * Executes the given function.
-     * @param fn Function to execute.
-     * @returns The function result or fallback value.
-     */
-    async execute(fn, signal = neverAbortedSignal) {
-        const result = await this.executor.invoke(fn, { signal });
-        if ('success' in result) {
-            return result.success;
-        }
-        return this.value();
-    }
-}
-//# sourceMappingURL=FallbackPolicy.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/FallbackPolicy.js.map b/node_modules/cockatiel/dist/esm/FallbackPolicy.js.map
deleted file mode 100644
index 110ab2a..0000000
--- a/node_modules/cockatiel/dist/esm/FallbackPolicy.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"FallbackPolicy.js","sourceRoot":"","sources":["../../src/FallbackPolicy.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AAIpD,MAAM,OAAO,cAAc;IAazB,YACmB,QAAwB,EACxB,KAAsB;QADtB,aAAQ,GAAR,QAAQ,CAAgB;QACxB,UAAK,GAAL,KAAK,CAAiB;QAZzC;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IAKjD,CAAC;IAEJ;;;;OAIG;IACI,KAAK,CAAC,OAAO,CAClB,EAA0D,EAC1D,MAAM,GAAG,kBAAkB;QAE3B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC;QAC1D,IAAI,SAAS,IAAI,MAAM,EAAE,CAAC;YACxB,OAAO,MAAM,CAAC,OAAO,CAAC;QACxB,CAAC;QAED,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;IACtB,CAAC;CACF","sourcesContent":["import { neverAbortedSignal } from './common/abort';\nimport { ExecuteWrapper } from './common/Executor';\nimport { IDefaultPolicyContext, IPolicy } from './Policy';\n\nexport class FallbackPolicy<AltReturn> implements IPolicy<IDefaultPolicyContext, AltReturn> {\n  declare readonly _altReturn: AltReturn;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  constructor(\n    private readonly executor: ExecuteWrapper,\n    private readonly value: () => AltReturn,\n  ) {}\n\n  /**\n   * Executes the given function.\n   * @param fn Function to execute.\n   * @returns The function result or fallback value.\n   */\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T | AltReturn> {\n    const result = await this.executor.invoke(fn, { signal });\n    if ('success' in result) {\n      return result.success;\n    }\n\n    return this.value();\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/NoopPolicy.d.ts b/node_modules/cockatiel/dist/esm/NoopPolicy.d.ts
deleted file mode 100644
index 0beec48..0000000
--- a/node_modules/cockatiel/dist/esm/NoopPolicy.d.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-import { IDefaultPolicyContext, IPolicy } from './Policy';
-/**
- * A no-op policy, useful for unit tests and stubs.
- */
-export declare class NoopPolicy implements IPolicy {
-    readonly _altReturn: never;
-    private readonly executor;
-    readonly onSuccess: import(".").Event<import("./Policy").ISuccessEvent>;
-    readonly onFailure: import(".").Event<import("./Policy").IFailureEvent>;
-    execute<T>(fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
-}
diff --git a/node_modules/cockatiel/dist/esm/NoopPolicy.js b/node_modules/cockatiel/dist/esm/NoopPolicy.js
deleted file mode 100644
index b20dc26..0000000
--- a/node_modules/cockatiel/dist/esm/NoopPolicy.js
+++ /dev/null
@@ -1,16 +0,0 @@
-import { neverAbortedSignal } from './common/abort';
-import { ExecuteWrapper, returnOrThrow } from './common/Executor';
-/**
- * A no-op policy, useful for unit tests and stubs.
- */
-export class NoopPolicy {
-    constructor() {
-        this.executor = new ExecuteWrapper();
-        this.onSuccess = this.executor.onSuccess;
-        this.onFailure = this.executor.onFailure;
-    }
-    async execute(fn, signal = neverAbortedSignal) {
-        return returnOrThrow(await this.executor.invoke(fn, { signal }));
-    }
-}
-//# sourceMappingURL=NoopPolicy.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/NoopPolicy.js.map b/node_modules/cockatiel/dist/esm/NoopPolicy.js.map
deleted file mode 100644
index 7835558..0000000
--- a/node_modules/cockatiel/dist/esm/NoopPolicy.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"NoopPolicy.js","sourceRoot":"","sources":["../../src/NoopPolicy.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AACpD,OAAO,EAAE,cAAc,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAGlE;;GAEG;AACH,MAAM,OAAO,UAAU;IAAvB;QAEmB,aAAQ,GAAG,IAAI,cAAc,EAAE,CAAC;QACjC,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QACpC,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IAQtD,CAAC;IANQ,KAAK,CAAC,OAAO,CAClB,EAA0D,EAC1D,SAAsB,kBAAkB;QAExC,OAAO,aAAa,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;IACnE,CAAC;CACF","sourcesContent":["import { neverAbortedSignal } from './common/abort';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { IDefaultPolicyContext, IPolicy } from './Policy';\n\n/**\n * A no-op policy, useful for unit tests and stubs.\n */\nexport class NoopPolicy implements IPolicy {\n  declare readonly _altReturn: never;\n  private readonly executor = new ExecuteWrapper();\n  public readonly onSuccess = this.executor.onSuccess;\n  public readonly onFailure = this.executor.onFailure;\n\n  public async execute<T>(\n    fn: (context: IDefaultPolicyContext) => PromiseLike<T> | T,\n    signal: AbortSignal = neverAbortedSignal,\n  ): Promise<T> {\n    return returnOrThrow(await this.executor.invoke(fn, { signal }));\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/Policy.d.ts b/node_modules/cockatiel/dist/esm/Policy.d.ts
deleted file mode 100644
index d0b1c12..0000000
--- a/node_modules/cockatiel/dist/esm/Policy.d.ts
+++ /dev/null
@@ -1,322 +0,0 @@
-import { IBackoffFactory } from './backoff/Backoff';
-import { BulkheadPolicy } from './BulkheadPolicy';
-import { CircuitBreakerPolicy, ICircuitBreakerOptions } from './CircuitBreakerPolicy';
-import { Event } from './common/Event';
-import { FallbackPolicy } from './FallbackPolicy';
-import { NoopPolicy } from './NoopPolicy';
-import { IRetryBackoffContext, RetryPolicy } from './RetryPolicy';
-import { TimeoutPolicy, TimeoutStrategy } from './TimeoutPolicy';
-type Constructor<T> = new (...args: any) => T;
-export interface IBasePolicyOptions {
-    errorFilter: (error: Error) => boolean;
-    resultFilter: (result: unknown) => boolean;
-}
-/**
- * The reason for a call failure. Either an error, or the a value that was
- * marked as a failure (when using result filtering).
- */
-export type FailureReason<ReturnType> = {
-    error: Error;
-} | {
-    value: ReturnType;
-};
-/**
- * Event emitted on the `onFailure` calls.
- */
-export interface IFailureEvent {
-    /**
-     * Call duration, in milliseconds (with nanosecond precision, as the OS allows).
-     */
-    duration: number;
-    /**
-     * Whether the error was handled by the policy.
-     */
-    handled: boolean;
-    /**
-     * The reason for the error.
-     */
-    reason: FailureReason<unknown>;
-}
-/**
- * Event emitted on the `onSuccess` calls.
- */
-export interface ISuccessEvent {
-    /**
-     * Call duration, in milliseconds (with nanosecond precision, as the OS allows).
-     */
-    duration: number;
-}
-export interface IDefaultPolicyContext {
-    /**
-     * Abort signal for the operation. This is propagated through multiple
-     * retry policies.
-     */
-    signal: AbortSignal;
-}
-/**
- * IPolicy is the type of all policies that Cockatiel provides. It describes
- * an execute() function which takes a generic argument.
- */
-export interface IPolicy<ContextType extends IDefaultPolicyContext = IDefaultPolicyContext, AltReturn = never> {
-    /**
-     * Virtual property only used for TypeScript--will not actually be defined.
-     * @deprecated This property does not exist
-     */
-    readonly _altReturn: AltReturn;
-    /**
-     * Fires on the policy when a request successfully completes and some
-     * successful value will be returned. In a retry policy, this is fired once
-     * even if the request took multiple retries to succeed.
-     */
-    readonly onSuccess: Event<ISuccessEvent>;
-    /**
-     * Fires on the policy when a request fails *due to a handled reason* fails
-     * and will give rejection to the called.
-     */
-    readonly onFailure: Event<IFailureEvent>;
-    /**
-     * Runs the function through behavior specified by the policy.
-     */
-    execute<T>(fn: (context: ContextType) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T | AltReturn>;
-}
-export interface IMergedPolicy<A extends IDefaultPolicyContext, B, W extends IPolicy<any, any>[]> extends IPolicy<A, B> {
-    readonly wrapped: W;
-}
-type MergePolicies<A, B> = A extends IPolicy<infer A1, any> ? B extends IPolicy<infer B1, any> ? IMergedPolicy<A1 & B1, A['_altReturn'] | B['_altReturn'], B extends IMergedPolicy<any, any, infer W> ? [A, ...W] : [A, B]> : never : never;
-export declare class Policy {
-    readonly options: Readonly<IBasePolicyOptions>;
-    /**
-     * Factory that builds a base set of filters that can be used in circuit
-     * breakers, retries, etc.
-     */
-    constructor(options: Readonly<IBasePolicyOptions>);
-    /**
-     * Allows the policy to additionally handles errors of the given type.
-     *
-     * @param cls Class constructor to check that the error is an instance of.
-     * @param predicate If provided, a function to be called with the error
-     * which should return "true" if we want to handle this error.
-     * @example
-     * ```js
-     * // retry both network errors and response errors with a 503 status code
-     * new Policy()
-     *  .orType(NetworkError)
-     *  .orType(ResponseError, err => err.statusCode === 503)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean): Policy;
-    /**
-     * Allows the policy to additionally handles errors that pass the given
-     * predicate function.
-     *
-     * @param predicate Takes any thrown error, and returns true if it should
-     * be retried by this policy.
-     * @example
-     * ```js
-     * // only retry if the error has a "shouldBeRetried" property set
-     * new Policy()
-     *  .orWhen(err => err.shouldBeRetried === true)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orWhen(predicate: (error: Error) => boolean): Policy;
-    /**
-     * Adds handling for return values. The predicate will be called with
-     * the return value of the executed function,
-     *
-     * @param predicate Takes the returned value, and returns true if it
-     * should be retried by this policy.
-     * @example
-     * ```js
-     * // retry when the response status code is a 5xx
-     * new Policy()
-     *  .orResultWhen(res => res.statusCode >= 500)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orWhenResult(predicate: (r: unknown) => boolean): Policy;
-    /**
-     * Adds handling for return values. The predicate will be called with
-     * the return value of the executed function,
-     *
-     * @param predicate Takes the returned value, and returns true if it
-     * should be retried by this policy.
-     * @example
-     * ```js
-     * // retry when the response status code is a 5xx
-     * new Policy()
-     *  .orResultType(res => res.statusCode >= 500)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean): Policy;
-}
-export declare const noop: NoopPolicy;
-/**
- * A policy that handles all errors.
- */
-export declare const handleAll: Policy;
-/**
- * See {@link Policy.orType} for usage.
- */
-export declare function handleType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean): Policy;
-/**
- * See {@link Policy.orWhen} for usage.
- */
-export declare function handleWhen(predicate: (error: Error) => boolean): Policy;
-/**
- * See {@link Policy.orResultType} for usage.
- */
-export declare function handleResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean): Policy;
-/**
- * See {@link Policy.orWhenResult} for usage.
- */
-export declare function handleWhenResult(predicate: (error: unknown) => boolean): Policy;
-/**
- * Creates a bulkhead--a policy that limits the number of concurrent calls.
- */
-export declare function bulkhead(limit: number, queue?: number): BulkheadPolicy;
-/**
- * A decorator that can be used to wrap class methods and apply the given
- * policy to them. It also adds the last argument normally given in
- * {@link Policy.execute} as the last argument in the function call.
- * For example:
- *
- * ```ts
- * import { usePolicy, retry, handleAll } from 'cockatiel';
- *
- * const retry = retry(handleAll, { maxAttempts: 3 });
- *
- * class Database {
- *   @usePolicy(retry)
- *   public getUserInfo(userId, context, cancellationToken) {
- *     console.log('Retry attempt number', context.attempt);
- *     // implementation here
- *   }
- * }
- *
- * const db = new Database();
- * db.getUserInfo(3).then(info => console.log('User 3 info:', info))
- * ```
- *
- * Note that it will force the return type to be a Promise, since that's
- * what policies return.
- */
-export declare function usePolicy(policy: IPolicy<IDefaultPolicyContext, never>): (_target: unknown, _key: string, descriptor: PropertyDescriptor) => void;
-/**
- * Creates a timeout policy.
- * @param duration - How long to wait before timing out execute()'d functions
- * @param strategy - Strategy for timeouts, "Cooperative" or "Aggressive".
- * A {@link CancellationToken} will be pass to any executed function, and in
- * cooperative timeouts we'll simply wait for that function to return or
- * throw. In aggressive timeouts, we'll immediately throw a
- * {@link TaskCancelledError} when the timeout is reached, in addition to
- * marking the passed token as failed.
- */
-export declare function timeout(duration: number, strategyOrOpts: TimeoutStrategy | {
-    strategy: TimeoutStrategy;
-    abortOnReturn: boolean;
-}): TimeoutPolicy;
-/**
- * Wraps the given set of policies into a single policy. For instance, this:
- *
- * ```js
- * retry.execute(() =>
- *  breaker.execute(() =>
- *    timeout.execute(({ cancellationToken }) => getData(cancellationToken))))
- * ```
- *
- * Is the equivalent to:
- *
- * ```js
- * Policy
- *  .wrap(retry, breaker, timeout)
- *  .execute(({ cancellationToken }) => getData(cancellationToken)));
- * ```
- *
- * The `context` argument passed to the executed function is the merged object
- * of all previous policies.
- *
- */
-export declare function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A): A;
-export declare function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>, B extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A, p2: B): MergePolicies<A, B>;
-export declare function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>, B extends IPolicy<IDefaultPolicyContext, unknown>, C extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A, p2: B, p3: C): MergePolicies<C, MergePolicies<A, B>>;
-export declare function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>, B extends IPolicy<IDefaultPolicyContext, unknown>, C extends IPolicy<IDefaultPolicyContext, unknown>, D extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A, p2: B, p3: C, p4: D): MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>;
-export declare function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>, B extends IPolicy<IDefaultPolicyContext, unknown>, C extends IPolicy<IDefaultPolicyContext, unknown>, D extends IPolicy<IDefaultPolicyContext, unknown>, E extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A, p2: B, p3: C, p4: D, p5: E): MergePolicies<E, MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>>;
-export declare function wrap<C extends IDefaultPolicyContext, A>(...p: Array<IPolicy<C, A>>): IPolicy<C, A>;
-/**
- * Creates a retry policy. The options should contain the backoff strategy to
- * use. Included strategies are:
- *  - {@link ConstantBackoff}
- *  - {@link ExponentialBackoff}
- *  - {@link IterableBackoff}
- *  - {@link DelegateBackoff} (advanced)
- *
- * For example:
- *
- * ```
- * import { handleAll, retry } from 'cockatiel';
- *
- * const policy = retry(handleAll, { backoff: new ExponentialBackoff() });
- * ```
- *
- * You can optionally pass in the `attempts` to limit the maximum number of
- * retry attempts per call.
- */
-export declare function retry(policy: Policy, opts: {
-    maxAttempts?: number;
-    backoff?: IBackoffFactory<IRetryBackoffContext<unknown>>;
-}): RetryPolicy;
-/**
- * Returns a circuit breaker for the policy. **Important**: you should share
- * your circuit breaker between executions of whatever function you're
- * wrapping for it to function!
- *
- * ```ts
- * import { SamplingBreaker, Policy } from 'cockatiel';
- *
- * // Break if more than 20% of requests fail in a 30 second time window:
- * const breaker = Policy
- *  .handleAll()
- *  .circuitBreaker(10_000, new SamplingBreaker(0.2, 30 * 1000));
- *
- * export function handleRequest() {
- *   return breaker.execute(() => getInfoFromDatabase());
- * }
- * ```
- *
- * @param halfOpenAfter Time after failures to try to open the circuit
- * breaker again.
- * @param breaker The circuit breaker to use. This package exports
- * ConsecutiveBreaker and SamplingBreakers for you to use.
- */
-export declare function circuitBreaker(policy: Policy, opts: ICircuitBreakerOptions): CircuitBreakerPolicy;
-/**
- * Falls back to the given value in the event of an error.
- *
- * ```ts
- * import { Policy } from 'cockatiel';
- *
- * const fallback = Policy
- *  .handleType(DatabaseError)
- *  .fallback(() => getStaleData());
- *
- * export function handleRequest() {
- *   return fallback.execute(() => getInfoFromDatabase());
- * }
- * ```
- *
- * @param toValue Value to fall back to, or a function that creates the
- * value to return (any may return a promise)
- */
-export declare function fallback<R>(policy: Policy, valueOrFactory: (() => Promise<R> | R) | R): FallbackPolicy<R>;
-export {};
diff --git a/node_modules/cockatiel/dist/esm/Policy.js b/node_modules/cockatiel/dist/esm/Policy.js
deleted file mode 100644
index 0529307..0000000
--- a/node_modules/cockatiel/dist/esm/Policy.js
+++ /dev/null
@@ -1,285 +0,0 @@
-import { ConstantBackoff } from './backoff/Backoff';
-import { BulkheadPolicy } from './BulkheadPolicy';
-import { CircuitBreakerPolicy } from './CircuitBreakerPolicy';
-import { ExecuteWrapper } from './common/Executor';
-import { FallbackPolicy } from './FallbackPolicy';
-import { NoopPolicy } from './NoopPolicy';
-import { RetryPolicy } from './RetryPolicy';
-import { TimeoutPolicy } from './TimeoutPolicy';
-const typeFilter = (cls, predicate) => predicate ? (v) => v instanceof cls && predicate(v) : (v) => v instanceof cls;
-const always = () => true;
-const never = () => false;
-export class Policy {
-    /**
-     * Factory that builds a base set of filters that can be used in circuit
-     * breakers, retries, etc.
-     */
-    constructor(options) {
-        this.options = options;
-    }
-    /**
-     * Allows the policy to additionally handles errors of the given type.
-     *
-     * @param cls Class constructor to check that the error is an instance of.
-     * @param predicate If provided, a function to be called with the error
-     * which should return "true" if we want to handle this error.
-     * @example
-     * ```js
-     * // retry both network errors and response errors with a 503 status code
-     * new Policy()
-     *  .orType(NetworkError)
-     *  .orType(ResponseError, err => err.statusCode === 503)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orType(cls, predicate) {
-        const filter = typeFilter(cls, predicate);
-        return new Policy({
-            ...this.options,
-            errorFilter: e => this.options.errorFilter(e) || filter(e),
-        });
-    }
-    /**
-     * Allows the policy to additionally handles errors that pass the given
-     * predicate function.
-     *
-     * @param predicate Takes any thrown error, and returns true if it should
-     * be retried by this policy.
-     * @example
-     * ```js
-     * // only retry if the error has a "shouldBeRetried" property set
-     * new Policy()
-     *  .orWhen(err => err.shouldBeRetried === true)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orWhen(predicate) {
-        return new Policy({
-            ...this.options,
-            errorFilter: e => this.options.errorFilter(e) || predicate(e),
-        });
-    }
-    /**
-     * Adds handling for return values. The predicate will be called with
-     * the return value of the executed function,
-     *
-     * @param predicate Takes the returned value, and returns true if it
-     * should be retried by this policy.
-     * @example
-     * ```js
-     * // retry when the response status code is a 5xx
-     * new Policy()
-     *  .orResultWhen(res => res.statusCode >= 500)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orWhenResult(predicate) {
-        return new Policy({
-            ...this.options,
-            resultFilter: r => this.options.resultFilter(r) || predicate(r),
-        });
-    }
-    /**
-     * Adds handling for return values. The predicate will be called with
-     * the return value of the executed function,
-     *
-     * @param predicate Takes the returned value, and returns true if it
-     * should be retried by this policy.
-     * @example
-     * ```js
-     * // retry when the response status code is a 5xx
-     * new Policy()
-     *  .orResultType(res => res.statusCode >= 500)
-     *  .retry()
-     *  .attempts(3)
-     *  .execute(() => getJsonFrom('https://example.com'));
-     * ```
-     */
-    orResultType(cls, predicate) {
-        const filter = typeFilter(cls, predicate);
-        return new Policy({
-            ...this.options,
-            resultFilter: r => this.options.resultFilter(r) || filter(r),
-        });
-    }
-}
-export const noop = new NoopPolicy();
-/**
- * A policy that handles all errors.
- */
-export const handleAll = new Policy({ errorFilter: always, resultFilter: never });
-/**
- * See {@link Policy.orType} for usage.
- */
-export function handleType(cls, predicate) {
-    return new Policy({ errorFilter: typeFilter(cls, predicate), resultFilter: never });
-}
-/**
- * See {@link Policy.orWhen} for usage.
- */
-export function handleWhen(predicate) {
-    return new Policy({ errorFilter: predicate, resultFilter: never });
-}
-/**
- * See {@link Policy.orResultType} for usage.
- */
-export function handleResultType(cls, predicate) {
-    return new Policy({ errorFilter: never, resultFilter: typeFilter(cls, predicate) });
-}
-/**
- * See {@link Policy.orWhenResult} for usage.
- */
-export function handleWhenResult(predicate) {
-    return new Policy({ errorFilter: never, resultFilter: predicate });
-}
-/**
- * Creates a bulkhead--a policy that limits the number of concurrent calls.
- */
-export function bulkhead(limit, queue = 0) {
-    return new BulkheadPolicy(limit, queue);
-}
-/**
- * A decorator that can be used to wrap class methods and apply the given
- * policy to them. It also adds the last argument normally given in
- * {@link Policy.execute} as the last argument in the function call.
- * For example:
- *
- * ```ts
- * import { usePolicy, retry, handleAll } from 'cockatiel';
- *
- * const retry = retry(handleAll, { maxAttempts: 3 });
- *
- * class Database {
- *   @usePolicy(retry)
- *   public getUserInfo(userId, context, cancellationToken) {
- *     console.log('Retry attempt number', context.attempt);
- *     // implementation here
- *   }
- * }
- *
- * const db = new Database();
- * db.getUserInfo(3).then(info => console.log('User 3 info:', info))
- * ```
- *
- * Note that it will force the return type to be a Promise, since that's
- * what policies return.
- */
-export function usePolicy(policy) {
-    return (_target, _key, descriptor) => {
-        const inner = descriptor.value;
-        if (typeof inner !== 'function') {
-            throw new Error(`Can only decorate functions with @cockatiel, got ${typeof inner}`);
-        }
-        descriptor.value = function (...args) {
-            const signal = args[args.length - 1] instanceof AbortSignal ? args.pop() : undefined;
-            return policy.execute(context => inner.apply(this, [...args, context]), signal);
-        };
-    };
-}
-/**
- * Creates a timeout policy.
- * @param duration - How long to wait before timing out execute()'d functions
- * @param strategy - Strategy for timeouts, "Cooperative" or "Aggressive".
- * A {@link CancellationToken} will be pass to any executed function, and in
- * cooperative timeouts we'll simply wait for that function to return or
- * throw. In aggressive timeouts, we'll immediately throw a
- * {@link TaskCancelledError} when the timeout is reached, in addition to
- * marking the passed token as failed.
- */
-export function timeout(duration, strategyOrOpts) {
-    return new TimeoutPolicy(duration, typeof strategyOrOpts === 'string' ? { strategy: strategyOrOpts } : strategyOrOpts);
-}
-export function wrap(...p) {
-    return {
-        _altReturn: undefined,
-        onFailure: p[0].onFailure,
-        onSuccess: p[0].onSuccess,
-        wrapped: p,
-        execute(fn, signal) {
-            const run = (context, i) => i === p.length
-                ? fn(context)
-                : p[i].execute(next => run({ ...context, ...next }, i + 1), context.signal);
-            return Promise.resolve(run({ signal }, 0));
-        },
-    };
-}
-/**
- * Creates a retry policy. The options should contain the backoff strategy to
- * use. Included strategies are:
- *  - {@link ConstantBackoff}
- *  - {@link ExponentialBackoff}
- *  - {@link IterableBackoff}
- *  - {@link DelegateBackoff} (advanced)
- *
- * For example:
- *
- * ```
- * import { handleAll, retry } from 'cockatiel';
- *
- * const policy = retry(handleAll, { backoff: new ExponentialBackoff() });
- * ```
- *
- * You can optionally pass in the `attempts` to limit the maximum number of
- * retry attempts per call.
- */
-export function retry(policy, opts) {
-    return new RetryPolicy({ backoff: opts.backoff || new ConstantBackoff(0), maxAttempts: opts.maxAttempts ?? Infinity }, new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter));
-}
-/**
- * Returns a circuit breaker for the policy. **Important**: you should share
- * your circuit breaker between executions of whatever function you're
- * wrapping for it to function!
- *
- * ```ts
- * import { SamplingBreaker, Policy } from 'cockatiel';
- *
- * // Break if more than 20% of requests fail in a 30 second time window:
- * const breaker = Policy
- *  .handleAll()
- *  .circuitBreaker(10_000, new SamplingBreaker(0.2, 30 * 1000));
- *
- * export function handleRequest() {
- *   return breaker.execute(() => getInfoFromDatabase());
- * }
- * ```
- *
- * @param halfOpenAfter Time after failures to try to open the circuit
- * breaker again.
- * @param breaker The circuit breaker to use. This package exports
- * ConsecutiveBreaker and SamplingBreakers for you to use.
- */
-export function circuitBreaker(policy, opts) {
-    return new CircuitBreakerPolicy(opts, new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter));
-}
-/**
- * Falls back to the given value in the event of an error.
- *
- * ```ts
- * import { Policy } from 'cockatiel';
- *
- * const fallback = Policy
- *  .handleType(DatabaseError)
- *  .fallback(() => getStaleData());
- *
- * export function handleRequest() {
- *   return fallback.execute(() => getInfoFromDatabase());
- * }
- * ```
- *
- * @param toValue Value to fall back to, or a function that creates the
- * value to return (any may return a promise)
- */
-export function fallback(policy, valueOrFactory) {
-    return new FallbackPolicy(new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter), 
-    // not technically type-safe, since if they actually want to _return_
-    // a function, that gets lost here. We'll just advice in the docs to
-    // use a higher-order function if necessary.
-    (typeof valueOrFactory === 'function' ? valueOrFactory : () => valueOrFactory));
-}
-//# sourceMappingURL=Policy.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/Policy.js.map b/node_modules/cockatiel/dist/esm/Policy.js.map
deleted file mode 100644
index 3302ac2..0000000
--- a/node_modules/cockatiel/dist/esm/Policy.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Policy.js","sourceRoot":"","sources":["../../src/Policy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConstantBackoff, IBackoffFactory } from './backoff/Backoff';\nimport { BulkheadPolicy } from './BulkheadPolicy';\nimport { CircuitBreakerPolicy, ICircuitBreakerOptions } from './CircuitBreakerPolicy';\nimport { Event } from './common/Event';\nimport { ExecuteWrapper } from './common/Executor';\nimport { FallbackPolicy } from './FallbackPolicy';\nimport { NoopPolicy } from './NoopPolicy';\nimport { IRetryBackoffContext, RetryPolicy } from './RetryPolicy';\nimport { TimeoutPolicy, TimeoutStrategy } from './TimeoutPolicy';\n\ntype Constructor<T> = new (...args: any) => T;\n\nconst typeFilter = <T>(cls: Constructor<T>, predicate?: (error: T) => boolean) =>\n  predicate ? (v: unknown) => v instanceof cls && predicate(v) : (v: unknown) => v instanceof cls;\n\nconst always = () => true;\nconst never = () => false;\n\nexport interface IBasePolicyOptions {\n  errorFilter: (error: Error) => boolean;\n  resultFilter: (result: unknown) => boolean;\n}\n\n/**\n * The reason for a call failure. Either an error, or the a value that was\n * marked as a failure (when using result filtering).\n */\nexport type FailureReason<ReturnType> = { error: Error } | { value: ReturnType };\n\n/**\n * Event emitted on the `onFailure` calls.\n */\nexport interface IFailureEvent {\n  /**\n   * Call duration, in milliseconds (with nanosecond precision, as the OS allows).\n   */\n  duration: number;\n\n  /**\n   * Whether the error was handled by the policy.\n   */\n  handled: boolean;\n\n  /**\n   * The reason for the error.\n   */\n  reason: FailureReason<unknown>;\n}\n\n/**\n * Event emitted on the `onSuccess` calls.\n */\nexport interface ISuccessEvent {\n  /**\n   * Call duration, in milliseconds (with nanosecond precision, as the OS allows).\n   */\n  duration: number;\n}\n\nexport interface IDefaultPolicyContext {\n  /**\n   * Abort signal for the operation. This is propagated through multiple\n   * retry policies.\n   */\n  signal: AbortSignal;\n}\n\n/**\n * IPolicy is the type of all policies that Cockatiel provides. It describes\n * an execute() function which takes a generic argument.\n */\nexport interface IPolicy<\n  ContextType extends IDefaultPolicyContext = IDefaultPolicyContext,\n  AltReturn = never,\n> {\n  /**\n   * Virtual property only used for TypeScript--will not actually be defined.\n   * @deprecated This property does not exist\n   */\n  readonly _altReturn: AltReturn;\n\n  /**\n   * Fires on the policy when a request successfully completes and some\n   * successful value will be returned. In a retry policy, this is fired once\n   * even if the request took multiple retries to succeed.\n   */\n  readonly onSuccess: Event<ISuccessEvent>;\n\n  /**\n   * Fires on the policy when a request fails *due to a handled reason* fails\n   * and will give rejection to the called.\n   */\n  readonly onFailure: Event<IFailureEvent>;\n\n  /**\n   * Runs the function through behavior specified by the policy.\n   */\n  execute<T>(\n    fn: (context: ContextType) => PromiseLike<T> | T,\n    signal?: AbortSignal,\n  ): Promise<T | AltReturn>;\n}\n\nexport interface IMergedPolicy<A extends IDefaultPolicyContext, B, W extends IPolicy<any, any>[]>\n  extends IPolicy<A, B> {\n  readonly wrapped: W;\n}\n\ntype MergePolicies<A, B> =\n  A extends IPolicy<infer A1, any>\n    ? B extends IPolicy<infer B1, any>\n      ? IMergedPolicy<\n          A1 & B1,\n          A['_altReturn'] | B['_altReturn'],\n          B extends IMergedPolicy<any, any, infer W> ? [A, ...W] : [A, B]\n        >\n      : never\n    : never;\n\nexport class Policy {\n  /**\n   * Factory that builds a base set of filters that can be used in circuit\n   * breakers, retries, etc.\n   */\n  constructor(public readonly options: Readonly<IBasePolicyOptions>) {}\n\n  /**\n   * Allows the policy to additionally handles errors of the given type.\n   *\n   * @param cls Class constructor to check that the error is an instance of.\n   * @param predicate If provided, a function to be called with the error\n   * which should return \"true\" if we want to handle this error.\n   * @example\n   * ```js\n   * // retry both network errors and response errors with a 503 status code\n   * new Policy()\n   *  .orType(NetworkError)\n   *  .orType(ResponseError, err => err.statusCode === 503)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n    const filter = typeFilter(cls, predicate);\n    return new Policy({\n      ...this.options,\n      errorFilter: e => this.options.errorFilter(e) || filter(e),\n    });\n  }\n\n  /**\n   * Allows the policy to additionally handles errors that pass the given\n   * predicate function.\n   *\n   * @param predicate Takes any thrown error, and returns true if it should\n   * be retried by this policy.\n   * @example\n   * ```js\n   * // only retry if the error has a \"shouldBeRetried\" property set\n   * new Policy()\n   *  .orWhen(err => err.shouldBeRetried === true)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orWhen(predicate: (error: Error) => boolean) {\n    return new Policy({\n      ...this.options,\n      errorFilter: e => this.options.errorFilter(e) || predicate(e),\n    });\n  }\n\n  /**\n   * Adds handling for return values. The predicate will be called with\n   * the return value of the executed function,\n   *\n   * @param predicate Takes the returned value, and returns true if it\n   * should be retried by this policy.\n   * @example\n   * ```js\n   * // retry when the response status code is a 5xx\n   * new Policy()\n   *  .orResultWhen(res => res.statusCode >= 500)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orWhenResult(predicate: (r: unknown) => boolean) {\n    return new Policy({\n      ...this.options,\n      resultFilter: r => this.options.resultFilter(r) || predicate(r),\n    });\n  }\n\n  /**\n   * Adds handling for return values. The predicate will be called with\n   * the return value of the executed function,\n   *\n   * @param predicate Takes the returned value, and returns true if it\n   * should be retried by this policy.\n   * @example\n   * ```js\n   * // retry when the response status code is a 5xx\n   * new Policy()\n   *  .orResultType(res => res.statusCode >= 500)\n   *  .retry()\n   *  .attempts(3)\n   *  .execute(() => getJsonFrom('https://example.com'));\n   * ```\n   */\n  public orResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n    const filter = typeFilter(cls, predicate);\n    return new Policy({\n      ...this.options,\n      resultFilter: r => this.options.resultFilter(r) || filter(r),\n    });\n  }\n}\n\nexport const noop = new NoopPolicy();\n\n/**\n * A policy that handles all errors.\n */\nexport const handleAll = new Policy({ errorFilter: always, resultFilter: never });\n\n/**\n * See {@link Policy.orType} for usage.\n */\nexport function handleType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n  return new Policy({ errorFilter: typeFilter(cls, predicate), resultFilter: never });\n}\n\n/**\n * See {@link Policy.orWhen} for usage.\n */\nexport function handleWhen(predicate: (error: Error) => boolean) {\n  return new Policy({ errorFilter: predicate, resultFilter: never });\n}\n/**\n * See {@link Policy.orResultType} for usage.\n */\nexport function handleResultType<T>(cls: Constructor<T>, predicate?: (error: T) => boolean) {\n  return new Policy({ errorFilter: never, resultFilter: typeFilter(cls, predicate) });\n}\n\n/**\n * See {@link Policy.orWhenResult} for usage.\n */\nexport function handleWhenResult(predicate: (error: unknown) => boolean) {\n  return new Policy({ errorFilter: never, resultFilter: predicate });\n}\n\n/**\n * Creates a bulkhead--a policy that limits the number of concurrent calls.\n */\nexport function bulkhead(limit: number, queue: number = 0) {\n  return new BulkheadPolicy(limit, queue);\n}\n\n/**\n * A decorator that can be used to wrap class methods and apply the given\n * policy to them. It also adds the last argument normally given in\n * {@link Policy.execute} as the last argument in the function call.\n * For example:\n *\n * ```ts\n * import { usePolicy, retry, handleAll } from 'cockatiel';\n *\n * const retry = retry(handleAll, { maxAttempts: 3 });\n *\n * class Database {\n *   @usePolicy(retry)\n *   public getUserInfo(userId, context, cancellationToken) {\n *     console.log('Retry attempt number', context.attempt);\n *     // implementation here\n *   }\n * }\n *\n * const db = new Database();\n * db.getUserInfo(3).then(info => console.log('User 3 info:', info))\n * ```\n *\n * Note that it will force the return type to be a Promise, since that's\n * what policies return.\n */\nexport function usePolicy(policy: IPolicy<IDefaultPolicyContext, never>) {\n  return (_target: unknown, _key: string, descriptor: PropertyDescriptor) => {\n    const inner = descriptor.value;\n    if (typeof inner !== 'function') {\n      throw new Error(`Can only decorate functions with @cockatiel, got ${typeof inner}`);\n    }\n\n    descriptor.value = function (this: unknown, ...args: any[]) {\n      const signal = args[args.length - 1] instanceof AbortSignal ? args.pop() : undefined;\n      return policy.execute(context => inner.apply(this, [...args, context]), signal);\n    };\n  };\n}\n\n/**\n * Creates a timeout policy.\n * @param duration - How long to wait before timing out execute()'d functions\n * @param strategy - Strategy for timeouts, \"Cooperative\" or \"Aggressive\".\n * A {@link CancellationToken} will be pass to any executed function, and in\n * cooperative timeouts we'll simply wait for that function to return or\n * throw. In aggressive timeouts, we'll immediately throw a\n * {@link TaskCancelledError} when the timeout is reached, in addition to\n * marking the passed token as failed.\n */\nexport function timeout(\n  duration: number,\n  strategyOrOpts: TimeoutStrategy | { strategy: TimeoutStrategy; abortOnReturn: boolean },\n) {\n  return new TimeoutPolicy(\n    duration,\n    typeof strategyOrOpts === 'string' ? { strategy: strategyOrOpts } : strategyOrOpts,\n  );\n}\n\n/**\n * Wraps the given set of policies into a single policy. For instance, this:\n *\n * ```js\n * retry.execute(() =>\n *  breaker.execute(() =>\n *    timeout.execute(({ cancellationToken }) => getData(cancellationToken))))\n * ```\n *\n * Is the equivalent to:\n *\n * ```js\n * Policy\n *  .wrap(retry, breaker, timeout)\n *  .execute(({ cancellationToken }) => getData(cancellationToken)));\n * ```\n *\n * The `context` argument passed to the executed function is the merged object\n * of all previous policies.\n *\n */\n// The types here a certain unattrative. Ideally we could do\n// `wrap<A, B>(p: IPolicy<A, B>): IPolicy<A, B>`, but TS doesn't narrow the\n// types well in that scenario (unless p is explicitly typed as an IPolicy\n// and not some implementation) and returns `IPolicy<void, unknown>` and\n// the like. This is the best solution I've found for it.\nexport function wrap<A extends IPolicy<IDefaultPolicyContext, unknown>>(p1: A): A;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B): MergePolicies<A, B>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B, p3: C): MergePolicies<C, MergePolicies<A, B>>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n  D extends IPolicy<IDefaultPolicyContext, unknown>,\n>(p1: A, p2: B, p3: C, p4: D): MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>;\nexport function wrap<\n  A extends IPolicy<IDefaultPolicyContext, unknown>,\n  B extends IPolicy<IDefaultPolicyContext, unknown>,\n  C extends IPolicy<IDefaultPolicyContext, unknown>,\n  D extends IPolicy<IDefaultPolicyContext, unknown>,\n  E extends IPolicy<IDefaultPolicyContext, unknown>,\n>(\n  p1: A,\n  p2: B,\n  p3: C,\n  p4: D,\n  p5: E,\n): MergePolicies<E, MergePolicies<D, MergePolicies<C, MergePolicies<A, B>>>>;\nexport function wrap<C extends IDefaultPolicyContext, A>(...p: Array<IPolicy<C, A>>): IPolicy<C, A>;\nexport function wrap<C extends IDefaultPolicyContext, A>(\n  ...p: Array<IPolicy<C, A>>\n): IMergedPolicy<C, A, IPolicy<C, A>[]> {\n  return {\n    _altReturn: undefined as any,\n    onFailure: p[0].onFailure,\n    onSuccess: p[0].onSuccess,\n    wrapped: p,\n    execute<T>(fn: (context: C) => PromiseLike<T> | T, signal: AbortSignal): Promise<T | A> {\n      const run = (context: C, i: number): PromiseLike<T | A> | T | A =>\n        i === p.length\n          ? fn(context)\n          : p[i].execute(next => run({ ...context, ...next }, i + 1), context.signal);\n      return Promise.resolve(run({ signal } as C, 0));\n    },\n  };\n}\n\n/**\n * Creates a retry policy. The options should contain the backoff strategy to\n * use. Included strategies are:\n *  - {@link ConstantBackoff}\n *  - {@link ExponentialBackoff}\n *  - {@link IterableBackoff}\n *  - {@link DelegateBackoff} (advanced)\n *\n * For example:\n *\n * ```\n * import { handleAll, retry } from 'cockatiel';\n *\n * const policy = retry(handleAll, { backoff: new ExponentialBackoff() });\n * ```\n *\n * You can optionally pass in the `attempts` to limit the maximum number of\n * retry attempts per call.\n */\nexport function retry(\n  policy: Policy,\n  opts: {\n    maxAttempts?: number;\n    backoff?: IBackoffFactory<IRetryBackoffContext<unknown>>;\n  },\n) {\n  return new RetryPolicy(\n    { backoff: opts.backoff || new ConstantBackoff(0), maxAttempts: opts.maxAttempts ?? Infinity },\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n  );\n}\n\n/**\n * Returns a circuit breaker for the policy. **Important**: you should share\n * your circuit breaker between executions of whatever function you're\n * wrapping for it to function!\n *\n * ```ts\n * import { SamplingBreaker, Policy } from 'cockatiel';\n *\n * // Break if more than 20% of requests fail in a 30 second time window:\n * const breaker = Policy\n *  .handleAll()\n *  .circuitBreaker(10_000, new SamplingBreaker(0.2, 30 * 1000));\n *\n * export function handleRequest() {\n *   return breaker.execute(() => getInfoFromDatabase());\n * }\n * ```\n *\n * @param halfOpenAfter Time after failures to try to open the circuit\n * breaker again.\n * @param breaker The circuit breaker to use. This package exports\n * ConsecutiveBreaker and SamplingBreakers for you to use.\n */\nexport function circuitBreaker(policy: Policy, opts: ICircuitBreakerOptions) {\n  return new CircuitBreakerPolicy(\n    opts,\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n  );\n}\n\n/**\n * Falls back to the given value in the event of an error.\n *\n * ```ts\n * import { Policy } from 'cockatiel';\n *\n * const fallback = Policy\n *  .handleType(DatabaseError)\n *  .fallback(() => getStaleData());\n *\n * export function handleRequest() {\n *   return fallback.execute(() => getInfoFromDatabase());\n * }\n * ```\n *\n * @param toValue Value to fall back to, or a function that creates the\n * value to return (any may return a promise)\n */\nexport function fallback<R>(policy: Policy, valueOrFactory: (() => Promise<R> | R) | R) {\n  return new FallbackPolicy(\n    new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter),\n    // not technically type-safe, since if they actually want to _return_\n    // a function, that gets lost here. We'll just advice in the docs to\n    // use a higher-order function if necessary.\n    (typeof valueOrFactory === 'function' ? valueOrFactory : () => valueOrFactory) as () => R,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/RetryPolicy.d.ts b/node_modules/cockatiel/dist/esm/RetryPolicy.d.ts
deleted file mode 100644
index 11d86ca..0000000
--- a/node_modules/cockatiel/dist/esm/RetryPolicy.d.ts
+++ /dev/null
@@ -1,72 +0,0 @@
-import { IBackoffFactory } from './backoff/Backoff';
-import { ExecuteWrapper } from './common/Executor';
-import { FailureReason, IDefaultPolicyContext, IPolicy } from './Policy';
-/**
- * Context passed into the execute method of the builder.
- */
-export interface IRetryContext extends IDefaultPolicyContext {
-    /**
-     * The retry attempt, starting at 1 for calls into backoffs.
-     */
-    attempt: number;
-}
-/**
- * Context passed into backoff delegate.
- */
-export interface IRetryBackoffContext<R> extends IRetryContext {
-    /**
-     * The result of the last method call. Either a thrown error, or a value
-     * that we determined should be retried upon.
-     */
-    result: FailureReason<R>;
-}
-export interface IRetryPolicyConfig {
-    backoff: IBackoffFactory<IRetryBackoffContext<unknown>>;
-    maxAttempts: number;
-    /**
-     * Whether to unreference the internal timer. This means the policy will not
-     * keep the Node.js even loop active. Defaults to `false`.
-     */
-    unref?: boolean;
-}
-export declare class RetryPolicy implements IPolicy<IRetryContext> {
-    private options;
-    private readonly executor;
-    readonly _altReturn: never;
-    private readonly onGiveUpEmitter;
-    private readonly onRetryEmitter;
-    /**
-     * @inheritdoc
-     */
-    readonly onSuccess: import("./common/Event").Event<import("./Policy").ISuccessEvent>;
-    /**
-     * @inheritdoc
-     */
-    readonly onFailure: import("./common/Event").Event<import("./Policy").IFailureEvent>;
-    /**
-     * Emitter that fires when we retry a call, before any backoff.
-     *
-     */
-    readonly onRetry: import("./common/Event").Event<FailureReason<unknown> & {
-        delay: number;
-        attempt: number;
-    }>;
-    /**
-     * Emitter that fires when we're no longer retrying a call and are giving up.
-     */
-    readonly onGiveUp: import("./common/Event").Event<FailureReason<unknown>>;
-    constructor(options: Readonly<IRetryPolicyConfig>, executor: ExecuteWrapper);
-    /**
-     * When retrying, a referenced timer is created. This means the Node.js event
-     * loop is kept active while we're delaying a retried call. Calling this
-     * method on the retry builder will unreference the timer, allowing the
-     * process to exit even if a retry might still be pending.
-     */
-    dangerouslyUnref(): RetryPolicy;
-    /**
-     * Executes the given function with retries.
-     * @param fn Function to run
-     * @returns a Promise that resolves or rejects with the function results.
-     */
-    execute<T>(fn: (context: IRetryContext) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
-}
diff --git a/node_modules/cockatiel/dist/esm/RetryPolicy.js b/node_modules/cockatiel/dist/esm/RetryPolicy.js
deleted file mode 100644
index 633e19a..0000000
--- a/node_modules/cockatiel/dist/esm/RetryPolicy.js
+++ /dev/null
@@ -1,75 +0,0 @@
-import { ConstantBackoff } from './backoff/ConstantBackoff';
-import { neverAbortedSignal } from './common/abort';
-import { EventEmitter } from './common/Event';
-const delay = (duration, unref) => new Promise(resolve => {
-    const timer = setTimeout(resolve, duration);
-    if (unref) {
-        timer.unref();
-    }
-});
-export class RetryPolicy {
-    constructor(options, executor) {
-        this.options = options;
-        this.executor = executor;
-        this.onGiveUpEmitter = new EventEmitter();
-        this.onRetryEmitter = new EventEmitter();
-        /**
-         * @inheritdoc
-         */
-        this.onSuccess = this.executor.onSuccess;
-        /**
-         * @inheritdoc
-         */
-        this.onFailure = this.executor.onFailure;
-        /**
-         * Emitter that fires when we retry a call, before any backoff.
-         *
-         */
-        this.onRetry = this.onRetryEmitter.addListener;
-        /**
-         * Emitter that fires when we're no longer retrying a call and are giving up.
-         */
-        this.onGiveUp = this.onGiveUpEmitter.addListener;
-    }
-    /**
-     * When retrying, a referenced timer is created. This means the Node.js event
-     * loop is kept active while we're delaying a retried call. Calling this
-     * method on the retry builder will unreference the timer, allowing the
-     * process to exit even if a retry might still be pending.
-     */
-    dangerouslyUnref() {
-        return new RetryPolicy({ ...this.options, unref: true }, this.executor.clone());
-    }
-    /**
-     * Executes the given function with retries.
-     * @param fn Function to run
-     * @returns a Promise that resolves or rejects with the function results.
-     */
-    async execute(fn, signal = neverAbortedSignal) {
-        const factory = this.options.backoff || new ConstantBackoff(0);
-        let backoff;
-        for (let retries = 0;; retries++) {
-            const result = await this.executor.invoke(fn, { attempt: retries, signal });
-            if ('success' in result) {
-                return result.success;
-            }
-            if (!signal.aborted && retries < this.options.maxAttempts) {
-                const context = { attempt: retries + 1, signal, result };
-                backoff = backoff ? backoff.next(context) : factory.next(context);
-                const delayDuration = backoff.duration;
-                const delayPromise = delay(delayDuration, !!this.options.unref);
-                // A little sneaky reordering here lets us use Sinon's fake timers
-                // when we get an emission in our tests.
-                this.onRetryEmitter.emit({ ...result, delay: delayDuration, attempt: retries + 1 });
-                await delayPromise;
-                continue;
-            }
-            this.onGiveUpEmitter.emit(result);
-            if ('error' in result) {
-                throw result.error;
-            }
-            return result.value;
-        }
-    }
-}
-//# sourceMappingURL=RetryPolicy.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/RetryPolicy.js.map b/node_modules/cockatiel/dist/esm/RetryPolicy.js.map
deleted file mode 100644
index ce93285..0000000
--- a/node_modules/cockatiel/dist/esm/RetryPolicy.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"RetryPolicy.js","sourceRoot":"","sources":["../../src/RetryPolicy.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,eAAe,EAAE,MAAM,2BAA2B,CAAC;AAC5D,OAAO,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AACpD,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAI9C,MAAM,KAAK,GAAG,CAAC,QAAgB,EAAE,KAAc,EAAE,EAAE,CACjD,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;IACpB,MAAM,KAAK,GAAG,UAAU,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC5C,IAAI,KAAK,EAAE,CAAC;QACV,KAAK,CAAC,KAAK,EAAE,CAAC;IAChB,CAAC;AACH,CAAC,CAAC,CAAC;AAkCL,MAAM,OAAO,WAAW;IA6BtB,YACU,OAAqC,EAC5B,QAAwB;QADjC,YAAO,GAAP,OAAO,CAA8B;QAC5B,aAAQ,GAAR,QAAQ,CAAgB;QA5B1B,oBAAe,GAAG,IAAI,YAAY,EAA0B,CAAC;QAC7D,mBAAc,GAAG,IAAI,YAAY,EAE/C,CAAC;QAEJ;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;WAEG;QACa,cAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;QAEpD;;;WAGG;QACa,YAAO,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC;QAE1D;;WAEG;QACa,aAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC;IAKzD,CAAC;IAEJ;;;;;OAKG;IACI,gBAAgB;QACrB,OAAO,IAAI,WAAW,CAAC,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC;IAClF,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,OAAO,CAClB,EAAkD,EAClD,MAAM,GAAG,kBAAkB;QAE3B,MAAM,OAAO,GACX,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC;QACjD,IAAI,OAA4D,CAAC;QACjE,KAAK,IAAI,OAAO,GAAG,CAAC,GAAI,OAAO,EAAE,EAAE,CAAC;YAClC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;YAC5E,IAAI,SAAS,IAAI,MAAM,EAAE,CAAC;gBACxB,OAAO,MAAM,CAAC,OAAO,CAAC;YACxB,CAAC;YAED,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;gBAC1D,MAAM,OAAO,GAAG,EAAE,OAAO,EAAE,OAAO,GAAG,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;gBACzD,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAClE,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,CAAC;gBACvC,MAAM,YAAY,GAAG,KAAK,CAAC,aAAa,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBAChE,kEAAkE;gBAClE,wCAAwC;gBACxC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,OAAO,EAAE,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC;gBACpF,MAAM,YAAY,CAAC;gBACnB,SAAS;YACX,CAAC;YAED,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAClC,IAAI,OAAO,IAAI,MAAM,EAAE,CAAC;gBACtB,MAAM,MAAM,CAAC,KAAK,CAAC;YACrB,CAAC;YAED,OAAO,MAAM,CAAC,KAAK,CAAC;QACtB,CAAC;IACH,CAAC;CACF","sourcesContent":["import { IBackoff, IBackoffFactory } from './backoff/Backoff';\nimport { ConstantBackoff } from './backoff/ConstantBackoff';\nimport { neverAbortedSignal } from './common/abort';\nimport { EventEmitter } from './common/Event';\nimport { ExecuteWrapper } from './common/Executor';\nimport { FailureReason, IDefaultPolicyContext, IPolicy } from './Policy';\n\nconst delay = (duration: number, unref: boolean) =>\n  new Promise(resolve => {\n    const timer = setTimeout(resolve, duration);\n    if (unref) {\n      timer.unref();\n    }\n  });\n\n/**\n * Context passed into the execute method of the builder.\n */\nexport interface IRetryContext extends IDefaultPolicyContext {\n  /**\n   * The retry attempt, starting at 1 for calls into backoffs.\n   */\n  attempt: number;\n}\n\n/**\n * Context passed into backoff delegate.\n */\nexport interface IRetryBackoffContext<R> extends IRetryContext {\n  /**\n   * The result of the last method call. Either a thrown error, or a value\n   * that we determined should be retried upon.\n   */\n  result: FailureReason<R>;\n}\n\nexport interface IRetryPolicyConfig {\n  backoff: IBackoffFactory<IRetryBackoffContext<unknown>>;\n  maxAttempts: number;\n\n  /**\n   * Whether to unreference the internal timer. This means the policy will not\n   * keep the Node.js even loop active. Defaults to `false`.\n   */\n  unref?: boolean;\n}\n\nexport class RetryPolicy implements IPolicy<IRetryContext> {\n  declare readonly _altReturn: never;\n\n  private readonly onGiveUpEmitter = new EventEmitter<FailureReason<unknown>>();\n  private readonly onRetryEmitter = new EventEmitter<\n    FailureReason<unknown> & { delay: number; attempt: number }\n  >();\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * Emitter that fires when we retry a call, before any backoff.\n   *\n   */\n  public readonly onRetry = this.onRetryEmitter.addListener;\n\n  /**\n   * Emitter that fires when we're no longer retrying a call and are giving up.\n   */\n  public readonly onGiveUp = this.onGiveUpEmitter.addListener;\n\n  constructor(\n    private options: Readonly<IRetryPolicyConfig>,\n    private readonly executor: ExecuteWrapper,\n  ) {}\n\n  /**\n   * When retrying, a referenced timer is created. This means the Node.js event\n   * loop is kept active while we're delaying a retried call. Calling this\n   * method on the retry builder will unreference the timer, allowing the\n   * process to exit even if a retry might still be pending.\n   */\n  public dangerouslyUnref() {\n    return new RetryPolicy({ ...this.options, unref: true }, this.executor.clone());\n  }\n\n  /**\n   * Executes the given function with retries.\n   * @param fn Function to run\n   * @returns a Promise that resolves or rejects with the function results.\n   */\n  public async execute<T>(\n    fn: (context: IRetryContext) => PromiseLike<T> | T,\n    signal = neverAbortedSignal,\n  ): Promise<T> {\n    const factory: IBackoffFactory<IRetryBackoffContext<unknown>> =\n      this.options.backoff || new ConstantBackoff(0);\n    let backoff: IBackoff<IRetryBackoffContext<unknown>> | undefined;\n    for (let retries = 0; ; retries++) {\n      const result = await this.executor.invoke(fn, { attempt: retries, signal });\n      if ('success' in result) {\n        return result.success;\n      }\n\n      if (!signal.aborted && retries < this.options.maxAttempts) {\n        const context = { attempt: retries + 1, signal, result };\n        backoff = backoff ? backoff.next(context) : factory.next(context);\n        const delayDuration = backoff.duration;\n        const delayPromise = delay(delayDuration, !!this.options.unref);\n        // A little sneaky reordering here lets us use Sinon's fake timers\n        // when we get an emission in our tests.\n        this.onRetryEmitter.emit({ ...result, delay: delayDuration, attempt: retries + 1 });\n        await delayPromise;\n        continue;\n      }\n\n      this.onGiveUpEmitter.emit(result);\n      if ('error' in result) {\n        throw result.error;\n      }\n\n      return result.value;\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/TimeoutPolicy.d.ts b/node_modules/cockatiel/dist/esm/TimeoutPolicy.d.ts
deleted file mode 100644
index a7f38a3..0000000
--- a/node_modules/cockatiel/dist/esm/TimeoutPolicy.d.ts
+++ /dev/null
@@ -1,61 +0,0 @@
-import { Event } from './common/Event';
-import { ExecuteWrapper } from './common/Executor';
-import { IPolicy } from './Policy';
-export declare enum TimeoutStrategy {
-    /**
-     * Cooperative timeouts will simply revoke the inner cancellation token,
-     * assuming the caller handles cancellation and throws or returns appropriately.
-     */
-    Cooperative = "optimistic",
-    /**
-     * Aggressive cancellation immediately throws
-     */
-    Aggressive = "aggressive"
-}
-export interface ICancellationContext {
-    signal: AbortSignal;
-}
-export interface ITimeoutOptions {
-    /** Strategy for timeouts, "Cooperative", or "Accessive" */
-    strategy: TimeoutStrategy;
-    /**
-     * Whether the AbortSignal should be aborted when the
-     * function returns. Defaults to true.
-     */
-    abortOnReturn?: boolean;
-}
-export declare class TimeoutPolicy implements IPolicy<ICancellationContext> {
-    private readonly duration;
-    private readonly options;
-    private readonly executor;
-    private readonly unref;
-    readonly _altReturn: never;
-    private readonly timeoutEmitter;
-    /**
-     * @inheritdoc
-     */
-    readonly onTimeout: Event<void>;
-    /**
-     * @inheritdoc
-     */
-    readonly onFailure: Event<import("./Policy").IFailureEvent>;
-    /**
-     * @inheritdoc
-     */
-    readonly onSuccess: Event<import("./Policy").ISuccessEvent>;
-    constructor(duration: number, options: ITimeoutOptions, executor?: ExecuteWrapper, unref?: boolean);
-    /**
-     * When timing out, a referenced timer is created. This means the Node.js
-     * event loop is kept active while we're waiting for the timeout, as long as
-     * the function hasn't returned. Calling this method on the timeout builder
-     * will unreference the timer, allowing the process to exit even if a
-     * timeout might still be happening.
-     */
-    dangerouslyUnref(): TimeoutPolicy;
-    /**
-     * Executes the given function.
-     * @param fn Function to execute. Takes in a nested cancellation token.
-     * @throws a {@link TaskCancelledError} if a timeout occurs
-     */
-    execute<T>(fn: (context: ICancellationContext, signal: AbortSignal) => PromiseLike<T> | T, signal?: AbortSignal): Promise<T>;
-}
diff --git a/node_modules/cockatiel/dist/esm/TimeoutPolicy.js b/node_modules/cockatiel/dist/esm/TimeoutPolicy.js
deleted file mode 100644
index cd618dd..0000000
--- a/node_modules/cockatiel/dist/esm/TimeoutPolicy.js
+++ /dev/null
@@ -1,86 +0,0 @@
-import { deriveAbortController } from './common/abort';
-import { Event, EventEmitter, onAbort } from './common/Event';
-import { ExecuteWrapper, returnOrThrow } from './common/Executor';
-import { TaskCancelledError } from './errors/TaskCancelledError';
-export var TimeoutStrategy;
-(function (TimeoutStrategy) {
-    /**
-     * Cooperative timeouts will simply revoke the inner cancellation token,
-     * assuming the caller handles cancellation and throws or returns appropriately.
-     */
-    TimeoutStrategy["Cooperative"] = "optimistic";
-    /**
-     * Aggressive cancellation immediately throws
-     */
-    TimeoutStrategy["Aggressive"] = "aggressive";
-})(TimeoutStrategy || (TimeoutStrategy = {}));
-export class TimeoutPolicy {
-    constructor(duration, options, executor = new ExecuteWrapper(), unref = false) {
-        this.duration = duration;
-        this.options = options;
-        this.executor = executor;
-        this.unref = unref;
-        this.timeoutEmitter = new EventEmitter();
-        /**
-         * @inheritdoc
-         */
-        this.onTimeout = this.timeoutEmitter.addListener;
-        /**
-         * @inheritdoc
-         */
-        this.onFailure = this.executor.onFailure;
-        /**
-         * @inheritdoc
-         */
-        this.onSuccess = this.executor.onSuccess;
-    }
-    /**
-     * When timing out, a referenced timer is created. This means the Node.js
-     * event loop is kept active while we're waiting for the timeout, as long as
-     * the function hasn't returned. Calling this method on the timeout builder
-     * will unreference the timer, allowing the process to exit even if a
-     * timeout might still be happening.
-     */
-    dangerouslyUnref() {
-        const t = new TimeoutPolicy(this.duration, this.options, this.executor, true);
-        return t;
-    }
-    /**
-     * Executes the given function.
-     * @param fn Function to execute. Takes in a nested cancellation token.
-     * @throws a {@link TaskCancelledError} if a timeout occurs
-     */
-    async execute(fn, signal) {
-        const { ctrl: aborter, dispose: disposeAbort } = deriveAbortController(signal);
-        const timer = setTimeout(() => aborter.abort(), this.duration);
-        if (this.unref) {
-            timer.unref();
-        }
-        const context = { signal: aborter.signal };
-        const onceAborted = onAbort(aborter.signal);
-        const onCancelledListener = onceAborted.event(() => this.timeoutEmitter.emit());
-        try {
-            if (this.options.strategy === TimeoutStrategy.Cooperative) {
-                return returnOrThrow(await this.executor.invoke(fn, context, aborter.signal));
-            }
-            return await this.executor
-                .invoke(async () => Promise.race([
-                Promise.resolve(fn(context, aborter.signal)),
-                Event.toPromise(onceAborted.event).then(() => {
-                    throw new TaskCancelledError(`Operation timed out after ${this.duration}ms`);
-                }),
-            ]))
-                .then(returnOrThrow);
-        }
-        finally {
-            onCancelledListener.dispose();
-            onceAborted.dispose();
-            if (this.options.abortOnReturn !== false) {
-                aborter.abort();
-            }
-            clearTimeout(timer);
-            disposeAbort();
-        }
-    }
-}
-//# sourceMappingURL=TimeoutPolicy.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/TimeoutPolicy.js.map b/node_modules/cockatiel/dist/esm/TimeoutPolicy.js.map
deleted file mode 100644
index 4466ed5..0000000
--- a/node_modules/cockatiel/dist/esm/TimeoutPolicy.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"TimeoutPolicy.js","sourceRoot":"","sources":["../../src/TimeoutPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["import { deriveAbortController } from './common/abort';\nimport { Event, EventEmitter, onAbort } from './common/Event';\nimport { ExecuteWrapper, returnOrThrow } from './common/Executor';\nimport { TaskCancelledError } from './errors/TaskCancelledError';\nimport { IPolicy } from './Policy';\n\nexport enum TimeoutStrategy {\n  /**\n   * Cooperative timeouts will simply revoke the inner cancellation token,\n   * assuming the caller handles cancellation and throws or returns appropriately.\n   */\n  Cooperative = 'optimistic',\n\n  /**\n   * Aggressive cancellation immediately throws\n   */\n  Aggressive = 'aggressive',\n}\n\nexport interface ICancellationContext {\n  signal: AbortSignal;\n}\n\nexport interface ITimeoutOptions {\n  /** Strategy for timeouts, \"Cooperative\", or \"Accessive\" */\n  strategy: TimeoutStrategy;\n  /**\n   * Whether the AbortSignal should be aborted when the\n   * function returns. Defaults to true.\n   */\n  abortOnReturn?: boolean;\n}\n\nexport class TimeoutPolicy implements IPolicy<ICancellationContext> {\n  declare readonly _altReturn: never;\n\n  private readonly timeoutEmitter = new EventEmitter<void>();\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onTimeout = this.timeoutEmitter.addListener;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onFailure = this.executor.onFailure;\n\n  /**\n   * @inheritdoc\n   */\n  public readonly onSuccess = this.executor.onSuccess;\n\n  constructor(\n    private readonly duration: number,\n    private readonly options: ITimeoutOptions,\n    private readonly executor = new ExecuteWrapper(),\n    private readonly unref = false,\n  ) {}\n\n  /**\n   * When timing out, a referenced timer is created. This means the Node.js\n   * event loop is kept active while we're waiting for the timeout, as long as\n   * the function hasn't returned. Calling this method on the timeout builder\n   * will unreference the timer, allowing the process to exit even if a\n   * timeout might still be happening.\n   */\n  public dangerouslyUnref() {\n    const t = new TimeoutPolicy(this.duration, this.options, this.executor, true);\n    return t;\n  }\n\n  /**\n   * Executes the given function.\n   * @param fn Function to execute. Takes in a nested cancellation token.\n   * @throws a {@link TaskCancelledError} if a timeout occurs\n   */\n  public async execute<T>(\n    fn: (context: ICancellationContext, signal: AbortSignal) => PromiseLike<T> | T,\n    signal?: AbortSignal,\n  ): Promise<T> {\n    const { ctrl: aborter, dispose: disposeAbort } = deriveAbortController(signal);\n    const timer = setTimeout(() => aborter.abort(), this.duration);\n    if (this.unref) {\n      timer.unref();\n    }\n\n    const context = { signal: aborter.signal };\n\n    const onceAborted = onAbort(aborter.signal);\n    const onCancelledListener = onceAborted.event(() => this.timeoutEmitter.emit());\n\n    try {\n      if (this.options.strategy === TimeoutStrategy.Cooperative) {\n        return returnOrThrow(await this.executor.invoke(fn, context, aborter.signal));\n      }\n\n      return await this.executor\n        .invoke(async () =>\n          Promise.race<T>([\n            Promise.resolve(fn(context, aborter.signal)),\n            Event.toPromise(onceAborted.event).then(() => {\n              throw new TaskCancelledError(`Operation timed out after ${this.duration}ms`);\n            }),\n          ]),\n        )\n        .then(returnOrThrow);\n    } finally {\n      onCancelledListener.dispose();\n      onceAborted.dispose();\n      if (this.options.abortOnReturn !== false) {\n        aborter.abort();\n      }\n      clearTimeout(timer);\n      disposeAbort();\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/Backoff.d.ts b/node_modules/cockatiel/dist/esm/backoff/Backoff.d.ts
deleted file mode 100644
index 077d882..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/Backoff.d.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-/**
- * A generic type that returns backoff intervals.
- */
-export interface IBackoffFactory<T> {
-    /**
-     * Returns the first backoff duration.
-     */
-    next(context: T): IBackoff<T>;
-}
-/**
- * A generic type that returns backoff intervals.
- */
-export interface IBackoff<T> extends IBackoffFactory<T> {
-    /**
-     * Returns the number of milliseconds to wait for this backoff attempt.
-     */
-    readonly duration: number;
-}
-export * from './ConstantBackoff';
-export * from './DelegateBackoff';
-export * from './ExponentialBackoff';
-export * from './ExponentialBackoffGenerators';
-export * from './IterableBackoff';
diff --git a/node_modules/cockatiel/dist/esm/backoff/Backoff.js b/node_modules/cockatiel/dist/esm/backoff/Backoff.js
deleted file mode 100644
index d680f21..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/Backoff.js
+++ /dev/null
@@ -1,6 +0,0 @@
-export * from './ConstantBackoff';
-export * from './DelegateBackoff';
-export * from './ExponentialBackoff';
-export * from './ExponentialBackoffGenerators';
-export * from './IterableBackoff';
-//# sourceMappingURL=Backoff.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/Backoff.js.map b/node_modules/cockatiel/dist/esm/backoff/Backoff.js.map
deleted file mode 100644
index 46c8d10..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/Backoff.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Backoff.js","sourceRoot":"","sources":["../../../src/backoff/Backoff.ts"],"names":[],"mappings":"AAoBA,cAAc,mBAAmB,CAAC;AAClC,cAAc,mBAAmB,CAAC;AAClC,cAAc,sBAAsB,CAAC;AACrC,cAAc,gCAAgC,CAAC;AAC/C,cAAc,mBAAmB,CAAC","sourcesContent":["/**\n * A generic type that returns backoff intervals.\n */\nexport interface IBackoffFactory<T> {\n  /**\n   * Returns the first backoff duration.\n   */\n  next(context: T): IBackoff<T>;\n}\n\n/**\n * A generic type that returns backoff intervals.\n */\nexport interface IBackoff<T> extends IBackoffFactory<T> {\n  /**\n   * Returns the number of milliseconds to wait for this backoff attempt.\n   */\n  readonly duration: number;\n}\n\nexport * from './ConstantBackoff';\nexport * from './DelegateBackoff';\nexport * from './ExponentialBackoff';\nexport * from './ExponentialBackoffGenerators';\nexport * from './IterableBackoff';\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.d.ts b/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.d.ts
deleted file mode 100644
index 92bb51b..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.d.ts
+++ /dev/null
@@ -1,12 +0,0 @@
-import { IBackoff, IBackoffFactory } from './Backoff';
-export declare class ConstantBackoff implements IBackoffFactory<unknown> {
-    private readonly interval;
-    /**
-     * Backoff that returns a constant interval.
-     */
-    constructor(interval: number);
-    /**
-     * @inheritdoc
-     */
-    next(): IBackoff<unknown>;
-}
diff --git a/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.js b/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.js
deleted file mode 100644
index be09fa6..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.js
+++ /dev/null
@@ -1,21 +0,0 @@
-export class ConstantBackoff {
-    /**
-     * Backoff that returns a constant interval.
-     */
-    constructor(interval) {
-        this.interval = interval;
-    }
-    /**
-     * @inheritdoc
-     */
-    next() {
-        return instance(this.interval);
-    }
-}
-const instance = (interval) => ({
-    duration: interval,
-    next() {
-        return this;
-    },
-});
-//# sourceMappingURL=ConstantBackoff.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.js.map b/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.js.map
deleted file mode 100644
index 10911ed..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ConstantBackoff.js","sourceRoot":"","sources":["../../../src/backoff/ConstantBackoff.ts"],"names":[],"mappings":"AAEA,MAAM,OAAO,eAAe;IAC1B;;OAEG;IACH,YAA6B,QAAgB;QAAhB,aAAQ,GAAR,QAAQ,CAAQ;IAAG,CAAC;IAEjD;;OAEG;IACI,IAAI;QACT,OAAO,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACjC,CAAC;CACF;AAED,MAAM,QAAQ,GAAG,CAAC,QAAgB,EAAqB,EAAE,CAAC,CAAC;IACzD,QAAQ,EAAE,QAAQ;IAClB,IAAI;QACF,OAAO,IAAI,CAAC;IACd,CAAC;CACF,CAAC,CAAC","sourcesContent":["import { IBackoff, IBackoffFactory } from './Backoff';\n\nexport class ConstantBackoff implements IBackoffFactory<unknown> {\n  /**\n   * Backoff that returns a constant interval.\n   */\n  constructor(private readonly interval: number) {}\n\n  /**\n   * @inheritdoc\n   */\n  public next() {\n    return instance(this.interval);\n  }\n}\n\nconst instance = (interval: number): IBackoff<unknown> => ({\n  duration: interval,\n  next() {\n    return this;\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.d.ts b/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.d.ts
deleted file mode 100644
index 99fb8bb..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.d.ts
+++ /dev/null
@@ -1,18 +0,0 @@
-import { IBackoff, IBackoffFactory } from './Backoff';
-export type DelegateBackoffFn<T, S = void> = (context: T, state?: S) => {
-    delay: number;
-    state: S;
-} | number;
-export declare class DelegateBackoff<T, S = void> implements IBackoffFactory<T> {
-    private readonly fn;
-    /**
-     * Backoff that delegates to a user-provided function. The function takes
-     * the backoff context, and can optionally take (and return) a state value
-     * that will be passed into subsequent backoff requests.
-     */
-    constructor(fn: DelegateBackoffFn<T, S>);
-    /**
-     * @inheritdoc
-     */
-    next(context: T): IBackoff<T>;
-}
diff --git a/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.js b/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.js
deleted file mode 100644
index a14fed9..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.js
+++ /dev/null
@@ -1,26 +0,0 @@
-export class DelegateBackoff {
-    /**
-     * Backoff that delegates to a user-provided function. The function takes
-     * the backoff context, and can optionally take (and return) a state value
-     * that will be passed into subsequent backoff requests.
-     */
-    constructor(fn) {
-        this.fn = fn;
-    }
-    /**
-     * @inheritdoc
-     */
-    next(context) {
-        return instance(this.fn).next(context);
-    }
-}
-const instance = (fn, state, current = 0) => ({
-    duration: current,
-    next(context) {
-        const result = fn(context, state);
-        return typeof result === 'number'
-            ? instance(fn, state, result)
-            : instance(fn, result.state, result.delay);
-    },
-});
-//# sourceMappingURL=DelegateBackoff.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.js.map b/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.js.map
deleted file mode 100644
index 56dcc74..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/DelegateBackoff.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"DelegateBackoff.js","sourceRoot":"","sources":["../../../src/backoff/DelegateBackoff.ts"],"names":[],"mappings":"AAOA,MAAM,OAAO,eAAe;IAC1B;;;;OAIG;IACH,YAA6B,EAA2B;QAA3B,OAAE,GAAF,EAAE,CAAyB;IAAG,CAAC;IAE5D;;OAEG;IACI,IAAI,CAAC,OAAU;QACpB,OAAO,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC;CACF;AAED,MAAM,QAAQ,GAAG,CAAO,EAA2B,EAAE,KAAS,EAAE,OAAO,GAAG,CAAC,EAAe,EAAE,CAAC,CAAC;IAC5F,QAAQ,EAAE,OAAO;IACjB,IAAI,CAAC,OAAU;QACb,MAAM,MAAM,GAAG,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAClC,OAAO,OAAO,MAAM,KAAK,QAAQ;YAC/B,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,KAAK,EAAE,MAAM,CAAC;YAC7B,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;IAC/C,CAAC;CACF,CAAC,CAAC","sourcesContent":["import { IBackoff, IBackoffFactory } from './Backoff';\n\nexport type DelegateBackoffFn<T, S = void> = (\n  context: T,\n  state?: S,\n) => { delay: number; state: S } | number;\n\nexport class DelegateBackoff<T, S = void> implements IBackoffFactory<T> {\n  /**\n   * Backoff that delegates to a user-provided function. The function takes\n   * the backoff context, and can optionally take (and return) a state value\n   * that will be passed into subsequent backoff requests.\n   */\n  constructor(private readonly fn: DelegateBackoffFn<T, S>) {}\n\n  /**\n   * @inheritdoc\n   */\n  public next(context: T) {\n    return instance(this.fn).next(context);\n  }\n}\n\nconst instance = <T, S>(fn: DelegateBackoffFn<T, S>, state?: S, current = 0): IBackoff<T> => ({\n  duration: current,\n  next(context: T) {\n    const result = fn(context, state);\n    return typeof result === 'number'\n      ? instance(fn, state, result)\n      : instance(fn, result.state, result.delay);\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.d.ts b/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.d.ts
deleted file mode 100644
index f159d29..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.d.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-import { IBackoff, IBackoffFactory } from './Backoff';
-import { GeneratorFn } from './ExponentialBackoffGenerators';
-/**
- * Options passed into {@link ExponentialBackoff}.
- */
-export interface IExponentialBackoffOptions<S> {
-    /**
-     * Delay generator function to use. This package provides several of these/
-     * Defaults to "decorrelatedJitterGenerator", a good default for most
-     * scenarios (see the linked Polly issue).
-     *
-     * @see https://github.com/App-vNext/Polly/issues/530
-     * @see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
-     */
-    generator: GeneratorFn<S>;
-    /**
-     * Maximum delay, in milliseconds. Defaults to 30s.
-     */
-    maxDelay: number;
-    /**
-     * Backoff exponent. Defaults to 2.
-     */
-    exponent: number;
-    /**
-     * The initial, first delay of the backoff, in milliseconds.
-     * Defaults to 128ms.
-     */
-    initialDelay: number;
-}
-export declare class ExponentialBackoff<S> implements IBackoffFactory<unknown> {
-    private readonly options;
-    /**
-     * An implementation of exponential backoff.
-     */
-    constructor(options?: Partial<IExponentialBackoffOptions<S>>);
-    next(): IBackoff<unknown>;
-}
diff --git a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.js b/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.js
deleted file mode 100644
index 7a5cd44..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.js
+++ /dev/null
@@ -1,29 +0,0 @@
-import { decorrelatedJitterGenerator } from './ExponentialBackoffGenerators';
-const defaultOptions = {
-    generator: decorrelatedJitterGenerator,
-    maxDelay: 30000,
-    exponent: 2,
-    initialDelay: 128,
-};
-export class ExponentialBackoff {
-    /**
-     * An implementation of exponential backoff.
-     */
-    constructor(options) {
-        this.options = options ? { ...defaultOptions, ...options } : defaultOptions;
-    }
-    next() {
-        return instance(this.options).next(undefined);
-    }
-}
-/**
- * An implementation of exponential backoff.
- */
-const instance = (options, state, delay = 0, attempt = -1) => ({
-    duration: delay,
-    next() {
-        const [nextDelay, nextState] = options.generator(state, options);
-        return instance(options, nextState, nextDelay, attempt + 1);
-    },
-});
-//# sourceMappingURL=ExponentialBackoff.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.js.map b/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.js.map
deleted file mode 100644
index e0f3c39..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ExponentialBackoff.js","sourceRoot":"","sources":["../../../src/backoff/ExponentialBackoff.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,2BAA2B,EAAe,MAAM,gCAAgC,CAAC;AAiC1F,MAAM,cAAc,GAAoC;IACtD,SAAS,EAAE,2BAA2B;IACtC,QAAQ,EAAE,KAAK;IACf,QAAQ,EAAE,CAAC;IACX,YAAY,EAAE,GAAG;CAClB,CAAC;AAEF,MAAM,OAAO,kBAAkB;IAG7B;;OAEG;IACH,YAAY,OAAgD;QAC1D,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,cAAc,EAAE,GAAG,OAAO,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC;IAC9E,CAAC;IAEM,IAAI;QACT,OAAO,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAChD,CAAC;CACF;AAED;;GAEG;AACH,MAAM,QAAQ,GAAG,CACf,OAAsC,EACtC,KAAS,EACT,KAAK,GAAG,CAAC,EACT,OAAO,GAAG,CAAC,CAAC,EACO,EAAE,CAAC,CAAC;IACvB,QAAQ,EAAE,KAAK;IACf,IAAI;QACF,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,QAAQ,CAAC,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,GAAG,CAAC,CAAC,CAAC;IAC9D,CAAC;CACF,CAAC,CAAC","sourcesContent":["import { IBackoff, IBackoffFactory } from './Backoff';\nimport { decorrelatedJitterGenerator, GeneratorFn } from './ExponentialBackoffGenerators';\n\n/**\n * Options passed into {@link ExponentialBackoff}.\n */\nexport interface IExponentialBackoffOptions<S> {\n  /**\n   * Delay generator function to use. This package provides several of these/\n   * Defaults to \"decorrelatedJitterGenerator\", a good default for most\n   * scenarios (see the linked Polly issue).\n   *\n   * @see https://github.com/App-vNext/Polly/issues/530\n   * @see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n   */\n  generator: GeneratorFn<S>;\n\n  /**\n   * Maximum delay, in milliseconds. Defaults to 30s.\n   */\n  maxDelay: number;\n\n  /**\n   * Backoff exponent. Defaults to 2.\n   */\n  exponent: number;\n\n  /**\n   * The initial, first delay of the backoff, in milliseconds.\n   * Defaults to 128ms.\n   */\n  initialDelay: number;\n}\n\nconst defaultOptions: IExponentialBackoffOptions<any> = {\n  generator: decorrelatedJitterGenerator,\n  maxDelay: 30000,\n  exponent: 2,\n  initialDelay: 128,\n};\n\nexport class ExponentialBackoff<S> implements IBackoffFactory<unknown> {\n  private readonly options: IExponentialBackoffOptions<S>;\n\n  /**\n   * An implementation of exponential backoff.\n   */\n  constructor(options?: Partial<IExponentialBackoffOptions<S>>) {\n    this.options = options ? { ...defaultOptions, ...options } : defaultOptions;\n  }\n\n  public next() {\n    return instance(this.options).next(undefined);\n  }\n}\n\n/**\n * An implementation of exponential backoff.\n */\nconst instance = <S>(\n  options: IExponentialBackoffOptions<S>,\n  state?: S,\n  delay = 0,\n  attempt = -1,\n): IBackoff<unknown> => ({\n  duration: delay,\n  next() {\n    const [nextDelay, nextState] = options.generator(state, options);\n    return instance(options, nextState, nextDelay, attempt + 1);\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.d.ts b/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.d.ts
deleted file mode 100644
index 07546e7..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.d.ts
+++ /dev/null
@@ -1,25 +0,0 @@
-import { IExponentialBackoffOptions } from '../backoff/ExponentialBackoff';
-/**
- * Function used to get the next delay.
- */
-export type GeneratorFn<S> = (state: S | undefined, options: IExponentialBackoffOptions<S>) => [number, S];
-/**
- * Generator that creates a backoff with no jitter.
- */
-export declare const noJitterGenerator: GeneratorFn<number>;
-/**
- * Generator that randomizes an exponential backoff between [0, delay).
- */
-export declare const fullJitterGenerator: GeneratorFn<number>;
-/**
- * Generator that randomizes an exponential backoff between [0, delay).
- */
-export declare const halfJitterGenerator: GeneratorFn<number>;
-/**
- * Decorrelated jitter. This should be considered the optimal Jitter stategy
- * for most scenarios, as battle-tested in Polly.
- *
- * @see https://github.com/App-vNext/Polly/issues/530
- * @see https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry/blob/24cb116a2a320e82b01f57e13bfeaeff2725ccbf/src/Polly.Contrib.WaitAndRetry/Backoff.DecorrelatedJitterV2.cs
- */
-export declare const decorrelatedJitterGenerator: GeneratorFn<[number, number]>;
diff --git a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.js b/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.js
deleted file mode 100644
index f5ac6c8..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.js
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Generator that creates a backoff with no jitter.
- */
-export const noJitterGenerator = (attempts = 0, options) => [
-    Math.min(options.maxDelay, options.initialDelay * 2 ** attempts),
-    attempts + 1,
-];
-/**
- * Generator that randomizes an exponential backoff between [0, delay).
- */
-export const fullJitterGenerator = (state, options) => {
-    const [delay, next] = noJitterGenerator(state, options);
-    return [Math.floor(Math.random() * delay), next];
-};
-/**
- * Generator that randomizes an exponential backoff between [0, delay).
- */
-export const halfJitterGenerator = (attempts, options) => {
-    const [delay, next] = noJitterGenerator(attempts, options);
-    return [Math.floor((delay + Math.random() * delay) / 2), next];
-};
-/**
- * A factor used within the formula to help smooth the first calculated delay.
- */
-const pFactor = 4.0;
-/**
- *  A factor used to scale the median values of the retry times generated by
- * the formula to be _near_ whole seconds, to aid user comprehension. This
- * factor allows the median values to fall approximately at 1, 2, 4 etc
- * seconds, instead of 1.4, 2.8, 5.6, 11.2.
- */
-const rpScalingFactor = 1 / 1.4;
-/**
- * Decorrelated jitter. This should be considered the optimal Jitter stategy
- * for most scenarios, as battle-tested in Polly.
- *
- * @see https://github.com/App-vNext/Polly/issues/530
- * @see https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry/blob/24cb116a2a320e82b01f57e13bfeaeff2725ccbf/src/Polly.Contrib.WaitAndRetry/Backoff.DecorrelatedJitterV2.cs
- */
-export const decorrelatedJitterGenerator = (state, options) => {
-    const [attempt, prev] = state || [0, 0];
-    const t = attempt + Math.random();
-    const next = Math.pow(options.exponent, t) * Math.tanh(Math.sqrt(pFactor * t));
-    const formulaIntrinsicValue = isFinite(next) ? Math.max(0, next - prev) : Infinity;
-    return [
-        Math.min(formulaIntrinsicValue * rpScalingFactor * options.initialDelay, options.maxDelay),
-        [attempt + 1, next],
-    ];
-};
-//# sourceMappingURL=ExponentialBackoffGenerators.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.js.map b/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.js.map
deleted file mode 100644
index a1aefae..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ExponentialBackoffGenerators.js","sourceRoot":"","sources":["../../../src/backoff/ExponentialBackoffGenerators.ts"],"names":[],"mappings":"AAUA;;GAEG;AACH,MAAM,CAAC,MAAM,iBAAiB,GAAwB,CAAC,QAAQ,GAAG,CAAC,EAAE,OAAO,EAAE,EAAE,CAAC;IAC/E,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,YAAY,GAAG,CAAC,IAAI,QAAQ,CAAC;IAChE,QAAQ,GAAG,CAAC;CACb,CAAC;AAEF;;GAEG;AACH,MAAM,CAAC,MAAM,mBAAmB,GAAwB,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;IACzE,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IACxD,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;AACnD,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,CAAC,MAAM,mBAAmB,GAAwB,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;IAC5E,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,iBAAiB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC3D,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AACjE,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,OAAO,GAAG,GAAG,CAAC;AAEpB;;;;;GAKG;AACH,MAAM,eAAe,GAAG,CAAC,GAAG,GAAG,CAAC;AAEhC;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,2BAA2B,GAAkC,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;IAC3F,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACxC,MAAM,CAAC,GAAG,OAAO,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;IAClC,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;IAC/E,MAAM,qBAAqB,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;IACnF,OAAO;QACL,IAAI,CAAC,GAAG,CAAC,qBAAqB,GAAG,eAAe,GAAG,OAAO,CAAC,YAAY,EAAE,OAAO,CAAC,QAAQ,CAAC;QAC1F,CAAC,OAAO,GAAG,CAAC,EAAE,IAAI,CAAC;KACpB,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import { IExponentialBackoffOptions } from '../backoff/ExponentialBackoff';\n\n/**\n * Function used to get the next delay.\n */\nexport type GeneratorFn<S> = (\n  state: S | undefined,\n  options: IExponentialBackoffOptions<S>,\n) => [number, S];\n\n/**\n * Generator that creates a backoff with no jitter.\n */\nexport const noJitterGenerator: GeneratorFn<number> = (attempts = 0, options) => [\n  Math.min(options.maxDelay, options.initialDelay * 2 ** attempts),\n  attempts + 1,\n];\n\n/**\n * Generator that randomizes an exponential backoff between [0, delay).\n */\nexport const fullJitterGenerator: GeneratorFn<number> = (state, options) => {\n  const [delay, next] = noJitterGenerator(state, options);\n  return [Math.floor(Math.random() * delay), next];\n};\n\n/**\n * Generator that randomizes an exponential backoff between [0, delay).\n */\nexport const halfJitterGenerator: GeneratorFn<number> = (attempts, options) => {\n  const [delay, next] = noJitterGenerator(attempts, options);\n  return [Math.floor((delay + Math.random() * delay) / 2), next];\n};\n\n/**\n * A factor used within the formula to help smooth the first calculated delay.\n */\nconst pFactor = 4.0;\n\n/**\n *  A factor used to scale the median values of the retry times generated by\n * the formula to be _near_ whole seconds, to aid user comprehension. This\n * factor allows the median values to fall approximately at 1, 2, 4 etc\n * seconds, instead of 1.4, 2.8, 5.6, 11.2.\n */\nconst rpScalingFactor = 1 / 1.4;\n\n/**\n * Decorrelated jitter. This should be considered the optimal Jitter stategy\n * for most scenarios, as battle-tested in Polly.\n *\n * @see https://github.com/App-vNext/Polly/issues/530\n * @see https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry/blob/24cb116a2a320e82b01f57e13bfeaeff2725ccbf/src/Polly.Contrib.WaitAndRetry/Backoff.DecorrelatedJitterV2.cs\n */\nexport const decorrelatedJitterGenerator: GeneratorFn<[number, number]> = (state, options) => {\n  const [attempt, prev] = state || [0, 0];\n  const t = attempt + Math.random();\n  const next = Math.pow(options.exponent, t) * Math.tanh(Math.sqrt(pFactor * t));\n  const formulaIntrinsicValue = isFinite(next) ? Math.max(0, next - prev) : Infinity;\n  return [\n    Math.min(formulaIntrinsicValue * rpScalingFactor * options.initialDelay, options.maxDelay),\n    [attempt + 1, next],\n  ];\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.d.ts b/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.d.ts
deleted file mode 100644
index 4b51497..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.d.ts
+++ /dev/null
@@ -1,12 +0,0 @@
-import { IBackoff, IBackoffFactory } from './Backoff';
-export declare class IterableBackoff implements IBackoffFactory<unknown> {
-    private readonly durations;
-    /**
-     * Backoff that returns a number from an iterable.
-     */
-    constructor(durations: ReadonlyArray<number>);
-    /**
-     * @inheritdoc
-     */
-    next(_context: unknown): IBackoff<unknown>;
-}
diff --git a/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.js b/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.js
deleted file mode 100644
index 0365092..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.js
+++ /dev/null
@@ -1,21 +0,0 @@
-export class IterableBackoff {
-    /**
-     * Backoff that returns a number from an iterable.
-     */
-    constructor(durations) {
-        this.durations = durations;
-    }
-    /**
-     * @inheritdoc
-     */
-    next(_context) {
-        return instance(this.durations, 0);
-    }
-}
-const instance = (durations, index) => ({
-    duration: durations[index],
-    next() {
-        return index === durations.length - 1 ? this : instance(durations, index + 1);
-    },
-});
-//# sourceMappingURL=IterableBackoff.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.js.map b/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.js.map
deleted file mode 100644
index 0e8b6d3..0000000
--- a/node_modules/cockatiel/dist/esm/backoff/IterableBackoff.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"IterableBackoff.js","sourceRoot":"","sources":["../../../src/backoff/IterableBackoff.ts"],"names":[],"mappings":"AAEA,MAAM,OAAO,eAAe;IAC1B;;OAEG;IACH,YAA6B,SAAgC;QAAhC,cAAS,GAAT,SAAS,CAAuB;IAAG,CAAC;IAEjE;;OAEG;IACI,IAAI,CAAC,QAAiB;QAC3B,OAAO,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;IACrC,CAAC;CACF;AAED,MAAM,QAAQ,GAAG,CAAC,SAAgC,EAAE,KAAa,EAAqB,EAAE,CAAC,CAAC;IACxF,QAAQ,EAAE,SAAS,CAAC,KAAK,CAAC;IAC1B,IAAI;QACF,OAAO,KAAK,KAAK,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;IAChF,CAAC;CACF,CAAC,CAAC","sourcesContent":["import { IBackoff, IBackoffFactory } from './Backoff';\n\nexport class IterableBackoff implements IBackoffFactory<unknown> {\n  /**\n   * Backoff that returns a number from an iterable.\n   */\n  constructor(private readonly durations: ReadonlyArray<number>) {}\n\n  /**\n   * @inheritdoc\n   */\n  public next(_context: unknown) {\n    return instance(this.durations, 0);\n  }\n}\n\nconst instance = (durations: ReadonlyArray<number>, index: number): IBackoff<unknown> => ({\n  duration: durations[index],\n  next() {\n    return index === durations.length - 1 ? this : instance(durations, index + 1);\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/Breaker.d.ts b/node_modules/cockatiel/dist/esm/breaker/Breaker.d.ts
deleted file mode 100644
index 405f195..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/Breaker.d.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { CircuitState } from '../CircuitBreakerPolicy';
-/**
- * The breaker determines when the circuit breaker should open.
- */
-export interface IBreaker {
-    /**
-     * Gets or sets the internal state of the breaker. Used for serialization
-     * with {@link CircuitBreaker.toJSON}.
-     */
-    state: unknown;
-    /**
-     * Called when a call succeeds.
-     */
-    success(state: CircuitState): void;
-    /**
-     * Called when a call fails. Returns true if the circuit should open.
-     */
-    failure(state: CircuitState): boolean;
-}
-export * from './ConsecutiveBreaker';
-export * from './CountBreaker';
-export * from './SamplingBreaker';
diff --git a/node_modules/cockatiel/dist/esm/breaker/Breaker.js b/node_modules/cockatiel/dist/esm/breaker/Breaker.js
deleted file mode 100644
index 38ff820..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/Breaker.js
+++ /dev/null
@@ -1,4 +0,0 @@
-export * from './ConsecutiveBreaker';
-export * from './CountBreaker';
-export * from './SamplingBreaker';
-//# sourceMappingURL=Breaker.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/Breaker.js.map b/node_modules/cockatiel/dist/esm/breaker/Breaker.js.map
deleted file mode 100644
index 726ee6d..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/Breaker.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Breaker.js","sourceRoot":"","sources":["../../../src/breaker/Breaker.ts"],"names":[],"mappings":"AAuBA,cAAc,sBAAsB,CAAC;AACrC,cAAc,gBAAgB,CAAC;AAC/B,cAAc,mBAAmB,CAAC","sourcesContent":["import { CircuitState } from '../CircuitBreakerPolicy';\n\n/**\n * The breaker determines when the circuit breaker should open.\n */\nexport interface IBreaker {\n  /**\n   * Gets or sets the internal state of the breaker. Used for serialization\n   * with {@link CircuitBreaker.toJSON}.\n   */\n  state: unknown;\n\n  /**\n   * Called when a call succeeds.\n   */\n  success(state: CircuitState): void;\n\n  /**\n   * Called when a call fails. Returns true if the circuit should open.\n   */\n  failure(state: CircuitState): boolean;\n}\n\nexport * from './ConsecutiveBreaker';\nexport * from './CountBreaker';\nexport * from './SamplingBreaker';\n\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.d.ts b/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.d.ts
deleted file mode 100644
index 629a957..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.d.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { IBreaker } from './Breaker';
-export declare class ConsecutiveBreaker implements IBreaker {
-    private readonly threshold;
-    /**
-     * @inheritdoc
-     */
-    state: number;
-    /**
-     * ConsecutiveBreaker breaks if more than `threshold` exceptions are received
-     * over a time period.
-     */
-    constructor(threshold: number);
-    /**
-     * @inheritdoc
-     */
-    success(): void;
-    /**
-     * @inheritdoc
-     */
-    failure(): boolean;
-}
diff --git a/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.js b/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.js
deleted file mode 100644
index 2fdae6e..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.js
+++ /dev/null
@@ -1,26 +0,0 @@
-export class ConsecutiveBreaker {
-    /**
-     * ConsecutiveBreaker breaks if more than `threshold` exceptions are received
-     * over a time period.
-     */
-    constructor(threshold) {
-        this.threshold = threshold;
-        /**
-         * @inheritdoc
-         */
-        this.state = 0;
-    }
-    /**
-     * @inheritdoc
-     */
-    success() {
-        this.state = 0;
-    }
-    /**
-     * @inheritdoc
-     */
-    failure() {
-        return ++this.state >= this.threshold;
-    }
-}
-//# sourceMappingURL=ConsecutiveBreaker.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.js.map b/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.js.map
deleted file mode 100644
index 686d393..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/ConsecutiveBreaker.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ConsecutiveBreaker.js","sourceRoot":"","sources":["../../../src/breaker/ConsecutiveBreaker.ts"],"names":[],"mappings":"AAEA,MAAM,OAAO,kBAAkB;IAM7B;;;OAGG;IACH,YAA6B,SAAiB;QAAjB,cAAS,GAAT,SAAS,CAAQ;QAT9C;;WAEG;QACI,UAAK,GAAG,CAAC,CAAC;IAMgC,CAAC;IAElD;;OAEG;IACI,OAAO;QACZ,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IACjB,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,OAAO,EAAE,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC;IACxC,CAAC;CACF","sourcesContent":["import { IBreaker } from './Breaker';\n\nexport class ConsecutiveBreaker implements IBreaker {\n  /**\n   * @inheritdoc\n   */\n  public state = 0;\n\n  /**\n   * ConsecutiveBreaker breaks if more than `threshold` exceptions are received\n   * over a time period.\n   */\n  constructor(private readonly threshold: number) {}\n\n  /**\n   * @inheritdoc\n   */\n  public success() {\n    this.state = 0;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public failure() {\n    return ++this.state >= this.threshold;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/CountBreaker.d.ts b/node_modules/cockatiel/dist/esm/breaker/CountBreaker.d.ts
deleted file mode 100644
index 47d724b..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/CountBreaker.d.ts
+++ /dev/null
@@ -1,56 +0,0 @@
-import { CircuitState } from '../CircuitBreakerPolicy';
-import { IBreaker } from './Breaker';
-export interface ICountBreakerOptions {
-    /**
-     * Percentage (from 0 to 1) of requests that need to fail before we'll
-     * open the circuit.
-     */
-    threshold: number;
-    /**
-     * Size of the count based sliding window.
-     */
-    size: number;
-    /**
-     * Minimum number of calls needed to (potentially) open the circuit.
-     * Useful to avoid unnecessarily tripping when there are only few samples yet.
-     * Defaults to {@link ICountBreakerOptions.size}.
-     */
-    minimumNumberOfCalls?: number;
-}
-export declare class CountBreaker implements IBreaker {
-    private readonly threshold;
-    private readonly minimumNumberOfCalls;
-    /**
-     * The samples in the sliding window. `true` means "success", `false` means
-     * "failure" and `null` means that there is no sample yet.
-     */
-    private samples;
-    private successes;
-    private failures;
-    private currentSample;
-    /**
-     * @inheritdoc
-     */
-    get state(): unknown;
-    /**
-     * @inheritdoc
-     */
-    set state(value: unknown);
-    /**
-     * CountBreaker breaks if more than `threshold` percentage of the last `size`
-     * calls failed, so long as at least `minimumNumberOfCalls` calls have been
-     * performed (to avoid opening unnecessarily if there are only few samples
-     * in the sliding window yet).
-     */
-    constructor({ threshold, size, minimumNumberOfCalls }: ICountBreakerOptions);
-    /**
-     * @inheritdoc
-     */
-    success(state: CircuitState): void;
-    /**
-     * @inheritdoc
-     */
-    failure(state: CircuitState): boolean;
-    private reset;
-    private sample;
-}
diff --git a/node_modules/cockatiel/dist/esm/breaker/CountBreaker.js b/node_modules/cockatiel/dist/esm/breaker/CountBreaker.js
deleted file mode 100644
index 013749d..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/CountBreaker.js
+++ /dev/null
@@ -1,94 +0,0 @@
-import { CircuitState } from '../CircuitBreakerPolicy';
-export class CountBreaker {
-    /**
-     * @inheritdoc
-     */
-    get state() {
-        return {
-            samples: this.samples,
-            currentSample: this.currentSample,
-            failures: this.failures,
-            successes: this.successes,
-        };
-    }
-    /**
-     * @inheritdoc
-     */
-    set state(value) {
-        Object.assign(this, value);
-    }
-    /**
-     * CountBreaker breaks if more than `threshold` percentage of the last `size`
-     * calls failed, so long as at least `minimumNumberOfCalls` calls have been
-     * performed (to avoid opening unnecessarily if there are only few samples
-     * in the sliding window yet).
-     */
-    constructor({ threshold, size, minimumNumberOfCalls = size }) {
-        this.successes = 0;
-        this.failures = 0;
-        this.currentSample = 0;
-        if (threshold <= 0 || threshold >= 1) {
-            throw new RangeError(`CountBreaker threshold should be between (0, 1), got ${threshold}`);
-        }
-        if (!Number.isSafeInteger(size) || size < 1) {
-            throw new RangeError(`CountBreaker size should be a positive integer, got ${size}`);
-        }
-        if (!Number.isSafeInteger(minimumNumberOfCalls) ||
-            minimumNumberOfCalls < 1 ||
-            minimumNumberOfCalls > size) {
-            throw new RangeError(`CountBreaker size should be an integer between (1, size), got ${minimumNumberOfCalls}`);
-        }
-        this.threshold = threshold;
-        this.minimumNumberOfCalls = minimumNumberOfCalls;
-        this.samples = Array.from({ length: size }, () => null);
-    }
-    /**
-     * @inheritdoc
-     */
-    success(state) {
-        if (state === CircuitState.HalfOpen) {
-            this.reset();
-        }
-        this.sample(true);
-    }
-    /**
-     * @inheritdoc
-     */
-    failure(state) {
-        this.sample(false);
-        if (state !== CircuitState.Closed) {
-            return true;
-        }
-        const total = this.successes + this.failures;
-        if (total < this.minimumNumberOfCalls) {
-            return false;
-        }
-        if (this.failures > this.threshold * total) {
-            return true;
-        }
-        return false;
-    }
-    reset() {
-        this.samples.fill(null);
-        this.successes = 0;
-        this.failures = 0;
-    }
-    sample(success) {
-        const current = this.samples[this.currentSample];
-        if (current === true) {
-            this.successes--;
-        }
-        else if (current === false) {
-            this.failures--;
-        }
-        this.samples[this.currentSample] = success;
-        if (success) {
-            this.successes++;
-        }
-        else {
-            this.failures++;
-        }
-        this.currentSample = (this.currentSample + 1) % this.samples.length;
-    }
-}
-//# sourceMappingURL=CountBreaker.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/CountBreaker.js.map b/node_modules/cockatiel/dist/esm/breaker/CountBreaker.js.map
deleted file mode 100644
index 73a5621..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/CountBreaker.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"CountBreaker.js","sourceRoot":"","sources":["../../../src/breaker/CountBreaker.ts"],"names":[],"mappings":"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","sourcesContent":["import { CircuitState } from '../CircuitBreakerPolicy';\nimport { IBreaker } from './Breaker';\n\nexport interface ICountBreakerOptions {\n  /**\n   * Percentage (from 0 to 1) of requests that need to fail before we'll\n   * open the circuit.\n   */\n  threshold: number;\n\n  /**\n   * Size of the count based sliding window.\n   */\n  size: number;\n\n  /**\n   * Minimum number of calls needed to (potentially) open the circuit.\n   * Useful to avoid unnecessarily tripping when there are only few samples yet.\n   * Defaults to {@link ICountBreakerOptions.size}.\n   */\n  minimumNumberOfCalls?: number;\n}\n\n\ninterface ICountBreakerState {\n  samples: (boolean | null)[];\n  currentSample: number;\n  failures: number;\n  successes: number;\n}\n\n\nexport class CountBreaker implements IBreaker {\n  private readonly threshold: number;\n  private readonly minimumNumberOfCalls: number;\n\n  /**\n   * The samples in the sliding window. `true` means \"success\", `false` means\n   * \"failure\" and `null` means that there is no sample yet.\n   */\n  private samples: (boolean | null)[];\n  private successes = 0;\n  private failures = 0;\n  private currentSample = 0;\n\n  /**\n   * @inheritdoc\n   */\n  public get state(): unknown {\n    return {\n      samples: this.samples,\n      currentSample: this.currentSample,\n      failures: this.failures,\n      successes: this.successes,\n    } satisfies ICountBreakerState;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public set state(value: unknown) {\n    Object.assign(this, value);\n  }\n\n  /**\n   * CountBreaker breaks if more than `threshold` percentage of the last `size`\n   * calls failed, so long as at least `minimumNumberOfCalls` calls have been\n   * performed (to avoid opening unnecessarily if there are only few samples\n   * in the sliding window yet).\n   */\n  constructor({ threshold, size, minimumNumberOfCalls = size }: ICountBreakerOptions) {\n    if (threshold <= 0 || threshold >= 1) {\n      throw new RangeError(`CountBreaker threshold should be between (0, 1), got ${threshold}`);\n    }\n    if (!Number.isSafeInteger(size) || size < 1) {\n      throw new RangeError(`CountBreaker size should be a positive integer, got ${size}`);\n    }\n    if (\n      !Number.isSafeInteger(minimumNumberOfCalls) ||\n      minimumNumberOfCalls < 1 ||\n      minimumNumberOfCalls > size\n    ) {\n      throw new RangeError(\n        `CountBreaker size should be an integer between (1, size), got ${minimumNumberOfCalls}`,\n      );\n    }\n\n    this.threshold = threshold;\n    this.minimumNumberOfCalls = minimumNumberOfCalls;\n    this.samples = Array.from({ length: size }, () => null);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public success(state: CircuitState) {\n    if (state === CircuitState.HalfOpen) {\n      this.reset();\n    }\n\n    this.sample(true);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public failure(state: CircuitState) {\n    this.sample(false);\n\n    if (state !== CircuitState.Closed) {\n      return true;\n    }\n\n    const total = this.successes + this.failures;\n\n    if (total < this.minimumNumberOfCalls) {\n      return false;\n    }\n\n    if (this.failures > this.threshold * total) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private reset() {\n    this.samples.fill(null);\n    this.successes = 0;\n    this.failures = 0;\n  }\n\n  private sample(success: boolean) {\n    const current = this.samples[this.currentSample];\n    if (current === true) {\n      this.successes--;\n    } else if (current === false) {\n      this.failures--;\n    }\n\n    this.samples[this.currentSample] = success;\n    if (success) {\n      this.successes++;\n    } else {\n      this.failures++;\n    }\n\n    this.currentSample = (this.currentSample + 1) % this.samples.length;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.d.ts b/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.d.ts
deleted file mode 100644
index 04a623b..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.d.ts
+++ /dev/null
@@ -1,53 +0,0 @@
-import { CircuitState } from '../CircuitBreakerPolicy';
-import { IBreaker } from './Breaker';
-export interface ISamplingBreakerOptions {
-    /**
-     * Percentage (from 0 to 1) of requests that need to fail before we'll
-     * open the circuit.
-     */
-    threshold: number;
-    /**
-     * Length of time over which to sample.
-     */
-    duration: number;
-    /**
-     * Minimum number of RPS needed to be able to (potentially) open the circuit.
-     * Useful to avoid unnecessarily tripping under low load.
-     */
-    minimumRps?: number;
-}
-export declare class SamplingBreaker implements IBreaker {
-    private readonly threshold;
-    private readonly minimumRpms;
-    private readonly duration;
-    private readonly windowSize;
-    private windows;
-    private currentWindow;
-    private currentFailures;
-    private currentSuccesses;
-    /**
-     * @inheritdoc
-     */
-    get state(): unknown;
-    /**
-     * @inheritdoc
-     */
-    set state(value: unknown);
-    /**
-     * SamplingBreaker breaks if more than `threshold` percentage of calls over the
-     * last `samplingDuration`, so long as there's at least `minimumRps` (to avoid
-     * opening unnecessarily under low RPS).
-     */
-    constructor({ threshold, duration: samplingDuration, minimumRps }: ISamplingBreakerOptions);
-    /**
-     * @inheritdoc
-     */
-    success(state: CircuitState): void;
-    /**
-     * @inheritdoc
-     */
-    failure(state: CircuitState): boolean;
-    private resetWindows;
-    private rotateWindow;
-    private push;
-}
diff --git a/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.js b/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.js
deleted file mode 100644
index 036a816..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.js
+++ /dev/null
@@ -1,118 +0,0 @@
-import { CircuitState } from '../CircuitBreakerPolicy';
-export class SamplingBreaker {
-    /**
-     * @inheritdoc
-     */
-    get state() {
-        return {
-            windows: this.windows,
-            currentWindow: this.currentWindow,
-            currentFailures: this.currentFailures,
-            currentSuccesses: this.currentSuccesses,
-        };
-    }
-    /**
-     * @inheritdoc
-     */
-    set state(value) {
-        Object.assign(this, value);
-    }
-    /**
-     * SamplingBreaker breaks if more than `threshold` percentage of calls over the
-     * last `samplingDuration`, so long as there's at least `minimumRps` (to avoid
-     * opening unnecessarily under low RPS).
-     */
-    constructor({ threshold, duration: samplingDuration, minimumRps }) {
-        this.windows = [];
-        this.currentWindow = 0;
-        this.currentFailures = 0;
-        this.currentSuccesses = 0;
-        if (threshold <= 0 || threshold >= 1) {
-            throw new RangeError(`SamplingBreaker threshold should be between (0, 1), got ${threshold}`);
-        }
-        this.threshold = threshold;
-        // at least 5 windows, max 1 second each:
-        const windowCount = Math.max(5, Math.ceil(samplingDuration / 1000));
-        for (let i = 0; i < windowCount; i++) {
-            this.windows.push({ startedAt: 0, failures: 0, successes: 0 });
-        }
-        this.windowSize = Math.round(samplingDuration / windowCount);
-        this.duration = this.windowSize * windowCount;
-        if (minimumRps) {
-            this.minimumRpms = minimumRps / 1000;
-        }
-        else {
-            // for our rps guess, set it so at least 5 failures per second
-            // are needed to open the circuit
-            this.minimumRpms = 5 / (threshold * 1000);
-        }
-    }
-    /**
-     * @inheritdoc
-     */
-    success(state) {
-        if (state === CircuitState.HalfOpen) {
-            this.resetWindows();
-        }
-        this.push(true);
-    }
-    /**
-     * @inheritdoc
-     */
-    failure(state) {
-        this.push(false);
-        if (state !== CircuitState.Closed) {
-            return true;
-        }
-        const total = this.currentSuccesses + this.currentFailures;
-        // If we don't have enough rps, then the circuit is open.
-        // 1. `total / samplingDuration` gets rps
-        // 2. We want `rpms < minimumRpms`
-        // 3. Simplifies to `total < samplingDuration * minimumRps`
-        if (total < this.duration * this.minimumRpms) {
-            return false;
-        }
-        // If we're above threshold, open the circuit
-        // 1. `failures / total > threshold`
-        // 2. `failures > threshold * total`
-        if (this.currentFailures > this.threshold * total) {
-            return true;
-        }
-        return false;
-    }
-    resetWindows() {
-        this.currentFailures = 0;
-        this.currentSuccesses = 0;
-        for (const window of this.windows) {
-            window.failures = 0;
-            window.successes = 0;
-            window.startedAt = 0;
-        }
-    }
-    rotateWindow(now) {
-        const next = (this.currentWindow + 1) % this.windows.length;
-        this.currentFailures -= this.windows[next].failures;
-        this.currentSuccesses -= this.windows[next].successes;
-        const window = (this.windows[next] = { failures: 0, successes: 0, startedAt: now });
-        this.currentWindow = next;
-        return window;
-    }
-    push(success) {
-        const now = Date.now();
-        // Get the current time period window, advance if necessary
-        let window = this.windows[this.currentWindow];
-        if (now - window.startedAt >= this.windowSize) {
-            window = this.rotateWindow(now);
-        }
-        // Increment current counts
-        if (success) {
-            window.successes++;
-            this.currentSuccesses++;
-        }
-        else {
-            window.failures++;
-            this.currentFailures++;
-        }
-    }
-}
-//# sourceMappingURL=SamplingBreaker.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.js.map b/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.js.map
deleted file mode 100644
index 2167a12..0000000
--- a/node_modules/cockatiel/dist/esm/breaker/SamplingBreaker.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"SamplingBreaker.js","sourceRoot":"","sources":["../../../src/breaker/SamplingBreaker.ts"],"names":[],"mappings":"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","sourcesContent":["import { CircuitState } from '../CircuitBreakerPolicy';\nimport { IBreaker } from './Breaker';\n\ninterface IWindow {\n  startedAt: number;\n  failures: number;\n  successes: number;\n}\n\nexport interface ISamplingBreakerOptions {\n  /**\n   * Percentage (from 0 to 1) of requests that need to fail before we'll\n   * open the circuit.\n   */\n  threshold: number;\n\n  /**\n   * Length of time over which to sample.\n   */\n  duration: number;\n\n  /**\n   * Minimum number of RPS needed to be able to (potentially) open the circuit.\n   * Useful to avoid unnecessarily tripping under low load.\n   */\n  minimumRps?: number;\n}\n\ninterface ISamplingBreakerState {\n  windows: IWindow[];\n  currentWindow: number;\n  currentFailures: number;\n  currentSuccesses: number;\n}\n\nexport class SamplingBreaker implements IBreaker {\n  private readonly threshold: number;\n  private readonly minimumRpms: number;\n  private readonly duration: number;\n  private readonly windowSize: number;\n\n  private windows: IWindow[] = [];\n  private currentWindow = 0;\n  private currentFailures = 0;\n  private currentSuccesses = 0;\n\n  /**\n   * @inheritdoc\n   */\n  public get state(): unknown {\n    return {\n      windows: this.windows,\n      currentWindow: this.currentWindow,\n      currentFailures: this.currentFailures,\n      currentSuccesses: this.currentSuccesses,\n    } satisfies ISamplingBreakerState;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public set state(value: unknown) {\n    Object.assign(this, value);\n  }\n\n  /**\n   * SamplingBreaker breaks if more than `threshold` percentage of calls over the\n   * last `samplingDuration`, so long as there's at least `minimumRps` (to avoid\n   * opening unnecessarily under low RPS).\n   */\n  constructor({ threshold, duration: samplingDuration, minimumRps }: ISamplingBreakerOptions) {\n    if (threshold <= 0 || threshold >= 1) {\n      throw new RangeError(`SamplingBreaker threshold should be between (0, 1), got ${threshold}`);\n    }\n\n    this.threshold = threshold;\n\n    // at least 5 windows, max 1 second each:\n    const windowCount = Math.max(5, Math.ceil(samplingDuration / 1000));\n    for (let i = 0; i < windowCount; i++) {\n      this.windows.push({ startedAt: 0, failures: 0, successes: 0 });\n    }\n\n    this.windowSize = Math.round(samplingDuration / windowCount);\n    this.duration = this.windowSize * windowCount;\n\n    if (minimumRps) {\n      this.minimumRpms = minimumRps / 1000;\n    } else {\n      // for our rps guess, set it so at least 5 failures per second\n      // are needed to open the circuit\n      this.minimumRpms = 5 / (threshold * 1000);\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public success(state: CircuitState) {\n    if (state === CircuitState.HalfOpen) {\n      this.resetWindows();\n    }\n\n    this.push(true);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public failure(state: CircuitState) {\n    this.push(false);\n\n    if (state !== CircuitState.Closed) {\n      return true;\n    }\n\n    const total = this.currentSuccesses + this.currentFailures;\n\n    // If we don't have enough rps, then the circuit is open.\n    // 1. `total / samplingDuration` gets rps\n    // 2. We want `rpms < minimumRpms`\n    // 3. Simplifies to `total < samplingDuration * minimumRps`\n    if (total < this.duration * this.minimumRpms) {\n      return false;\n    }\n\n    // If we're above threshold, open the circuit\n    // 1. `failures / total > threshold`\n    // 2. `failures > threshold * total`\n    if (this.currentFailures > this.threshold * total) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private resetWindows() {\n    this.currentFailures = 0;\n    this.currentSuccesses = 0;\n    for (const window of this.windows) {\n      window.failures = 0;\n      window.successes = 0;\n      window.startedAt = 0;\n    }\n  }\n\n  private rotateWindow(now: number) {\n    const next = (this.currentWindow + 1) % this.windows.length;\n    this.currentFailures -= this.windows[next].failures;\n    this.currentSuccesses -= this.windows[next].successes;\n    const window = (this.windows[next] = { failures: 0, successes: 0, startedAt: now });\n    this.currentWindow = next;\n\n    return window;\n  }\n\n  private push(success: boolean) {\n    const now = Date.now();\n\n    // Get the current time period window, advance if necessary\n    let window = this.windows[this.currentWindow];\n    if (now - window.startedAt >= this.windowSize) {\n      window = this.rotateWindow(now);\n    }\n\n    // Increment current counts\n    if (success) {\n      window.successes++;\n      this.currentSuccesses++;\n    } else {\n      window.failures++;\n      this.currentFailures++;\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/Event.d.ts b/node_modules/cockatiel/dist/esm/common/Event.d.ts
deleted file mode 100644
index f681344..0000000
--- a/node_modules/cockatiel/dist/esm/common/Event.d.ts
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Type that can be disposed.
- */
-export interface IDisposable {
-    dispose(): void;
-}
-export declare const noopDisposable: IDisposable;
-/**
- * Function that subscribes the method to receive data.
- */
-export type Event<T> = (listener: (data: T) => void) => IDisposable;
-export declare namespace Event {
-    /**
-     * Adds a handler that handles one event on the emitter.
-     */
-    const once: <T>(event: Event<T>, listener: (data: T) => void) => IDisposable;
-    /**
-     * Returns a promise that resolves when the event fires, or when cancellation
-     * is requested, whichever happens first.
-     */
-    const toPromise: <T>(event: Event<T>, signal?: AbortSignal) => Promise<T>;
-}
-/** Creates an Event that fires when the signal is aborted. */
-export declare const onAbort: (signal: AbortSignal) => {
-    event: Event<void>;
-} & IDisposable;
-/**
- * Base event emitter. Calls listeners when data is emitted.
- */
-export declare class EventEmitter<T> {
-    protected listeners?: Array<(data: T) => void> | ((data: T) => void);
-    /**
-     * Event<T> function.
-     */
-    readonly addListener: Event<T>;
-    /**
-     * Gets the number of event listeners.
-     */
-    get size(): number;
-    /**
-     * Emits event data.
-     */
-    emit(value: T): void;
-    protected addListenerInner(listener: (data: T) => void): IDisposable;
-    private removeListener;
-}
-/**
- * An event emitter that memorizes and instantly re-emits its last value
- * to attached listeners.
- */
-export declare class MemorizingEventEmitter<T> extends EventEmitter<T> {
-    /**
-     * Last emitted value, wrapped in an object so that we can correctly detect
-     * emission of 'undefined' values.
-     */
-    private lastValue?;
-    /**
-     * Gets whether this emitter has yet emitted any event.
-     */
-    get hasEmitted(): boolean;
-    /**
-     * @inheritdoc
-     */
-    readonly addListener: Event<T>;
-    /**
-     * @inheritdoc
-     */
-    emit(value: T): void;
-}
diff --git a/node_modules/cockatiel/dist/esm/common/Event.js b/node_modules/cockatiel/dist/esm/common/Event.js
deleted file mode 100644
index 12eff41..0000000
--- a/node_modules/cockatiel/dist/esm/common/Event.js
+++ /dev/null
@@ -1,205 +0,0 @@
-import { TaskCancelledError } from '../errors/TaskCancelledError';
-export const noopDisposable = { dispose: () => undefined };
-export var Event;
-(function (Event) {
-    /**
-     * Adds a handler that handles one event on the emitter.
-     */
-    Event.once = (event, listener) => {
-        let syncDispose = false;
-        let disposable;
-        disposable = event(value => {
-            listener(value);
-            if (disposable) {
-                disposable.dispose();
-            }
-            else {
-                syncDispose = true; // callback can fire before disposable is returned
-            }
-        });
-        if (syncDispose) {
-            disposable.dispose();
-            return noopDisposable; // no reason to keep the ref around
-        }
-        return disposable;
-    };
-    /**
-     * Returns a promise that resolves when the event fires, or when cancellation
-     * is requested, whichever happens first.
-     */
-    Event.toPromise = (event, signal) => {
-        if (!signal) {
-            return new Promise(resolve => Event.once(event, resolve));
-        }
-        if (signal.aborted) {
-            return Promise.reject(new TaskCancelledError());
-        }
-        const toDispose = [];
-        return new Promise((resolve, reject) => {
-            const abortEvt = onAbort(signal);
-            toDispose.push(abortEvt);
-            toDispose.push(abortEvt.event(() => {
-                reject(new TaskCancelledError());
-            }));
-            toDispose.push(Event.once(event, data => {
-                resolve(data);
-            }));
-        }).finally(() => {
-            for (const d of toDispose) {
-                d.dispose();
-            }
-        });
-    };
-})(Event || (Event = {}));
-/** Creates an Event that fires when the signal is aborted. */
-export const onAbort = (signal) => {
-    const evt = new OneShotEvent();
-    if (signal.aborted) {
-        evt.emit();
-        return { event: evt.addListener, dispose: () => { } };
-    }
-    const dispose = () => signal.removeEventListener('abort', l);
-    // @types/node is currently missing the event types on AbortSignal
-    const l = () => {
-        evt.emit();
-        dispose();
-    };
-    signal.addEventListener('abort', l);
-    return { event: evt.addListener, dispose };
-};
-/**
- * Base event emitter. Calls listeners when data is emitted.
- */
-export class EventEmitter {
-    constructor() {
-        /**
-         * Event<T> function.
-         */
-        this.addListener = listener => this.addListenerInner(listener);
-    }
-    /**
-     * Gets the number of event listeners.
-     */
-    get size() {
-        if (!this.listeners) {
-            return 0;
-        }
-        else if (typeof this.listeners === 'function') {
-            return 1;
-        }
-        else {
-            return this.listeners.length;
-        }
-    }
-    /**
-     * Emits event data.
-     */
-    emit(value) {
-        if (!this.listeners) {
-            // no-op
-        }
-        else if (typeof this.listeners === 'function') {
-            this.listeners(value);
-        }
-        else {
-            for (const listener of this.listeners) {
-                listener(value);
-            }
-        }
-    }
-    addListenerInner(listener) {
-        if (!this.listeners) {
-            this.listeners = listener;
-        }
-        else if (typeof this.listeners === 'function') {
-            this.listeners = [this.listeners, listener];
-        }
-        else {
-            this.listeners.push(listener);
-        }
-        return { dispose: () => this.removeListener(listener) };
-    }
-    removeListener(listener) {
-        if (!this.listeners) {
-            return;
-        }
-        if (typeof this.listeners === 'function') {
-            if (this.listeners === listener) {
-                this.listeners = undefined;
-            }
-            return;
-        }
-        const index = this.listeners.indexOf(listener);
-        if (index === -1) {
-            return;
-        }
-        if (this.listeners.length === 2) {
-            this.listeners = index === 0 ? this.listeners[1] : this.listeners[0];
-        }
-        else {
-            this.listeners = this.listeners.slice(0, index).concat(this.listeners.slice(index + 1));
-        }
-    }
-}
-/**
- * An event emitter that memorizes and instantly re-emits its last value
- * to attached listeners.
- */
-export class MemorizingEventEmitter extends EventEmitter {
-    constructor() {
-        super(...arguments);
-        /**
-         * @inheritdoc
-         */
-        this.addListener = listener => {
-            const disposable = this.addListenerInner(listener);
-            if (this.lastValue) {
-                listener(this.lastValue.value);
-            }
-            return disposable;
-        };
-    }
-    /**
-     * Gets whether this emitter has yet emitted any event.
-     */
-    get hasEmitted() {
-        return !!this.lastValue;
-    }
-    /**
-     * @inheritdoc
-     */
-    emit(value) {
-        this.lastValue = { value };
-        super.emit(value);
-    }
-}
-/**
- * An event emitter that fires a value once and removes all
- * listeners automatically after doing so.
- */
-class OneShotEvent extends EventEmitter {
-    constructor() {
-        super(...arguments);
-        /**
-         * @inheritdoc
-         */
-        this.addListener = listener => {
-            if (this.lastValue) {
-                listener(this.lastValue.value);
-                return noopDisposable;
-            }
-            else {
-                return this.addListenerInner(listener);
-            }
-        };
-    }
-    /**
-     * @inheritdoc
-     */
-    emit(value) {
-        this.lastValue = { value };
-        super.emit(value);
-        this.listeners = undefined;
-    }
-}
-//# sourceMappingURL=Event.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/Event.js.map b/node_modules/cockatiel/dist/esm/common/Event.js.map
deleted file mode 100644
index 84a094a..0000000
--- a/node_modules/cockatiel/dist/esm/common/Event.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Event.js","sourceRoot":"","sources":["../../../src/common/Event.ts"],"names":[],"mappings":"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","sourcesContent":["import { TaskCancelledError } from '../errors/TaskCancelledError';\n\n/**\n * Type that can be disposed.\n */\nexport interface IDisposable {\n  dispose(): void;\n}\n\nexport const noopDisposable: IDisposable = { dispose: () => undefined };\n\n/**\n * Function that subscribes the method to receive data.\n */\nexport type Event<T> = (listener: (data: T) => void) => IDisposable;\n\nexport namespace Event {\n  /**\n   * Adds a handler that handles one event on the emitter.\n   */\n  export const once = <T>(event: Event<T>, listener: (data: T) => void): IDisposable => {\n    let syncDispose = false;\n    let disposable: IDisposable | void;\n\n    disposable = event(value => {\n      listener(value);\n\n      if (disposable) {\n        disposable.dispose();\n      } else {\n        syncDispose = true; // callback can fire before disposable is returned\n      }\n    });\n\n    if (syncDispose) {\n      disposable.dispose();\n      return noopDisposable; // no reason to keep the ref around\n    }\n\n    return disposable;\n  };\n\n  /**\n   * Returns a promise that resolves when the event fires, or when cancellation\n   * is requested, whichever happens first.\n   */\n  export const toPromise = <T>(event: Event<T>, signal?: AbortSignal): Promise<T> => {\n    if (!signal) {\n      return new Promise<T>(resolve => once(event, resolve));\n    }\n\n    if (signal.aborted) {\n      return Promise.reject(new TaskCancelledError());\n    }\n\n    const toDispose: IDisposable[] = [];\n\n    return new Promise<T>((resolve, reject) => {\n      const abortEvt = onAbort(signal);\n      toDispose.push(abortEvt);\n\n      toDispose.push(\n        abortEvt.event(() => {\n          reject(new TaskCancelledError());\n        }),\n      );\n\n      toDispose.push(\n        once(event, data => {\n          resolve(data);\n        }),\n      );\n    }).finally(() => {\n      for (const d of toDispose) {\n        d.dispose();\n      }\n    });\n  };\n}\n\n/** Creates an Event that fires when the signal is aborted. */\nexport const onAbort = (signal: AbortSignal): { event: Event<void> } & IDisposable => {\n  const evt = new OneShotEvent<void>();\n  if (signal.aborted) {\n    evt.emit();\n    return { event: evt.addListener, dispose: () => {} };\n  }\n\n  const dispose = () => (signal as any).removeEventListener('abort', l);\n\n  // @types/node is currently missing the event types on AbortSignal\n  const l = () => {\n    evt.emit();\n    dispose();\n  };\n\n  (signal as any).addEventListener('abort', l);\n\n  return { event: evt.addListener, dispose };\n};\n\n/**\n * Base event emitter. Calls listeners when data is emitted.\n */\nexport class EventEmitter<T> {\n  protected listeners?: Array<(data: T) => void> | ((data: T) => void);\n\n  /**\n   * Event<T> function.\n   */\n  public readonly addListener: Event<T> = listener => this.addListenerInner(listener);\n\n  /**\n   * Gets the number of event listeners.\n   */\n  public get size() {\n    if (!this.listeners) {\n      return 0;\n    } else if (typeof this.listeners === 'function') {\n      return 1;\n    } else {\n      return this.listeners.length;\n    }\n  }\n\n  /**\n   * Emits event data.\n   */\n  public emit(value: T) {\n    if (!this.listeners) {\n      // no-op\n    } else if (typeof this.listeners === 'function') {\n      this.listeners(value);\n    } else {\n      for (const listener of this.listeners) {\n        listener(value);\n      }\n    }\n  }\n\n  protected addListenerInner(listener: (data: T) => void): IDisposable {\n    if (!this.listeners) {\n      this.listeners = listener;\n    } else if (typeof this.listeners === 'function') {\n      this.listeners = [this.listeners, listener];\n    } else {\n      this.listeners.push(listener);\n    }\n\n    return { dispose: () => this.removeListener(listener) };\n  }\n\n  private removeListener(listener: (data: T) => void) {\n    if (!this.listeners) {\n      return;\n    }\n\n    if (typeof this.listeners === 'function') {\n      if (this.listeners === listener) {\n        this.listeners = undefined;\n      }\n      return;\n    }\n\n    const index = this.listeners.indexOf(listener);\n    if (index === -1) {\n      return;\n    }\n\n    if (this.listeners.length === 2) {\n      this.listeners = index === 0 ? this.listeners[1] : this.listeners[0];\n    } else {\n      this.listeners = this.listeners.slice(0, index).concat(this.listeners.slice(index + 1));\n    }\n  }\n}\n\n/**\n * An event emitter that memorizes and instantly re-emits its last value\n * to attached listeners.\n */\nexport class MemorizingEventEmitter<T> extends EventEmitter<T> {\n  /**\n   * Last emitted value, wrapped in an object so that we can correctly detect\n   * emission of 'undefined' values.\n   */\n  private lastValue?: { value: T };\n\n  /**\n   * Gets whether this emitter has yet emitted any event.\n   */\n  public get hasEmitted() {\n    return !!this.lastValue;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public readonly addListener: Event<T> = listener => {\n    const disposable = this.addListenerInner(listener);\n    if (this.lastValue) {\n      listener(this.lastValue.value);\n    }\n\n    return disposable;\n  };\n\n  /**\n   * @inheritdoc\n   */\n  public emit(value: T) {\n    this.lastValue = { value };\n    super.emit(value);\n  }\n}\n\n/**\n * An event emitter that fires a value once and removes all\n * listeners automatically after doing so.\n */\nclass OneShotEvent<T> extends EventEmitter<T> {\n  /**\n   * Last emitted value, wrapped in an object so that we can correctly detect\n   * emission of 'undefined' values.\n   */\n  private lastValue?: { value: T };\n\n  /**\n   * @inheritdoc\n   */\n  public readonly addListener: Event<T> = listener => {\n    if (this.lastValue) {\n      listener(this.lastValue.value);\n      return noopDisposable;\n    } else {\n      return this.addListenerInner(listener);\n    }\n  };\n\n  /**\n   * @inheritdoc\n   */\n  public emit(value: T) {\n    this.lastValue = { value };\n    super.emit(value);\n    this.listeners = undefined;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/Executor.bench.js b/node_modules/cockatiel/dist/esm/common/Executor.bench.js
deleted file mode 100644
index 881f85d..0000000
--- a/node_modules/cockatiel/dist/esm/common/Executor.bench.js
+++ /dev/null
@@ -1,12 +0,0 @@
-import { EventEmitter } from './Event';
-const emitter0 = new EventEmitter();
-const emitter1 = new EventEmitter();
-emitter1.addListener(() => undefined);
-const emitter3 = new EventEmitter();
-emitter3.addListener(() => undefined);
-emitter3.addListener(() => undefined);
-emitter3.addListener(() => undefined);
-bench('0 listener', () => emitter0.emit(true));
-bench('1 listener', () => emitter1.emit(true));
-bench('3 listener', () => emitter3.emit(true));
-//# sourceMappingURL=Executor.bench.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/Executor.bench.js.map b/node_modules/cockatiel/dist/esm/common/Executor.bench.js.map
deleted file mode 100644
index 736f237..0000000
--- a/node_modules/cockatiel/dist/esm/common/Executor.bench.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Executor.bench.js","sourceRoot":"","sources":["../../../src/common/Executor.bench.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAIvC,MAAM,QAAQ,GAAG,IAAI,YAAY,EAAE,CAAC;AACpC,MAAM,QAAQ,GAAG,IAAI,YAAY,EAAE,CAAC;AACpC,QAAQ,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;AACtC,MAAM,QAAQ,GAAG,IAAI,YAAY,EAAE,CAAC;AACpC,QAAQ,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;AACtC,QAAQ,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;AACtC,QAAQ,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;AAEtC,KAAK,CAAC,YAAY,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAC/C,KAAK,CAAC,YAAY,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAC/C,KAAK,CAAC,YAAY,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC","sourcesContent":["import { EventEmitter } from './Event';\n\ndeclare function bench(name: string, fn: () => void): void;\n\nconst emitter0 = new EventEmitter();\nconst emitter1 = new EventEmitter();\nemitter1.addListener(() => undefined);\nconst emitter3 = new EventEmitter();\nemitter3.addListener(() => undefined);\nemitter3.addListener(() => undefined);\nemitter3.addListener(() => undefined);\n\nbench('0 listener', () => emitter0.emit(true));\nbench('1 listener', () => emitter1.emit(true));\nbench('3 listener', () => emitter3.emit(true));\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/Executor.d.ts b/node_modules/cockatiel/dist/esm/common/Executor.d.ts
deleted file mode 100644
index 99ab97e..0000000
--- a/node_modules/cockatiel/dist/esm/common/Executor.d.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-import { FailureReason, IFailureEvent, ISuccessEvent } from '../Policy';
-export type FailureOrSuccess<R> = FailureReason<R> | {
-    success: R;
-};
-export declare const returnOrThrow: <R>(failure: FailureOrSuccess<R>) => R;
-export declare class ExecuteWrapper {
-    private readonly errorFilter;
-    private readonly resultFilter;
-    private readonly successEmitter;
-    private readonly failureEmitter;
-    readonly onSuccess: import("./Event").Event<ISuccessEvent>;
-    readonly onFailure: import("./Event").Event<IFailureEvent>;
-    constructor(errorFilter?: (error: Error) => boolean, resultFilter?: (result: unknown) => boolean);
-    clone(): ExecuteWrapper;
-    invoke<T extends unknown[], R>(fn: (...args: T) => PromiseLike<R> | R, ...args: T): Promise<FailureOrSuccess<R>>;
-}
diff --git a/node_modules/cockatiel/dist/esm/common/Executor.js b/node_modules/cockatiel/dist/esm/common/Executor.js
deleted file mode 100644
index 0b9707f..0000000
--- a/node_modules/cockatiel/dist/esm/common/Executor.js
+++ /dev/null
@@ -1,61 +0,0 @@
-import { EventEmitter } from './Event';
-export const returnOrThrow = (failure) => {
-    if ('error' in failure) {
-        throw failure.error;
-    }
-    if ('success' in failure) {
-        return failure.success;
-    }
-    return failure.value;
-};
-const makeStopwatch = () => {
-    if (typeof performance !== 'undefined') {
-        const start = performance.now();
-        return () => performance.now() - start;
-    }
-    else {
-        const start = process.hrtime.bigint();
-        return () => Number(process.hrtime.bigint() - start) / 1000000; // ns->ms
-    }
-};
-export class ExecuteWrapper {
-    constructor(errorFilter = () => false, resultFilter = () => false) {
-        this.errorFilter = errorFilter;
-        this.resultFilter = resultFilter;
-        this.successEmitter = new EventEmitter();
-        this.failureEmitter = new EventEmitter();
-        this.onSuccess = this.successEmitter.addListener;
-        this.onFailure = this.failureEmitter.addListener;
-    }
-    clone() {
-        return new ExecuteWrapper(this.errorFilter, this.resultFilter);
-    }
-    async invoke(fn, ...args) {
-        const stopwatch = this.successEmitter.size || this.failureEmitter.size ? makeStopwatch() : null;
-        try {
-            const value = await fn(...args);
-            if (!this.resultFilter(value)) {
-                if (stopwatch) {
-                    this.successEmitter.emit({ duration: stopwatch() });
-                }
-                return { success: value };
-            }
-            if (stopwatch) {
-                this.failureEmitter.emit({ duration: stopwatch(), handled: true, reason: { value } });
-            }
-            return { value };
-        }
-        catch (rawError) {
-            const error = rawError;
-            const handled = this.errorFilter(error);
-            if (stopwatch) {
-                this.failureEmitter.emit({ duration: stopwatch(), handled, reason: { error } });
-            }
-            if (!handled) {
-                throw error;
-            }
-            return { error };
-        }
-    }
-}
-//# sourceMappingURL=Executor.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/Executor.js.map b/node_modules/cockatiel/dist/esm/common/Executor.js.map
deleted file mode 100644
index 203dca1..0000000
--- a/node_modules/cockatiel/dist/esm/common/Executor.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Executor.js","sourceRoot":"","sources":["../../../src/common/Executor.ts"],"names":[],"mappings":"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","sourcesContent":["import { FailureReason, IFailureEvent, ISuccessEvent } from '../Policy';\nimport { EventEmitter } from './Event';\n\nexport type FailureOrSuccess<R> = FailureReason<R> | { success: R };\n\nexport const returnOrThrow = <R>(failure: FailureOrSuccess<R>) => {\n  if ('error' in failure) {\n    throw failure.error;\n  }\n\n  if ('success' in failure) {\n    return failure.success;\n  }\n\n  return failure.value;\n};\n\ndeclare const performance: { now(): number };\n\nconst makeStopwatch = () => {\n  if (typeof performance !== 'undefined') {\n    const start = performance.now();\n    return () => performance.now() - start;\n  } else {\n    const start = process.hrtime.bigint();\n    return () => Number(process.hrtime.bigint() - start) / 1000000; // ns->ms\n  }\n};\n\nexport class ExecuteWrapper {\n  private readonly successEmitter = new EventEmitter<ISuccessEvent>();\n  private readonly failureEmitter = new EventEmitter<IFailureEvent>();\n  public readonly onSuccess = this.successEmitter.addListener;\n  public readonly onFailure = this.failureEmitter.addListener;\n\n  constructor(\n    private readonly errorFilter: (error: Error) => boolean = () => false,\n    private readonly resultFilter: (result: unknown) => boolean = () => false,\n  ) {}\n\n  public clone() {\n    return new ExecuteWrapper(this.errorFilter, this.resultFilter);\n  }\n\n  public async invoke<T extends unknown[], R>(\n    fn: (...args: T) => PromiseLike<R> | R,\n    ...args: T\n  ): Promise<FailureOrSuccess<R>> {\n    const stopwatch = this.successEmitter.size || this.failureEmitter.size ? makeStopwatch() : null;\n\n    try {\n      const value = await fn(...args);\n      if (!this.resultFilter(value)) {\n        if (stopwatch) {\n          this.successEmitter.emit({ duration: stopwatch() });\n        }\n        return { success: value };\n      }\n\n      if (stopwatch) {\n        this.failureEmitter.emit({ duration: stopwatch(), handled: true, reason: { value } });\n      }\n\n      return { value };\n    } catch (rawError) {\n      const error = rawError as Error;\n      const handled = this.errorFilter(error as Error);\n      if (stopwatch) {\n        this.failureEmitter.emit({ duration: stopwatch(), handled, reason: { error } });\n      }\n\n      if (!handled) {\n        throw error;\n      }\n\n      return { error };\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/abort.d.ts b/node_modules/cockatiel/dist/esm/common/abort.d.ts
deleted file mode 100644
index fb20c21..0000000
--- a/node_modules/cockatiel/dist/esm/common/abort.d.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import { IDisposable } from './Event';
-export declare const neverAbortedSignal: AbortSignal;
-export declare const abortedSignal: AbortSignal;
-/**
- * Creates a new AbortController that is aborted when the parent signal aborts.
- * @private
- */
-export declare const deriveAbortController: (signal?: AbortSignal) => {
-    ctrl: AbortController;
-} & IDisposable;
diff --git a/node_modules/cockatiel/dist/esm/common/abort.js b/node_modules/cockatiel/dist/esm/common/abort.js
deleted file mode 100644
index 07a4e1c..0000000
--- a/node_modules/cockatiel/dist/esm/common/abort.js
+++ /dev/null
@@ -1,27 +0,0 @@
-import { onAbort } from './Event';
-export const neverAbortedSignal = new AbortController().signal;
-const cancelledSrc = new AbortController();
-cancelledSrc.abort();
-export const abortedSignal = cancelledSrc.signal;
-const noop = () => { };
-/**
- * Creates a new AbortController that is aborted when the parent signal aborts.
- * @private
- */
-export const deriveAbortController = (signal) => {
-    const ctrl = new AbortController();
-    let dispose = noop;
-    if (!signal) {
-        return { ctrl, dispose };
-    }
-    if (signal.aborted) {
-        ctrl.abort();
-    }
-    else {
-        const abortEvt = onAbort(signal);
-        abortEvt.event(() => ctrl.abort());
-        dispose = abortEvt.dispose;
-    }
-    return { ctrl, dispose };
-};
-//# sourceMappingURL=abort.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/abort.js.map b/node_modules/cockatiel/dist/esm/common/abort.js.map
deleted file mode 100644
index ff9c967..0000000
--- a/node_modules/cockatiel/dist/esm/common/abort.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"abort.js","sourceRoot":"","sources":["../../../src/common/abort.ts"],"names":[],"mappings":"AAAA,OAAO,EAAe,OAAO,EAAE,MAAM,SAAS,CAAC;AAE/C,MAAM,CAAC,MAAM,kBAAkB,GAAG,IAAI,eAAe,EAAE,CAAC,MAAM,CAAC;AAE/D,MAAM,YAAY,GAAG,IAAI,eAAe,EAAE,CAAC;AAC3C,YAAY,CAAC,KAAK,EAAE,CAAC;AACrB,MAAM,CAAC,MAAM,aAAa,GAAG,YAAY,CAAC,MAAM,CAAC;AAEjD,MAAM,IAAI,GAAe,GAAG,EAAE,GAAE,CAAC,CAAC;AAElC;;;GAGG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAAG,CACnC,MAAoB,EACqB,EAAE;IAC3C,MAAM,IAAI,GAAG,IAAI,eAAe,EAAE,CAAC;IACnC,IAAI,OAAO,GAAe,IAAI,CAAC;IAC/B,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;QACnB,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;SAAM,CAAC;QACN,MAAM,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;QACjC,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;QACnC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IAC7B,CAAC;IAED,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;AAC3B,CAAC,CAAC","sourcesContent":["import { IDisposable, onAbort } from './Event';\n\nexport const neverAbortedSignal = new AbortController().signal;\n\nconst cancelledSrc = new AbortController();\ncancelledSrc.abort();\nexport const abortedSignal = cancelledSrc.signal;\n\nconst noop: () => void = () => {};\n\n/**\n * Creates a new AbortController that is aborted when the parent signal aborts.\n * @private\n */\nexport const deriveAbortController = (\n  signal?: AbortSignal,\n): { ctrl: AbortController } & IDisposable => {\n  const ctrl = new AbortController();\n  let dispose: () => void = noop;\n  if (!signal) {\n    return { ctrl, dispose };\n  }\n\n  if (signal.aborted) {\n    ctrl.abort();\n  } else {\n    const abortEvt = onAbort(signal);\n    abortEvt.event(() => ctrl.abort());\n    dispose = abortEvt.dispose;\n  }\n\n  return { ctrl, dispose };\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/defer.d.ts b/node_modules/cockatiel/dist/esm/common/defer.d.ts
deleted file mode 100644
index 83005ba..0000000
--- a/node_modules/cockatiel/dist/esm/common/defer.d.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-export declare const defer: <T>() => {
-    resolve: (value: T) => void;
-    reject: (error: Error) => void;
-    promise: Promise<T>;
-};
diff --git a/node_modules/cockatiel/dist/esm/common/defer.js b/node_modules/cockatiel/dist/esm/common/defer.js
deleted file mode 100644
index a65cac1..0000000
--- a/node_modules/cockatiel/dist/esm/common/defer.js
+++ /dev/null
@@ -1,11 +0,0 @@
-export const defer = () => {
-    let resolve;
-    let reject;
-    const promise = new Promise((res, rej) => {
-        resolve = res;
-        reject = rej;
-    });
-    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
-    return { resolve: resolve, reject: reject, promise };
-};
-//# sourceMappingURL=defer.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/common/defer.js.map b/node_modules/cockatiel/dist/esm/common/defer.js.map
deleted file mode 100644
index 6688368..0000000
--- a/node_modules/cockatiel/dist/esm/common/defer.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"defer.js","sourceRoot":"","sources":["../../../src/common/defer.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,KAAK,GAAG,GAAM,EAAE;IAC3B,IAAI,OAA2B,CAAC;IAChC,IAAI,MAA8B,CAAC;IACnC,MAAM,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;QAC1C,OAAO,GAAG,GAAG,CAAC;QACd,MAAM,GAAG,GAAG,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,oEAAoE;IACpE,OAAO,EAAE,OAAO,EAAE,OAAQ,EAAE,MAAM,EAAE,MAAO,EAAE,OAAO,EAAE,CAAC;AACzD,CAAC,CAAC","sourcesContent":["export const defer = <T>() => {\n  let resolve: (value: T) => void;\n  let reject: (error: Error) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return { resolve: resolve!, reject: reject!, promise };\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.d.ts b/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.d.ts
deleted file mode 100644
index 19fa4b4..0000000
--- a/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.d.ts
+++ /dev/null
@@ -1,8 +0,0 @@
-export declare class BrokenCircuitError extends Error {
-    readonly isBrokenCircuitError = true;
-    /**
-     * Exception thrown from {@link CircuitBreakerPolicy.execute} when the
-     * circuit breaker is open.
-     */
-    constructor(message?: string);
-}
diff --git a/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.js b/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.js
deleted file mode 100644
index f019322..0000000
--- a/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.js
+++ /dev/null
@@ -1,11 +0,0 @@
-export class BrokenCircuitError extends Error {
-    /**
-     * Exception thrown from {@link CircuitBreakerPolicy.execute} when the
-     * circuit breaker is open.
-     */
-    constructor(message = 'Execution prevented because the circuit breaker is open') {
-        super(message);
-        this.isBrokenCircuitError = true;
-    }
-}
-//# sourceMappingURL=BrokenCircuitError.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.js.map b/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.js.map
deleted file mode 100644
index 9ed7d43..0000000
--- a/node_modules/cockatiel/dist/esm/errors/BrokenCircuitError.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"BrokenCircuitError.js","sourceRoot":"","sources":["../../../src/errors/BrokenCircuitError.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,kBAAmB,SAAQ,KAAK;IAE3C;;;OAGG;IACH,YAAY,OAAO,GAAG,yDAAyD;QAC7E,KAAK,CAAC,OAAO,CAAC,CAAC;QAND,yBAAoB,GAAG,IAAI,CAAC;IAO5C,CAAC;CACF","sourcesContent":["export class BrokenCircuitError extends Error {\n  public readonly isBrokenCircuitError = true;\n  /**\n   * Exception thrown from {@link CircuitBreakerPolicy.execute} when the\n   * circuit breaker is open.\n   */\n  constructor(message = 'Execution prevented because the circuit breaker is open') {\n    super(message);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.d.ts b/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.d.ts
deleted file mode 100644
index ac56c08..0000000
--- a/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.d.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export declare class BulkheadRejectedError extends Error {
-    readonly isBulkheadRejectedError = true;
-    constructor(executionSlots: number, queueSlots: number);
-}
diff --git a/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.js b/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.js
deleted file mode 100644
index 7fa756a..0000000
--- a/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.js
+++ /dev/null
@@ -1,7 +0,0 @@
-export class BulkheadRejectedError extends Error {
-    constructor(executionSlots, queueSlots) {
-        super(`Bulkhead capacity exceeded (0/${executionSlots} execution slots, 0/${queueSlots} available)`);
-        this.isBulkheadRejectedError = true;
-    }
-}
-//# sourceMappingURL=BulkheadRejectedError.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.js.map b/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.js.map
deleted file mode 100644
index 465e15c..0000000
--- a/node_modules/cockatiel/dist/esm/errors/BulkheadRejectedError.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"BulkheadRejectedError.js","sourceRoot":"","sources":["../../../src/errors/BulkheadRejectedError.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,qBAAsB,SAAQ,KAAK;IAG9C,YAAY,cAAsB,EAAE,UAAkB;QACpD,KAAK,CACH,iCAAiC,cAAc,uBAAuB,UAAU,aAAa,CAC9F,CAAC;QALY,4BAAuB,GAAG,IAAI,CAAC;IAM/C,CAAC;CACF","sourcesContent":["export class BulkheadRejectedError extends Error {\n  public readonly isBulkheadRejectedError = true;\n\n  constructor(executionSlots: number, queueSlots: number) {\n    super(\n      `Bulkhead capacity exceeded (0/${executionSlots} execution slots, 0/${queueSlots} available)`,\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/Errors.d.ts b/node_modules/cockatiel/dist/esm/errors/Errors.d.ts
deleted file mode 100644
index 1f89841..0000000
--- a/node_modules/cockatiel/dist/esm/errors/Errors.d.ts
+++ /dev/null
@@ -1,15 +0,0 @@
-import { BrokenCircuitError } from './BrokenCircuitError';
-import { BulkheadRejectedError } from './BulkheadRejectedError';
-import { HydratingCircuitError } from './HydratingCircuitError';
-import { IsolatedCircuitError } from './IsolatedCircuitError';
-import { TaskCancelledError } from './TaskCancelledError';
-export * from './BrokenCircuitError';
-export * from './BulkheadRejectedError';
-export * from './HydratingCircuitError';
-export * from './IsolatedCircuitError';
-export * from './TaskCancelledError';
-export declare const isBrokenCircuitError: (e: unknown) => e is BrokenCircuitError;
-export declare const isBulkheadRejectedError: (e: unknown) => e is BulkheadRejectedError;
-export declare const isIsolatedCircuitError: (e: unknown) => e is IsolatedCircuitError;
-export declare const isTaskCancelledError: (e: unknown) => e is TaskCancelledError;
-export declare const isHydratingCircuitError: (e: unknown) => e is HydratingCircuitError;
diff --git a/node_modules/cockatiel/dist/esm/errors/Errors.js b/node_modules/cockatiel/dist/esm/errors/Errors.js
deleted file mode 100644
index b4e568d..0000000
--- a/node_modules/cockatiel/dist/esm/errors/Errors.js
+++ /dev/null
@@ -1,11 +0,0 @@
-export * from './BrokenCircuitError';
-export * from './BulkheadRejectedError';
-export * from './HydratingCircuitError';
-export * from './IsolatedCircuitError';
-export * from './TaskCancelledError';
-export const isBrokenCircuitError = (e) => !!e && e instanceof Error && 'isBrokenCircuitError' in e;
-export const isBulkheadRejectedError = (e) => !!e && e instanceof Error && 'isBulkheadRejectedError' in e;
-export const isIsolatedCircuitError = (e) => !!e && e instanceof Error && 'isBulkheadRejectedError' in e;
-export const isTaskCancelledError = (e) => !!e && e instanceof Error && 'isBulkheadRejectedError' in e;
-export const isHydratingCircuitError = (e) => !!e && e instanceof Error && 'isHydratingCircuitError' in e;
-//# sourceMappingURL=Errors.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/Errors.js.map b/node_modules/cockatiel/dist/esm/errors/Errors.js.map
deleted file mode 100644
index ef0c910..0000000
--- a/node_modules/cockatiel/dist/esm/errors/Errors.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Errors.js","sourceRoot":"","sources":["../../../src/errors/Errors.ts"],"names":[],"mappings":"AAMA,cAAc,sBAAsB,CAAC;AACrC,cAAc,yBAAyB,CAAC;AACxC,cAAc,yBAAyB,CAAC;AACxC,cAAc,wBAAwB,CAAC;AACvC,cAAc,sBAAsB,CAAC;AAErC,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,CAAU,EAA2B,EAAE,CAC1E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,sBAAsB,IAAI,CAAC,CAAC;AAE3D,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,CAAU,EAA8B,EAAE,CAChF,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AAE9D,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,CAAU,EAA6B,EAAE,CAC9E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AAE9D,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,CAAU,EAA2B,EAAE,CAC1E,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC;AAE9D,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,CAAU,EAA8B,EAAE,CAChF,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,yBAAyB,IAAI,CAAC,CAAC","sourcesContent":["import { BrokenCircuitError } from './BrokenCircuitError';\nimport { BulkheadRejectedError } from './BulkheadRejectedError';\nimport { HydratingCircuitError } from './HydratingCircuitError';\nimport { IsolatedCircuitError } from './IsolatedCircuitError';\nimport { TaskCancelledError } from './TaskCancelledError';\n\nexport * from './BrokenCircuitError';\nexport * from './BulkheadRejectedError';\nexport * from './HydratingCircuitError';\nexport * from './IsolatedCircuitError';\nexport * from './TaskCancelledError';\n\nexport const isBrokenCircuitError = (e: unknown): e is BrokenCircuitError =>\n  !!e && e instanceof Error && 'isBrokenCircuitError' in e;\n\nexport const isBulkheadRejectedError = (e: unknown): e is BulkheadRejectedError =>\n  !!e && e instanceof Error && 'isBulkheadRejectedError' in e;\n\nexport const isIsolatedCircuitError = (e: unknown): e is IsolatedCircuitError =>\n  !!e && e instanceof Error && 'isBulkheadRejectedError' in e;\n\nexport const isTaskCancelledError = (e: unknown): e is TaskCancelledError =>\n  !!e && e instanceof Error && 'isBulkheadRejectedError' in e;\n\nexport const isHydratingCircuitError = (e: unknown): e is HydratingCircuitError =>\n  !!e && e instanceof Error && 'isHydratingCircuitError' in e;\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.d.ts b/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.d.ts
deleted file mode 100644
index 44e1901..0000000
--- a/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.d.ts
+++ /dev/null
@@ -1,8 +0,0 @@
-export declare class HydratingCircuitError extends Error {
-    readonly isHydratingCircuitError = true;
-    /**
-     * Exception thrown from {@link CircuitBreakerPolicy.execute} when the
-     * circuit breaker is open.
-     */
-    constructor(message?: string);
-}
diff --git a/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.js b/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.js
deleted file mode 100644
index 5d3f54d..0000000
--- a/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.js
+++ /dev/null
@@ -1,11 +0,0 @@
-export class HydratingCircuitError extends Error {
-    /**
-     * Exception thrown from {@link CircuitBreakerPolicy.execute} when the
-     * circuit breaker is open.
-     */
-    constructor(message = 'Execution prevented because the circuit breaker is open') {
-        super(message);
-        this.isHydratingCircuitError = true;
-    }
-}
-//# sourceMappingURL=HydratingCircuitError.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.js.map b/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.js.map
deleted file mode 100644
index 210b2e2..0000000
--- a/node_modules/cockatiel/dist/esm/errors/HydratingCircuitError.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"HydratingCircuitError.js","sourceRoot":"","sources":["../../../src/errors/HydratingCircuitError.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,qBAAsB,SAAQ,KAAK;IAE9C;;;OAGG;IACH,YAAY,OAAO,GAAG,yDAAyD;QAC7E,KAAK,CAAC,OAAO,CAAC,CAAC;QAND,4BAAuB,GAAG,IAAI,CAAC;IAO/C,CAAC;CACF","sourcesContent":["export class HydratingCircuitError extends Error {\n  public readonly isHydratingCircuitError = true;\n  /**\n   * Exception thrown from {@link CircuitBreakerPolicy.execute} when the\n   * circuit breaker is open.\n   */\n  constructor(message = 'Execution prevented because the circuit breaker is open') {\n    super(message);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.d.ts b/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.d.ts
deleted file mode 100644
index 1b66c58..0000000
--- a/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.d.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-import { BrokenCircuitError } from './BrokenCircuitError';
-export declare class IsolatedCircuitError extends BrokenCircuitError {
-    readonly isIsolatedCircuitError = true;
-    /**
-     * Exception thrown from {@link CircuitBreakerPolicy.execute} when the
-     * circuit breaker is open.
-     */
-    constructor();
-}
diff --git a/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.js b/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.js
deleted file mode 100644
index 841ba67..0000000
--- a/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.js
+++ /dev/null
@@ -1,12 +0,0 @@
-import { BrokenCircuitError } from './BrokenCircuitError';
-export class IsolatedCircuitError extends BrokenCircuitError {
-    /**
-     * Exception thrown from {@link CircuitBreakerPolicy.execute} when the
-     * circuit breaker is open.
-     */
-    constructor() {
-        super(`Execution prevented because the circuit breaker is open`);
-        this.isIsolatedCircuitError = true;
-    }
-}
-//# sourceMappingURL=IsolatedCircuitError.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.js.map b/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.js.map
deleted file mode 100644
index 4abb97e..0000000
--- a/node_modules/cockatiel/dist/esm/errors/IsolatedCircuitError.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"IsolatedCircuitError.js","sourceRoot":"","sources":["../../../src/errors/IsolatedCircuitError.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAC;AAE1D,MAAM,OAAO,oBAAqB,SAAQ,kBAAkB;IAG1D;;;OAGG;IACH;QACE,KAAK,CAAC,yDAAyD,CAAC,CAAC;QAPnD,2BAAsB,GAAG,IAAI,CAAC;IAQ9C,CAAC;CACF","sourcesContent":["import { BrokenCircuitError } from './BrokenCircuitError';\n\nexport class IsolatedCircuitError extends BrokenCircuitError {\n  public readonly isIsolatedCircuitError = true;\n\n  /**\n   * Exception thrown from {@link CircuitBreakerPolicy.execute} when the\n   * circuit breaker is open.\n   */\n  constructor() {\n    super(`Execution prevented because the circuit breaker is open`);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.d.ts b/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.d.ts
deleted file mode 100644
index b5cd34e..0000000
--- a/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.d.ts
+++ /dev/null
@@ -1,8 +0,0 @@
-export declare class TaskCancelledError extends Error {
-    readonly message: string;
-    readonly isTaskCancelledError = true;
-    /**
-     * Error thrown when a task is cancelled.
-     */
-    constructor(message?: string);
-}
diff --git a/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.js b/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.js
deleted file mode 100644
index b1c19e4..0000000
--- a/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.js
+++ /dev/null
@@ -1,11 +0,0 @@
-export class TaskCancelledError extends Error {
-    /**
-     * Error thrown when a task is cancelled.
-     */
-    constructor(message = 'Operation cancelled') {
-        super(message);
-        this.message = message;
-        this.isTaskCancelledError = true;
-    }
-}
-//# sourceMappingURL=TaskCancelledError.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.js.map b/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.js.map
deleted file mode 100644
index 328789e..0000000
--- a/node_modules/cockatiel/dist/esm/errors/TaskCancelledError.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"TaskCancelledError.js","sourceRoot":"","sources":["../../../src/errors/TaskCancelledError.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,kBAAmB,SAAQ,KAAK;IAG3C;;OAEG;IACH,YAA4B,UAAU,qBAAqB;QACzD,KAAK,CAAC,OAAO,CAAC,CAAC;QADW,YAAO,GAAP,OAAO,CAAwB;QAL3C,yBAAoB,GAAG,IAAI,CAAC;IAO5C,CAAC;CACF","sourcesContent":["export class TaskCancelledError extends Error {\n  public readonly isTaskCancelledError = true;\n\n  /**\n   * Error thrown when a task is cancelled.\n   */\n  constructor(public readonly message = 'Operation cancelled') {\n    super(message);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/index.d.ts b/node_modules/cockatiel/dist/esm/index.d.ts
deleted file mode 100644
index 748a708..0000000
--- a/node_modules/cockatiel/dist/esm/index.d.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-export * from './backoff/Backoff';
-export * from './breaker/Breaker';
-export * from './BulkheadPolicy';
-export * from './CircuitBreakerPolicy';
-export { Event, EventEmitter, IDisposable } from './common/Event';
-export * from './errors/Errors';
-export * from './FallbackPolicy';
-export * from './NoopPolicy';
-export * from './Policy';
-export * from './RetryPolicy';
-export * from './TimeoutPolicy';
diff --git a/node_modules/cockatiel/dist/esm/index.js b/node_modules/cockatiel/dist/esm/index.js
deleted file mode 100644
index be92af3..0000000
--- a/node_modules/cockatiel/dist/esm/index.js
+++ /dev/null
@@ -1,12 +0,0 @@
-export * from './backoff/Backoff';
-export * from './breaker/Breaker';
-export * from './BulkheadPolicy';
-export * from './CircuitBreakerPolicy';
-export { Event, EventEmitter } from './common/Event';
-export * from './errors/Errors';
-export * from './FallbackPolicy';
-export * from './NoopPolicy';
-export * from './Policy';
-export * from './RetryPolicy';
-export * from './TimeoutPolicy';
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/esm/index.js.map b/node_modules/cockatiel/dist/esm/index.js.map
deleted file mode 100644
index 2d54dbc..0000000
--- a/node_modules/cockatiel/dist/esm/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,mBAAmB,CAAC;AAClC,cAAc,mBAAmB,CAAC;AAClC,cAAc,kBAAkB,CAAC;AACjC,cAAc,wBAAwB,CAAC;AACvC,OAAO,EAAE,KAAK,EAAE,YAAY,EAAe,MAAM,gBAAgB,CAAC;AAClE,cAAc,iBAAiB,CAAC;AAChC,cAAc,kBAAkB,CAAC;AACjC,cAAc,cAAc,CAAC;AAC7B,cAAc,UAAU,CAAC;AACzB,cAAc,eAAe,CAAC;AAC9B,cAAc,iBAAiB,CAAC","sourcesContent":["export * from './backoff/Backoff';\nexport * from './breaker/Breaker';\nexport * from './BulkheadPolicy';\nexport * from './CircuitBreakerPolicy';\nexport { Event, EventEmitter, IDisposable } from './common/Event';\nexport * from './errors/Errors';\nexport * from './FallbackPolicy';\nexport * from './NoopPolicy';\nexport * from './Policy';\nexport * from './RetryPolicy';\nexport * from './TimeoutPolicy';\n"]}
\ No newline at end of file
diff --git a/node_modules/cockatiel/dist/index.d.ts b/node_modules/cockatiel/dist/index.d.ts
index 748a708..f3ef6cc 100644
--- a/node_modules/cockatiel/dist/index.d.ts
+++ b/node_modules/cockatiel/dist/index.d.ts
@@ -3,6 +3,7 @@ export * from './breaker/Breaker';
 export * from './BulkheadPolicy';
 export * from './CircuitBreakerPolicy';
 export { Event, EventEmitter, IDisposable } from './common/Event';
+export { AbortController, AbortSignal, createAbortController } from './common/LocalAbortController';
 export * from './errors/Errors';
 export * from './FallbackPolicy';
 export * from './NoopPolicy';
diff --git a/node_modules/cockatiel/dist/index.js b/node_modules/cockatiel/dist/index.js
index 09208d0..c663c73 100644
--- a/node_modules/cockatiel/dist/index.js
+++ b/node_modules/cockatiel/dist/index.js
@@ -14,7 +14,7 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.EventEmitter = exports.Event = void 0;
+exports.createAbortController = exports.EventEmitter = exports.Event = void 0;
 __exportStar(require("./backoff/Backoff"), exports);
 __exportStar(require("./breaker/Breaker"), exports);
 __exportStar(require("./BulkheadPolicy"), exports);
@@ -22,6 +22,8 @@ __exportStar(require("./CircuitBreakerPolicy"), exports);
 var Event_1 = require("./common/Event");
 Object.defineProperty(exports, "Event", { enumerable: true, get: function () { return Event_1.Event; } });
 Object.defineProperty(exports, "EventEmitter", { enumerable: true, get: function () { return Event_1.EventEmitter; } });
+var LocalAbortController_1 = require("./common/LocalAbortController");
+Object.defineProperty(exports, "createAbortController", { enumerable: true, get: function () { return LocalAbortController_1.createAbortController; } });
 __exportStar(require("./errors/Errors"), exports);
 __exportStar(require("./FallbackPolicy"), exports);
 __exportStar(require("./NoopPolicy"), exports);
diff --git a/node_modules/cockatiel/dist/index.js.map b/node_modules/cockatiel/dist/index.js.map
index 07d4e28..661210d 100644
--- a/node_modules/cockatiel/dist/index.js.map
+++ b/node_modules/cockatiel/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,oDAAkC;AAClC,oDAAkC;AAClC,mDAAiC;AACjC,yDAAuC;AACvC,wCAAkE;AAAzD,8FAAA,KAAK,OAAA;AAAE,qGAAA,YAAY,OAAA;AAC5B,kDAAgC;AAChC,mDAAiC;AACjC,+CAA6B;AAC7B,2CAAyB;AACzB,gDAA8B;AAC9B,kDAAgC","sourcesContent":["export * from './backoff/Backoff';\nexport * from './breaker/Breaker';\nexport * from './BulkheadPolicy';\nexport * from './CircuitBreakerPolicy';\nexport { Event, EventEmitter, IDisposable } from './common/Event';\nexport * from './errors/Errors';\nexport * from './FallbackPolicy';\nexport * from './NoopPolicy';\nexport * from './Policy';\nexport * from './RetryPolicy';\nexport * from './TimeoutPolicy';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,oDAAkC;AAClC,oDAAkC;AAClC,mDAAiC;AACjC,yDAAuC;AACvC,wCAAkE;AAAzD,8FAAA,KAAK,OAAA;AAAE,qGAAA,YAAY,OAAA;AAC5B,sEAAoG;AAA7D,6HAAA,qBAAqB,OAAA;AAC5D,kDAAgC;AAChC,mDAAiC;AACjC,+CAA6B;AAC7B,2CAAyB;AACzB,gDAA8B;AAC9B,kDAAgC","sourcesContent":["export * from './backoff/Backoff';\nexport * from './breaker/Breaker';\nexport * from './BulkheadPolicy';\nexport * from './CircuitBreakerPolicy';\nexport { Event, EventEmitter, IDisposable } from './common/Event';\nexport { AbortController, AbortSignal, createAbortController } from './common/LocalAbortController';\nexport * from './errors/Errors';\nexport * from './FallbackPolicy';\nexport * from './NoopPolicy';\nexport * from './Policy';\nexport * from './RetryPolicy';\nexport * from './TimeoutPolicy';\n"]}
\ No newline at end of file
