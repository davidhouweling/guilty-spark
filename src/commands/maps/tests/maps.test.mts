import { describe, it, beforeEach, expect, vi } from "vitest";
import type {
  APIInteractionResponseChannelMessageWithSource,
  APIApplicationCommandInteraction,
  APIMessageComponentButtonInteraction,
  APIInteractionResponseCallbackData,
  APIMessage,
  APIActionRowComponent,
  APIComponentInMessageActionRow,
} from "discord-api-types/v10";
import {
  ApplicationCommandOptionType,
  ApplicationCommandType,
  InteractionType,
  Locale,
  ComponentType,
  MessageFlags,
  ButtonStyle,
} from "discord-api-types/v10";
import { MapsCommand, PlaylistType, InteractionButton } from "../maps.mjs";
import { installFakeServicesWith } from "../../../services/fakes/services.mjs";
import type { Services } from "../../../services/install.mjs";
import { aFakeEnvWith } from "../../../base/fakes/env.fake.mjs";
import {
  fakeBaseAPIApplicationCommandInteraction,
  fakeButtonClickInteraction,
} from "../../../services/discord/fakes/data.mjs";

// Local types for Discord components (since discord-api-types does not export them)
interface LocalButtonComponent {
  type: ComponentType.Button;
  custom_id: string;
  style: number;
}
interface LocalActionRow {
  type: ComponentType.ActionRow;
  components: LocalButtonComponent[];
}
type LocalComponent = LocalActionRow | LocalButtonComponent | { type: ComponentType };

function aFakeMapsInteractionWith(
  options: { name: string; value: unknown; type: number }[] = [],
): APIApplicationCommandInteraction {
  const applicationCommandInteractionMap: APIApplicationCommandInteraction = {
    ...fakeBaseAPIApplicationCommandInteraction,
    type: InteractionType.ApplicationCommand,
    guild: {
      features: [],
      id: "fake-guild-id",
      locale: Locale.EnglishUS,
    },
    guild_id: "fake-guild-id",
    data: {
      id: "fake-cmd-id",
      name: "maps",
      options,
      resolved: {},
      type: ApplicationCommandType.ChatInput,
    },
  };

  return applicationCommandInteractionMap;
}

function getButtonRow(components: LocalComponent[] | undefined): LocalActionRow | undefined {
  return components?.find(
    (c): c is LocalActionRow => c.type === ComponentType.ActionRow && "components" in c && Array.isArray(c.components),
  );
}
function getButtonById(row: LocalActionRow | undefined, custom_id: string): LocalButtonComponent | undefined {
  return row?.components.find((b): b is LocalButtonComponent => b.custom_id === custom_id);
}
function isActionRow(component: unknown): component is { type: ComponentType.ActionRow; components: unknown[] } {
  return (
    typeof component === "object" &&
    component !== null &&
    "type" in component &&
    "components" in component &&
    Array.isArray((component as { components: unknown[] }).components)
  );
}

describe("MapsCommand", () => {
  let command: MapsCommand;
  let services: Services;
  const env = aFakeEnvWith();

  beforeEach(() => {
    services = installFakeServicesWith({ env });
    command = new MapsCommand(services, env);
    vi.spyOn(services.logService, "error").mockImplementation(() => undefined);
    vi.spyOn(services.discordService, "getEmojiFromName").mockReturnValue(":GameCoachGG:");
  });

  describe("/maps basic usage", () => {
    it("returns a set of 5 maps by default", () => {
      const interaction = aFakeMapsInteractionWith();
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      expect(data).toHaveProperty("embeds");

      const embed = data.embeds?.[0];
      expect(embed).toBeDefined();
      expect(embed?.title).toContain(`Maps: ${PlaylistType.HcsCurrent}`);
      expect(embed?.fields?.length).toBeGreaterThanOrEqual(3); // #, Mode, Map columns + attribution
      expect(embed?.fields?.[0]?.value.split("\n")).toHaveLength(5);
      expect(embed?.fields?.some((f) => f.value.includes("Generated by"))).toBe(true);
      expect(data.components?.[0]?.type).toBe(ComponentType.ActionRow);

      const buttonRow = getButtonRow(data.components);
      expect(buttonRow).toBeDefined();
      expect(buttonRow?.components).toHaveLength(4);
      expect(getButtonById(buttonRow, InteractionButton.Roll5)?.style).toBe(ButtonStyle.Primary);
    });

    it("returns a set of 3 maps when count=3", () => {
      const interaction = aFakeMapsInteractionWith([
        { name: "count", value: 3, type: ApplicationCommandOptionType.Integer },
      ]);
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      const embed = data.embeds?.[0];

      expect(embed?.fields?.[0]?.value.split("\n")).toHaveLength(3);

      const buttonRow3 = getButtonRow(data.components);
      expect(getButtonById(buttonRow3, InteractionButton.Roll3)?.style).toBe(ButtonStyle.Primary);
    });

    it("returns a set of 7 maps when count=7", () => {
      const interaction = aFakeMapsInteractionWith([
        { name: "count", value: 7, type: ApplicationCommandOptionType.Integer },
      ]);
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      const embed = data.embeds?.[0];

      expect(embed?.fields?.[0]?.value.split("\n")).toHaveLength(7);

      const buttonRow7 = getButtonRow(data.components);
      expect(getButtonById(buttonRow7, InteractionButton.Roll7)?.style).toBe(ButtonStyle.Primary);
    });
  });

  describe("/maps playlist option", () => {
    it("returns maps from the historical playlist when selected", () => {
      const interaction = aFakeMapsInteractionWith([
        { name: "playlist", value: PlaylistType.HcsHistorical, type: ApplicationCommandOptionType.String },
      ]);
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      const embed = data.embeds?.[0];

      expect(embed).toBeDefined();
      expect(embed?.title).toContain(PlaylistType.HcsHistorical);
      expect(embed?.fields?.[0]?.value.split("\n")).toHaveLength(5);
    });

    it("returns maps from the current playlist by default", () => {
      const interaction = aFakeMapsInteractionWith();
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      const embed = data.embeds?.[0];

      expect(embed).toBeDefined();
      expect(embed?.title).toContain(PlaylistType.HcsCurrent);
      expect(embed?.fields?.[0]?.value.split("\n")).toHaveLength(5);
    });
  });

  describe("/maps button interaction", () => {
    function aFakeButtonInteraction(
      custom_id: string,
      playlist: PlaylistType = PlaylistType.HcsCurrent,
    ): APIMessageComponentButtonInteraction {
      return {
        ...fakeButtonClickInteraction,
        data: {
          ...fakeButtonClickInteraction.data,
          custom_id,
        },
        message: {
          ...fakeButtonClickInteraction.message,
          embeds: [{ title: `Maps: ${playlist}` }],
        },
      };
    }

    it("regenerates maps with correct count and playlist when button is pressed", () => {
      const interaction = aFakeButtonInteraction(InteractionButton.Roll3, PlaylistType.HcsHistorical);
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      const embed = data.embeds?.[0];

      expect(embed?.title).toContain(PlaylistType.HcsHistorical);
      expect(embed?.fields?.[0]?.value.split("\n")).toHaveLength(3);

      const buttonRowHist = getButtonRow(data.components);
      expect(getButtonById(buttonRowHist, InteractionButton.Roll3)?.style).toBe(ButtonStyle.Primary);
    });

    it("throws for unknown button id", () => {
      const interaction = aFakeButtonInteraction("btn_maps_roll_unknown");
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;

      expect(data.content).toMatch(/Unknown button interaction/);
      expect(data.flags).toBe(MessageFlags.Ephemeral);
    });

    it("throws for unknown playlist in embed", () => {
      const interaction = aFakeButtonInteraction(InteractionButton.Roll1, "NotAPlaylist" as PlaylistType);
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;

      expect(data.content).toMatch(/Unknown playlist type in embed/);
      expect(data.flags).toBe(MessageFlags.Ephemeral);
    });

    it("returns DeferredMessageUpdate and jobToComplete for Initiate button", async () => {
      const interaction = aFakeButtonInteraction(InteractionButton.Initiate);
      const { response, jobToComplete } = command.execute(interaction);
      expect(response).toEqual({ type: 6 }); // InteractionResponseType.UpdateMessage
      expect(typeof jobToComplete).toBe("function");

      // Spy on createMessage
      const createMessageSpy = vi
        .spyOn(services.discordService, "createMessage")
        .mockResolvedValue(undefined as unknown as APIMessage);
      await jobToComplete?.();
      const [channelId, data] = createMessageSpy.mock.calls[0] as [string, APIInteractionResponseCallbackData];
      expect(channelId).toBe(interaction.channel.id);
      expect(data.embeds?.[0]?.title).toContain("Maps: HCS - current");
      const actionRow = data.components?.find(isActionRow) as
        | APIActionRowComponent<APIComponentInMessageActionRow>
        | undefined;
      expect(actionRow?.components).toHaveLength(4);
    });
  });

  describe("/maps uniqueness and spread", () => {
    it("does not repeat maps in a short series", () => {
      const interaction = aFakeMapsInteractionWith([
        { name: "count", value: 3, type: ApplicationCommandOptionType.Integer },
      ]);
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      const embed = data.embeds?.[0];
      const maps = embed?.fields?.[2]?.value.split("\n") ?? [];
      const uniqueMaps = new Set(maps);

      expect(uniqueMaps.size).toBe(maps.length);
    });

    it("allows repeats only after all maps are used in a long series", () => {
      const interaction = aFakeMapsInteractionWith([
        { name: "count", value: 7, type: ApplicationCommandOptionType.Integer },
      ]);
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;
      const embed = data.embeds?.[0];
      const maps = embed?.fields?.[2]?.value.split("\n") ?? [];
      const uniqueMaps = new Set(maps);

      expect(uniqueMaps.size).toBeLessThanOrEqual(maps.length);
      expect(uniqueMaps.size).toBeGreaterThanOrEqual(5); // At least 5 unique maps in a Bo7
    });
  });

  describe("/maps error handling", () => {
    it("returns an error message if something throws", () => {
      vi.spyOn(Object.getPrototypeOf(command), "generateHcsSet").mockImplementation(() => {
        throw new Error("fail");
      });

      const interaction = aFakeMapsInteractionWith();
      const { response } = command.execute(interaction);
      const { data } = response as APIInteractionResponseChannelMessageWithSource;

      expect(data.content).toMatch(/fail/);
      expect(data.flags).toBe(MessageFlags.Ephemeral);
    });
  });
});
