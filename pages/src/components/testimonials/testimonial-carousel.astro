---
export interface TestimonialItem {
  text: string;
  who: string;
  discordServer: string;
  discordLink?: string;
}

interface Props {
  id?: string;
  items: readonly TestimonialItem[];
  autoRotateMs?: number;
}

const { id = "testimonial-carousel", items, autoRotateMs = 3000 }: Props = Astro.props;
import styles from "../../styles/components/testimonial-carousel.module.css";

if (!Array.isArray(items) || items.length === 0) {
  throw new Error("TestimonialCarousel requires at least one testimonial");
}

const slideCount = items.length;
---

<section
  class={styles.testimonialCarousel}
  aria-label="Discord community testimonials"
  data-carousel-root
  data-carousel-rotate={autoRotateMs}
>
  <div class={styles.carouselWindow} data-carousel-window>
    <div class={styles.carouselTrack} role="presentation" data-carousel-track>
      {
        items.map((item, index) => {
          const slideId = `${id}-slide-${index}`;
          const tabId = `${id}-tab-${index}`;
          const isActive = index === 0;

          // Split text into paragraphs on double newlines
          const text: string = item.text;
          const paragraphs: readonly string[] = text.split("\n\n");

          return (
            <article
              id={slideId}
              class={`${styles.testimonialCard}${isActive ? " is-active" : ""}`}
              role="tabpanel"
              aria-roledescription="slide"
              aria-label={`Testimonial ${index + 1} of ${slideCount}`}
              aria-labelledby={tabId}
              aria-hidden={isActive ? "false" : "true"}
              tabindex={isActive ? "0" : "-1"}
              data-carousel-slide
              data-index={index}
            >
              <div class={styles.testimonialText}>
                {paragraphs.map((paragraph: string) => {
                  // Split each paragraph on single newlines for line breaks
                  const lines: string[] = paragraph.split("\n");
                  return (
                    <p>
                      {lines.map((line: string, lIndex: number) => (
                        <>
                          {line}
                          {lIndex < lines.length - 1 && <br />}
                        </>
                      ))}
                    </p>
                  );
                })}
              </div>
              <footer class={styles.testimonialMeta}>
                <span class={styles.testimonialWho}>{item.who}</span>
                {item.discordLink ? (
                  <a
                    href={item.discordLink}
                    target="_blank"
                    rel="noopener noreferrer"
                    class={styles.testimonialServerLink}
                  >
                    <span class={styles.testimonialServer}>{item.discordServer}</span>
                  </a>
                ) : (
                  <span class={styles.testimonialServer}>{item.discordServer}</span>
                )}
              </footer>
            </article>
          );
        })
      }
    </div>
  </div>

  <div class={styles.carouselControls} role="tablist" aria-label="Select testimonial">
    {
      items.map((_item, index) => {
        const tabId = `${id}-tab-${index}`;
        const slideId = `${id}-slide-${index}`;
        const isActive = index === 0;

        return (
          <button
            id={tabId}
            type="button"
            role="tab"
            aria-selected={isActive ? "true" : "false"}
            aria-controls={slideId}
            tabindex={isActive ? "0" : "-1"}
            class={`${styles.carouselDot}${isActive ? " is-active" : ""}`}
            data-carousel-dot
            data-index={index}
          >
            <span class={styles.visuallyHidden}>Testimonial {index + 1}</span>
          </button>
        );
      })
    }
  </div>
</section>

<script is:inline>
  (() => {
    const script = document.currentScript;
    if (!script) {
      return;
    }

    const previous = script.previousElementSibling;
    const rootCandidate =
      previous instanceof HTMLElement && previous.matches("[data-carousel-root]")
        ? previous
        : script.parentElement?.querySelector(":scope > [data-carousel-root]");

    if (!(rootCandidate instanceof HTMLElement)) {
      return;
    }

    const root = rootCandidate;
    const windowEl = root.querySelector("[data-carousel-window]");
    const track = root.querySelector("[data-carousel-track]");
    const slides = Array.from(root.querySelectorAll("[data-carousel-slide]"));
    const dots = Array.from(root.querySelectorAll("[data-carousel-dot]"));
    const autoRotateMs = Number(root.getAttribute("data-carousel-rotate"));

    if (
      !(windowEl instanceof HTMLElement) ||
      !(track instanceof HTMLElement) ||
      slides.length === 0 ||
      dots.length === 0 ||
      !Number.isFinite(autoRotateMs)
    ) {
      return;
    }

    let activeIndex = slides.findIndex((slide) => slide.classList.contains("is-active"));
    if (activeIndex === -1) {
      activeIndex = 0;
    }

    const reduceMotionQuery =
      typeof window.matchMedia === "function" ? window.matchMedia("(prefers-reduced-motion: reduce)") : undefined;

    const prefersReducedMotion = () => reduceMotionQuery?.matches === true;
    const shouldRotate = () => autoRotateMs > 0 && !prefersReducedMotion();

    const clearSlideState = (slide) => {
      slide.classList.remove("is-glitching-in", "is-glitching-out");
    };

    const setInactiveAttributes = (slide) => {
      slide.setAttribute("aria-hidden", "true");
      slide.setAttribute("tabindex", "-1");
      slide.removeAttribute("data-active");
    };

    const setActiveAttributes = (slide) => {
      slide.setAttribute("aria-hidden", "false");
      slide.setAttribute("tabindex", "0");
      slide.setAttribute("data-active", "true");
    };

    slides.forEach((slide, index) => {
      if (index === activeIndex) {
        setActiveAttributes(slide);
      } else {
        setInactiveAttributes(slide);
      }
    });

    const applyTrackTransform = (index) => {
      const offset = index * -100;
      track.style.transform = `translateX(${offset}%)`;
      track.setAttribute("data-active-index", String(index));
    };

    root.setAttribute("data-carousel-ready", "true");
    applyTrackTransform(activeIndex);

    const setActive = (nextIndex, options = {}) => {
      if (nextIndex === activeIndex || nextIndex < 0 || nextIndex >= slides.length) {
        return;
      }

      const currentSlide = slides[activeIndex];
      const nextSlide = slides[nextIndex];
      const currentDot = dots[activeIndex];
      const nextDot = dots[nextIndex];

      clearSlideState(currentSlide);
      clearSlideState(nextSlide);

      currentDot.classList.remove("is-active");
      currentDot.setAttribute("aria-selected", "false");

      nextDot.classList.add("is-active");
      nextDot.setAttribute("aria-selected", "true");

      if (options.focusDot) {
        nextDot.focus({ preventScroll: true });
      }

      setInactiveAttributes(currentSlide);
      setActiveAttributes(nextSlide);

      currentSlide.classList.remove("is-active");
      nextSlide.classList.add("is-active");

      applyTrackTransform(nextIndex);

      if (!prefersReducedMotion()) {
        currentSlide.classList.add("is-glitching-out");
        nextSlide.classList.add("is-glitching-in");

        const handleExitEnd = () => {
          currentSlide.classList.remove("is-glitching-out");
          currentSlide.removeEventListener("animationend", handleExitEnd);
        };

        const handleEnterEnd = () => {
          nextSlide.classList.remove("is-glitching-in");
          nextSlide.removeEventListener("animationend", handleEnterEnd);
        };

        currentSlide.addEventListener("animationend", handleExitEnd, { once: true });
        nextSlide.addEventListener("animationend", handleEnterEnd, { once: true });
      }

      activeIndex = nextIndex;
    };

    const advance = (step) => {
      const nextIndex = (activeIndex + step + slides.length) % slides.length;
      setActive(nextIndex);
    };

    let intervalId = null;

    const startAutoRotate = () => {
      if (!shouldRotate() || intervalId !== null) {
        return;
      }

      intervalId = window.setInterval(() => {
        advance(1);
      }, autoRotateMs);
    };

    startAutoRotate();

    const pause = () => {
      if (intervalId === null) {
        return;
      }

      window.clearInterval(intervalId);
      intervalId = null;
    };

    const resume = () => {
      startAutoRotate();
    };

    dots.forEach((dot) => {
      const index = Number(dot.getAttribute("data-index"));

      dot.addEventListener("click", () => {
        pause();
        setActive(index);
        resume();
      });

      dot.addEventListener("keydown", (event) => {
        if (event.key === "ArrowRight" || event.key === "ArrowDown") {
          event.preventDefault();
          pause();
          const nextIndex = (activeIndex + 1) % slides.length;
          setActive(nextIndex, { focusDot: true });
          resume();
        }

        if (event.key === "ArrowLeft" || event.key === "ArrowUp") {
          event.preventDefault();
          pause();
          const nextIndex = (activeIndex - 1 + slides.length) % slides.length;
          setActive(nextIndex, { focusDot: true });
          resume();
        }
      });
    });

    root.addEventListener("mouseenter", pause);
    root.addEventListener("mouseleave", resume);
    root.addEventListener("focusin", pause);
    root.addEventListener("focusout", () => {
      if (!root.contains(document.activeElement)) {
        resume();
      }
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        pause();
      } else {
        resume();
      }
    });

    if (reduceMotionQuery) {
      const handleMotionChange = () => {
        if (!shouldRotate()) {
          pause();
        } else {
          resume();
        }
      };

      reduceMotionQuery.addEventListener("change", handleMotionChange);
    }
  })();
</script>
